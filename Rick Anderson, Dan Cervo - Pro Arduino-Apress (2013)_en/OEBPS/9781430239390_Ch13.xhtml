<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 13 Arduino Test Suite</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap13" />CHAPTER 13</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">Arduino Test Suite</p>
<div>
<p class="noindent">Whether you are creating projects, sketches, or examples, testing is a skill that you will need. When you are developing a product to share or sell, it is critical that both your hardware and software behave as expected. Having a test helps people learn about how your project works. The Arduino Test Suite<a id="cXXX.259a" /> provides a way to prove that your product is functioning correctly. Incorporating tests into a project helps highlight the fixes and improvements that you have made. Additionally, using the social coding principles we described in <a href="9781430239390_Ch02.xhtml">Chapter 2</a>, users are encouraged to submit issues to <span class="FontName2"><a href="http://github.com/arduino/tests">http://github.com/arduino/tests</a></span>, including test examples, to demonstrate problems and verify the resolution of those problems. The more confidence people have in your product, the better.</p>
<p class="indent">The Arduino Test Suite library allows you to create a standard test suite for your own software and the Arduino software. This library provides a simple, standard way to build these tests. Each test suite run provides output formatted in the Arduino test result format. This output can be parsed by continuous integration testing software, like Jenkins, which can be found at <span class="FontName2"><a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a></span>. These tests can be added to your project&#x2019;s official list of automatic tests, which run every time code is changed in the project&#x2019;s repository.</p>
<p class="indent">In this chapter, I will</p>
<ul class="bulleted">
<li>Go through the basic features of the Arduino Test Suite</li>
<li>Show how the built-in tests can be used with a custom test shield</li>
<li>Provide a basic procedure using the Arduino Test Suite to create a comprehensive test that tests your project and code libraries</li>
<li>Provide an example of testing memory usage</li>
<li>Show an example of how to test the Serial Peripheral Interface (SPI) library</li>
</ul>
<p class="indent">You are encouraged to create your own tests and submit them as official tests. They way this occurs is that you would &#x201C;fork&#x201D; the project, and create a new tests or modify an existing test for the project in your own repository. Then send a pull request for the change to the Arduino Test project in GitHub. This process is described in detail described in <a href="9781430239390_Ch02.xhtml">Chapter 2</a>. You can also file issues for the project that suggest changes and improvements.</p>
<p id="Sec1" class="Heading1">Installing the Arduino Test Suite</p>
<p class="noindent">The Arduino Test Suite is located on GitHub<a id="cXXX.546" /> in the Arduino Tests project, at <span class="FontName2"><a href="http://github.com/arduino/tests">http://github.com/arduino/tests</a></span>. You can download, install, or clone the code into your sketch library folder<a id="cXXX.547" />. In this case, since the Arduino Test Suite is an Arduino library, the code will be installed in your <span class="FontName2">libraries</span> folder.</p>
<p class="indent">You can download the library from the <span class="FontName2"><a href="http://github.com/arduino.tests">http://github.com/arduino.tests</a></span> download link, or, if you have installed Git, as explained in <a href="9781430239390_Ch02.xhtml">Chapter 2</a>, you can issue the following command from <span class="FontName2">libraries</span> directory:</p>
<pre><span class="FontName2">git clone</span> <span class="FontName2"><a href="https://github.com/arduino/Tests">https://github.com/arduino/Tests</a></span>&#160;&#160;<span class="FontName2">ArduinoTestSuite</span></pre>
<p class="indent">When you restart Arduino, the Arduino Test Suite will appear in the user-contributed libraries, as shown in <a href="#Fig1" id="_Fig1">Figure 13-1</a>. All of the example tests are in a dedicated folder in the <span class="FontName2">Tests</span> library, and these can be loaded from the Examples drop-down list in the Arduino IDE.</p>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig13-01.jpg" alt="9781430239390_Fig13-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 13-1</a>. </span>Arduino Test Suite installed in the sketch library folder </p>
</div>
<p class="indent">To verify that Arduino Test Suite is working, compile and upload the <span class="FontName2">ATS_Constants</span> example sketch to your hardware, as shown in <a href="#list1" id="_list1">Listing 13-1</a>. On the serial monitor, you should see each result come back as <span class="FontName2">OK</span>. This indicates a successful test.</p>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 13-1.</i></b></a>&#160;&#160;Arduino Test of Arduino Constants<a id="cXXX.548" /></p>
<pre><span class="FontName2">#include&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#x003C;ArduinoTestSuite.h&#x003E;</span><br /><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; startMemoryUsage;</span><br /><br />&#160;<span class="FontName2">//Start memory usage must be site prior to ATS_begin</span><br />&#160;&#160;<span class="FontName2">startMemoryUsage&#160;&#160;&#160;&#160;&#160;&#160;=&#160;&#160;&#160;&#160;&#160;&#160; ATS_GetFreeMemory();</span><br />&#160;&#160;<span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;Test of Arduino Constants&quot;);</span><br />&#160;&#160;<span class="FontName2">/*</span><br />&#160;&#160; <span class="FontName2">* Test Run Start</span><br />&#160;&#160; <span class="FontName2">*/</span><br /><br />&#160;&#160;<span class="FontName2">//test true constant</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;1. Test of true constant&quot;, true == 1);</span><br /><br />&#160;&#160;<span class="FontName2">//test false consts</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;2. Test of false constant&quot;, false == 0);</span><br /><br />&#160;&#160;<span class="FontName2">//Test of HIGH == 1</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;3. Test of HIGH == 1&quot;, HIGH == 1);</span><br /><br />&#160;&#160;<span class="FontName2">//Test of LOW ==&#160;&#160;0</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;4. Test of LOW ==&#160;&#160;0&quot;, LOW == 0);</span><br /><br />&#160;&#160;<span class="FontName2">???//Test of INPUT == 1</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;5. Test of INPUT == 1&quot;, INPUT == 1);</span><br /><br />&#160;&#160;<span class="FontName2">???//Test of OUTPUT ==&#160;&#160;0</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;6. Test of OUTPUT ==&#160;&#160;0&quot;, OUTPUT == 0);</span><br /><br />&#160;&#160;<span class="FontName2">//test decimal</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;7. Test of decimal constant&quot;, 101 == ((1 * pow(10,2)) + (0 * pow(10,1)) + 1));</span><br /><br />&#160;&#160;<span class="FontName2">//test binary</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;8. Test of binary constant&quot;, B101 == 5);</span><br /><br />&#160;&#160;<span class="FontName2">//test octal</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;9. Test of octal constant&quot;, 0101 == 65);</span><br /><br />&#160;&#160;<span class="FontName2">//test hexadecimal</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus( &quot;7. Test of hexadecimal constant&quot;, (0x101 == 257));</span><br /><br />&#160;&#160;<span class="FontName2">/*</span><br />&#160;&#160;<span class="FontName2">* Test Run End</span><br />&#160;&#160; <span class="FontName2">*/</span><br />&#160;&#160;<span class="FontName2">ATS_ReportMemoryUsage(startMemoryUsage);</span><br />&#160;&#160;<span class="FontName2">ATS_end();</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Once the code is uploaded to the Arduino, you can connect to the serial port and view the test results. They should look like <a href="#Fig2" id="_Fig2">Figure 13-2</a>.</p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig13-02.jpg" alt="9781430239390_Fig13-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 13-2</a>. </span>Arduino test results </p>
</div>
<p class="indent"><a href="#Fig2">Figure 13-2</a> shows the results of 11 tests, all which passed with an OK. If any of these tests fail, something is likely wrong with your Arduino environment, since the constants should always be defined. Now you are ready to run the example tests and create your own tests.</p>
<p id="Sec2" class="Heading1">Getting Started with Testing</p>
<p class="noindent">Testing Arduino helps to verify your hardware configuration<a id="cXXX.549" /> and the logic of your software, and ensures that your Arduino-inspired board works exactly as expected. To begin, brainstorm the things that you want to test. Create a list and focus on one area at a time. It is effective to number the tests in your sketch and systematically work through each area. Each test you create should test one condition and verify the pass or fail result. In some cases, a function or a value is supposed to have&#160;&#160;false value as an expected result to be the success if the output is correct it&#x2019;s considered a success.</p>
<p class="indent">Within the Arduino community, it is common to use examples instead of tests. Examples function similarly to tests, but while a test results in either pass or fail, an example allows you to compare what you thought would happen to what actually happens. There are many reasons for testing, including debugging code and observing the behavior of a remote control or line-following robot. Even more importantly, when we create libraries<a id="cXXX.262a" /> to share with others, we want to ensure that the code works and is easy for people to use. The goal of the Arduino Test Suite is to convert examples into official tests, which you can distribute with your libraries and sample codes, allowing others to learn from them. When someone files an issue against your code, they (or you) can add a test that shows where and how the problem was fixed.</p>
<p class="indent">The Arduino Test Suite comes with a test skeleton<a id="cXXX.550" />. This is the smallest test possible, which makes it a good starter sketch. This is shown in <a href="#list2" id="_list2">Listing 13-2</a>.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 13-2.</i></b></a>&#160;&#160;Minimal Test Sketch<a id="cXXX.551" /></p>
<pre><span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span><br /><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;My bare bones tests&quot;);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">testTrue();</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_end();</span><br /><span class="FontName2">}</span><br /><span class="FontName2">void testTrue()</span><br /><span class="FontName2">{</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">boolean result;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">result = true;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_PrintTestStatus(&quot;My bare bones test&quot;, result);</span><br /><span class="FontName2">}</span><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span></pre>
<p class="indent"><a href="#list2">Listing 13-2</a> shows the standard sketch structure<a id="cXXX.552" />. The tests are placed in <span class="FontName2">setup()</span>, so they are only run once. They can also be placed in <span class="FontName2">loop()</span>, which would run them multiple times; this can be useful if you are testing time and repetition issues. You can put your tests in <span class="FontName2">loop()</span> as long as you include <span class="FontName2">while(1){}</span> after the tests are complete.</p>
<p class="indent">In order to access the tests, you need to import the Arduino Test Suite with the <span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span> line. Remember that tests need a name and an expected result. In this case, we create a Boolean variable called <span class="FontName2">result</span>. Our goal is to show that the result is <span class="FontName2">TRUE</span>. Here&#x2019;s where we begin:</p>
<pre>&#160;<span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;My bare bones tests&quot;);</span></pre>
<p class="indent">This sets up the test suite run and initializes the starting conditions. Then you can do anything you need to, including setting up variables, calling libraries, and calling any function that you are testing. The test result is set as an outcome of the code, and the status is printed to the serial port:</p>
<pre><span class="FontName2">ATS_PrintTestStatus(&quot;My bare bones test&quot;, result);</span></pre>
<p class="indent">Finally, once <span class="FontName2">ATS_end()</span><a id="cXXX.553" /> is called, the test is over and you can clean up.</p>
<p class="indent">An even better option for testing is to place each test in its own function. That way, it is more clearly isolated from other tests and side effects are largely avoided.</p>
<p class="indent">The results of the tests appear in the serial monitor format<a id="cXXX.554" /> shown in <a href="#list3" id="_list3">Listing 13-3</a>.</p>
<p class="noindent2"><a href="#_list3" id="list3"><b><i>Listing 13-3.</i></b></a>&#160;&#160;Minimal Test Sketch Results</p>
<pre><span class="FontName2">info.MANUFACTURER&#160;&#160;&#160;&#160;= Arduino</span><br /><span class="FontName2">info.CPU-NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= ATmega328P</span><br /><span class="FontName2">info.GCC-Version&#160;&#160;&#160;&#160; = 4.3.2</span><br /><span class="FontName2">info.AVR-LibC-Ver&#160;&#160;&#160;&#160;= 1.6.4</span><br /><span class="FontName2">info.Compiled-date&#160;&#160; = Oct 20 2010</span><br /><span class="FontName2">info.Test-Suite-Name = My bare bones tests</span><br /><span class="FontName2">info.Free-memory&#160;&#160;&#160;&#160; = 1464 bytes</span><br /><span class="FontName2">My bare bones test&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;... ok</span><br /><span class="FontName2">--------------------------</span><br /><span class="FontName2">Ran 1 tests in 1.371s</span><br /><br /><span class="FontName2">OK</span></pre>
<p class="indent">The final <span class="FontName2">OK</span> shows that all tests passed and took a total time of 1.31 seconds. They passed because we created a result variable that held a <span class="FontName2">true</span> value, which was then passed to the <span class="FontName2">ATS_PrintTestStatus()</span> function<a id="cXXX.555" /><a id="cXXX.556" />. It has this function signature:</p>
<pre><span class="FontName2">void&#160;&#160;&#160;&#160;ATS_PrintTestStatus(</span><i>char *testString</i><span class="FontName2">,</span> <i>boolean passed</i> <span class="FontName2">);</span></pre>
<p class="indent">This <span class="FontName1"><i>char *testString</i></span> <a id="cXXX.557" />is the test name, and <span class="FontName1"><i>boolean passed</i></span> is the test result.</p>
<p id="Sec3" class="Heading1">Arduino Test Result Format<a id="cXXX.264c" /></p>
<p class="noindent">The Arduino test result format is based on the standard test format used by the Nose testing library from Python (<span class="FontName2"><a href="https://nose.readthedocs.org/en/latest/">https://nose.readthedocs.org/en/latest/</a></span>).<a id="cXXX.558" /><a id="cXXX.559" /> This format uses verbose mode so that all tests are listed with their outcomes. The output of the format is compatible with several different automated test systems. Since memory is limited and we want to preserve it for the tests as opposed to the testing library, this format is not based on an XML format. Each test must be discrete, and if one element fails, the incomplete XML file will be invalid and unusable. However, you can parse the output and change it to an xUnit test structure<a id="cXXX.560" />.</p>
<p class="indent">Another common use of the Arduino Test Suite is to use it to test the compiler toolchain<a id="cXXX.561" /> to ensure that the compiler, and it&#x2019;s support programs&#160;&#160;running your code properly. It is important for nonstandard compilers to check if an Arduino compiler upgrade is compatible with the Arduino API. The result format has a set of common data that allows you to know what toolchain your code is being compiled against. This is helpful because you can verify an upgraded GCC compiler or AVR-libc and be assured that your code functions<a id="cXXX.264a" />, thanks to a passing test result. Another feature of the format is the ability to identify the manufacturer so you know what platform and microcontroller you are testing against. This way, you can test an entire family of Arduinos and clones and know that they are compatible with your code, libraries, or project. Each test has a date, time, and name, so you can keep track of the different tests.</p>
<div>
<p id="Sec4" class="Heading2">Test Result Section Format Details</p>
<p class="noindent">The test result file begins with information data<a id="cXXX.562" />. This is indicated by the <span class="FontName2">info.</span> at the beginning of the line, as shown in <a href="#list4" id="_list4">Listing 13-4</a>.</p>
<p class="noindent2"><a href="#_list4" id="list4"><b><i>Listing 13-4.</i></b></a>&#160;&#160;Test Header Info Fields</p>
<pre><span class="FontName2">info.MANUFACTURER&#160;&#160;&#160;&#160;= Arduino</span><br /><span class="FontName2">info.CPU-NAME&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= ATmega328P</span><br /><span class="FontName2">info.GCC-Version&#160;&#160;&#160;&#160; = 4.3.2</span><br /><span class="FontName2">info.AVR-LibC-Ver&#160;&#160;&#160;&#160;= 1.6.4</span><br /><span class="FontName2">info.Compiled-date&#160;&#160; = Oct&#160;&#160;4 2010</span><br /><span class="FontName2">info.Test-Suite-Name = general</span></pre>
<p class="indent">The header information section is followed by the test section, which includes the test results.</p>
<div>
<p id="Sec5" class="Heading3">Test-Naming Structure<a id="cXXX.563" /></p>
<p class="noindent">The test format is identical for all tests. This makes it easier for other software to parse them. The format includes the following items in the following order:</p>
<ol class="OrderedList">
<li>The test name</li>
<li>Information about the test (included in parentheses)</li>
<li>Ellipsis points (i.e., <span class="FontName2">...</span>)</li>
<li>The test result status</li>
</ol>
<p class="indent">The following line shows an example:</p>
<pre><i>name of test</i><span class="FontName2">(</span><i>information about test</i><span class="FontName2">) ...</span><i>test result status</i></pre>
</div>
<div>
<p id="Sec6" class="Heading3">Test Status Options<a id="cXXX.564" /></p>
<p class="noindent">The tests themselves only have three valid outcomes: success, failure, or error:</p>
<pre><span class="FontName2">ok</span><br /><span class="FontName2">FAIL</span><br /><span class="FontName2">ERROR</span></pre>
</div>
<div>
<p id="Sec7" class="Heading3">Test Summary</p>
<p class="noindent">That last section of the test is a summary<a id="cXXX.565" />. It includes information such as how many tests were run, how long they took, and how many failures occurred. The test result summary is separated from the test by dashes, like so:</p>
<pre><span class="FontName2">--------------------------</span></pre>
<p class="indent">Here&#x2019;s an example of the summary format, followed by final condition:</p>
<pre><span class="FontName2">Ran</span> <b>n</b> <span class="FontName2">tests in</span> <b>Secs</b> <br /><br /><span class="FontName2">OK</span><br /><span class="FontName2">FAILED (failures=n)</span></pre>
<p class="indent">The variable <span class="FontName2">n</span> is replaced by the correct number of tests, and the exact number of failures that occurred in the test run.</p>
</div>
</div>
<p id="Sec8" class="Heading1">Arduino Test Suite Basic Functions</p>
<p class="noindent">The following functions allow you to start, print, and end tests, respectively. I&#x2019;ll describe them in detail in the following sections.</p>
<ul class="bulleted">
<li><span class="FontName2">ATS_begin</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">ATS_end</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">ATS_PrintTestStatus</span> <span class="FontName2">()</span></li>
</ul>
<div>
<p id="Sec9" class="Heading2">ATS_begin<a id="cXXX.566" /><a id="cXXX.567" /></p>
<p class="noindent">This is the function signature for <span class="FontName2">ATS_begin</span>:</p>
<pre><span class="FontName2">void&#160;&#160;&#160;&#160;ATS_begin(</span><i>char *manufName</i><span class="FontName2">,</span><i>char *testSuiteName</i><span class="FontName2">);</span></pre>
<p class="indent">Here are some examples of its usage:</p>
<pre><span class="FontName2">ATS_begin(&quot;Arduino&quot;,&quot;My test suite.&quot;);</span><br /><span class="FontName2">ATS_begin(&quot;Teensy&quot;, &quot;My test suite.&quot;);</span><br /><span class="FontName2">ATS_begin(&quot;Adafruit Motor Shield&quot;, &quot;My motor shield tests.&quot;);</span></pre>
<p class="indent">These are all valid examples of beginning statements. You can set the manufacturer of the board or shield and test the suite name. The <span class="FontName2">ATS_begin</span> function initializes the serial interface so that you do not have to do this in your test sketches. Once the test starts, it keeps track of the time and other summary test information, such as number of failures.</p>
</div>
<div>
<p id="Sec10" class="Heading2">ATS_PrintTestStatus<a id="cXXX.568" /><a id="cXXX.569" /></p>
<p class="noindent">You use the test status to return the test result to the user. Here is the syntax of the <span class="FontName2">ATS_PrintTestStatus</span> function:</p>
<pre><span class="FontName2">void&#160;&#160;&#160;&#160;ATS_PrintTestStatus(</span><i>char *testString</i><span class="FontName2">,</span><i>boolean passed</i><span class="FontName2">);</span></pre>
<p class="indent">And here are some examples of its usage:</p>
<pre><span class="FontName2">ATS_PrintTestStatus(&quot;1. Test result is TRUE test&quot; , true);</span><br /><span class="FontName2">ATS_PrintTestStatus(&quot;2. Test result is FALSE test (a false result is expected)&quot; , false);</span></pre>
<p class="indent">In the function, the argument test name is followed by a Boolean test result (<span class="FontName2">true</span> or <span class="FontName2">false</span>). All tests must pass or fail. You can use a parentheses section to add a note about the test to clarify detail, if necessary. In the <span class="FontName2">FALSE</span> test case, we must say that failure is expected, since we want to see the failure case. This is an unusual case so it&#x2019;s important to note it because interpreting the result could cause confusion.</p>
<p class="indent">Numbering is not automatic, so if you want to number your tests, put the numbering in the test name, like so:</p>
<pre><span class="FontName2">ATS_PrintTestsStatus(&quot;1. my numbered test&quot; , status);</span></pre>
</div>
<div>
<p id="Sec11" class="Heading2">ATS_end<a id="cXXX.570" /><a id="cXXX.571" /></p>
<p class="noindent"><span class="FontName2">ATS_end</span> completes the test run. Test time and the final count of successful and failed tests are sent in the summary format to the serial port.</p>
<pre><span class="FontName2">void&#160;&#160;&#160;&#160;ATS_end();</span></pre>
</div>
<div>
<p id="Sec12" class="Heading2">Using the Basic Functions</p>
<p class="noindent">With these functions, you can create custom test suites and verify your code or project. The code in <a href="#list5" id="_list5">Listing 13-5</a> is an example that forces a result to be <span class="FontName2">TRUE</span> or <span class="FontName2">FALSE</span>. It is important to keep track of all test results, but especially failure conditions. This way at a glance the test issue can be found quickly. The failure condition can be described in the test name, and the result would be <span class="FontName2">TRUE</span>, which will appear as <span class="FontName2">OK</span> in the result.</p>
<p class="noindent2"><a href="#_list5" id="list5"><b><i>Listing 13-5.</i></b></a>&#160;&#160;Bare-Bones Test<a id="cXXX.572" /><a id="cXXX.573" /> Sketch</p>
<pre><span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span><br /><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">boolean result;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;My bare bones tests&quot;);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">result = true;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_PrintTestStatus(&quot;My bare bones test&quot;, result);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">result = false;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_PrintTestStatus(&quot;1. My bare bones test&quot;, result);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ATS_end();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Here is the test result:</p>
<pre><span class="FontName2">info.MANUFACTURER = Arduino</span><br /><span class="FontName2">info.CPU-NAME = ATmega328P</span><br /><span class="FontName2">info.GCC-Version = 4.3.2</span><br /><span class="FontName2">info.AVR-LibC-Ver = 1.6.4</span><br /><span class="FontName2">info.Compiled-date = Oct 20 2010</span><br /><span class="FontName2">info.Test-Suite-Name = My bare bones tests</span><br /><span class="FontName2">info.Free-memory = 1442 bytes</span><br /><span class="FontName2">My bare bones test&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ... ok</span><br /><span class="FontName2">1. My bare bones test&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;... FAIL</span><br /><span class="FontName2">--------------------------</span><br /><span class="FontName2">Ran 2 tests in 1.443s</span><br /><br /><span class="FontName2">FAILED (failures=1)</span></pre>
<p class="indent">Once the test is complete, you will be able to see how many test were run, how long the tests took, and how many failures occurred. You can examine the tests to identify what happened. Additionally, you will get information about how much memory was available when you ran the tests. In this case, <span class="FontName2">info.Free-memory</span> shows that 1442 bytes were free in this test run.</p>
</div>
<p id="Sec13" class="Heading1">Arduino Test Suite Built-In Tests<a id="cXXX.574" /></p>
<p class="noindent">The Arduino Test Suite contains several built-in tests. These are very useful, as they standardize some of the basic tests. Running these standard tests will help you confirm that a custom Arduino-derived board has the correct pin numbers and behaves appropriately with the digital, analog, and PWM pins as the serial values are transmitted and received. You will need to test for memory leaks or heap fragmentation if things go wrong. The built-in tests are as follow:</p>
<pre><span class="FontName2">ATS_ReportMemoryUsage(int _memoryUsageAtStart)</span><br /><span class="FontName2">ATS_Test_DigitalPin(uint8_t digitalPinToTest)</span><br /><span class="FontName2">ATS_Test_PWM_Pin(uint8_t digitalPinToTest)</span><br /><span class="FontName2">ATS_Test_AnalogInput(uint8_t analogPintoTest)</span><br /><span class="FontName2">ATS_Test_EEPROM(void)</span><br /><span class="FontName2">ATS_TestSerialLoopback(HardwareSerial *theSerialPort, char *serialPortName)</span></pre>
<p class="indent">For the Serial port test the RX/TX pins to be wired to one another. This loops the input and output of serial information into each other for reading, and parsing by the test suite. However, the test results are delivered over the first serial port, and the board is programmed through it. Therefore, you can&#x2019;t test the port using this technique on the Arduino Uno, the Arduino Mega has multiple serial so there is extra serial ports that can be tested so you can still get the test results from the default serial.</p>
<p class="indent">Since these tests make the assumption that the board is wired for testing, you need to make sure your version of Arduino matches the wiring in <a href="#Fig3" id="_Fig3">Figure 13-3</a> or <a href="#Fig4" id="_Fig4">13-4</a>.</p>
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig13-03.jpg" alt="9781430239390_Fig13-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 13-3</a>. </span>Arduino Uno configured for testing </p>
</div>
<p class="indent">You would use the design in <a href="#Fig4">Figure 13-4</a> to test a board similar to the Arduino Mega.</p>
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig13-04.jpg" alt="9781430239390_Fig13-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 13-4</a>. </span>Arduino Mega test wiring </p>
</div>
<p id="Sec14" class="Heading1">Strategies for Testing Your Own Arduino Derivative</p>
<p class="noindent">The Arduino Test Suite contains all the necessary tests to verify that your board is fully functional. For creating a custom board to be compatible with the Arduino Uno or Mega pin layout<a id="cXXX.575" />, the Arduino Test Suite contains the <span class="FontName2">ATS_General</span> test<a id="cXXX.576" />. This test checks all the features of these two boards, including digital pins, PWM, analog read/write, EEPROM, tone, and serial RX/TX. If your custom board can pass these tests, then the board is pin-for-pin and feature compatible. You can save time and money by identifying problems early.</p>
<p class="indent">The <span class="FontName2">ATS_General</span> test<a id="cXXX.577" /> requires that you wire the pins in a specific way. The digital I/O pins are tied together, the analog read/write pins are tied together, and serial RX/TX pins can also be tied together. For a board with only one serial port, you will want to skip the RX/TX test. This is detected in the current <span class="FontName2">ATS_General</span> test.</p>
<p class="indent">You would use the same wiring options like we&#x2019;ve done with the Arduino Uno board in <a href="#Fig3">Figure 13-3</a>. You would be configured for testing. You can do something similar for your own board.</p>
<p id="Sec15" class="Heading1">Memory Testing<a id="cXXX.578" /></p>
<p class="noindent">The Arduino Test Suite provides a test for checking the amount of free memory available. This function is particularly useful for checking how much memory is being consumed and if it is being returned after use. You can find out how to use this function by studying the tests. This section will look at a subset of these tests and then demonstrate using this function to track memory usage and create a test that involves memory use. <a href="#list6" id="_list6">Listing 13-6</a> shows the code that we will examine. The complete test is part of the ATS examples. We will look at three tests:<a id="cXXX.579" /></p>
<ul class="bulleted">
<li><span class="FontName2">testAllocatingThenDeallocatingPreservesFreeMemory();</span></li>
<li><span class="FontName2">testAllocatingAndDeallocatingSmallerPreservesFreeMemory();</span></li>
<li><span class="FontName2">testRepeatedlyAllocatingAndDeallocatingMemoryPreservesFreeMemory();</span></li>
</ul>
<p class="noindent2"><a href="#_list6" id="list6"><b><i>Listing 13-6.</i></b></a>&#160;&#160;ATS_GetFreeMemory Tests<a id="cXXX.580" /> Example, from Matthew Murdoch</p>
<pre><span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span><br /><br /><span class="FontName2">void setup() {</span><br />&#160;&#160;<span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;ATS_GetFreeMemory() Tests&quot;);</span><br /><br />&#160;&#160;<span class="FontName2">testAllocatingThenDeallocatingPreservesFreeMemory();</span><br />&#160;&#160;<span class="FontName2">testRepeatedlyAllocatingAndDeallocatingMemoryPreservesFreeMemory();</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">testAllocatingAndDeallocatingSmallerPreservesFreeMemory();</span><br /><br />&#160;&#160;<span class="FontName2">ATS_end();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">// This test checks that the free list is taken into account when free memory is calculated</span><br /><span class="FontName2">// when using versions of free() which *don&#x0027;t* reset __brkval (such as in avr-libc 1.6.4)</span><br /><span class="FontName2">void testAllocatingThenDeallocatingPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br /><br />&#160;&#160;<span class="FontName2">void* buffer = malloc(10);</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Allocating then deallocating preserves free memory&quot;, startMemory ==&#160;&#160; ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">// This test checks that the free list is taken into account when free memory is calculated</span><br /><span class="FontName2">// even when using versions of free() which *do* reset __brkval (such as in avr-libc 1.7.1)</span><br /><span class="FontName2">void testAllocatingAndDeallocatingInterleavedPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">void* buffer1 = malloc(10);</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br /><br />&#160;&#160;<span class="FontName2">void* buffer2 = malloc(10);</span><br />&#160;&#160;<span class="FontName2">free(buffer1);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Interleaved allocation and deallocation preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">free(buffer2);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testRepeatedlyAllocatingAndDeallocatingMemoryPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br /><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; 10; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void* buffer1 = malloc(10);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void* buffer2 = malloc(10);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void* buffer3 = malloc(10);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">free(buffer3);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">free(buffer2);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">free(buffer1);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160; <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Repeated allocation and deallocation preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">// TODO MM Currently fails as __brkval is not increased, but the size of the free list is...</span><br /><span class="FontName2">// Therefore looks as if the total amount of free memory increases (i.e. negative memory leak)!</span><br /><span class="FontName2">void testReallocatingSmallerPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">// Allocate one byte more than the space taken up by a free list node</span><br />&#160;&#160;<span class="FontName2">void* buffer = malloc(5);</span><br />&#160;&#160;<span class="FontName2">buffer = realloc(buffer, 1);</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Reallocating smaller preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testReallocatingLargerPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br /><br />&#160;&#160;<span class="FontName2">void* buffer = malloc(1);</span><br />&#160;&#160;<span class="FontName2">buffer = realloc(buffer, 5);</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Reallocating larger preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testAllocatingAndDeallocatingSmallerPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">// Allocate one byte more than the space taken up by a free list node</span><br />&#160;&#160;<span class="FontName2">void* buffer = malloc(5);</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;<span class="FontName2">buffer = malloc(1);</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Allocating and deallocating smaller preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testReallocatingRepeatedlyLargerPreservesFreeMemory() {</span><br />&#160;&#160;<span class="FontName2">int startMemory = ATS_GetFreeMemory();</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">void* buffer = malloc(2);</span><br />&#160;&#160;<span class="FontName2">for (int i = 4; i &#x003C;= 8; i+=2) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">buffer = realloc(buffer, i);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">free(buffer);</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;Reallocating repeatedly larger preserves free memory&quot;,&#160;&#160; startMemory == ATS_GetFreeMemory());</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop() {</span><br /><span class="FontName2">}</span></pre>
<div>
<p id="Sec16" class="Heading2">Example: Testing for a Memory Leak</p>
<p class="noindent">Any new values created inside the memory test will use memory. So, you must declare all the variables that consume memory at the beginning of the setup.</p>
<pre><span class="FontName2">startMemoryUsage = ATS_GetFreeMemory();</span></pre>
<p class="indent">Once this is done, your starting memory is set. Anything that takes without putting back will be counted as a failure. The memory test is over when you call the following:</p>
<pre><span class="FontName2">ATS_ReportMemoryUsage(startMemoryUsage);</span></pre>
<p class="indent">Here are some hints for debugging:</p>
<ul class="bulleted">
<li>By putting the memory test at the bottom of the code, you can gradually move it higher into the code and see where the memory was lost.</li>
<li>An <span class="FontName2">OK</span> indicates that the memory loss occurred below the memory test.</li>
<li>A binary search will help you find the problem.</li>
</ul>
<p class="indent"><a href="#list7" id="_list7">Listing 13-7</a> is a sketch of the testing skeleton.</p>
<p class="noindent2"><a href="#_list7" id="list7"><b><i>Listing 13-7.</i></b></a>&#160;&#160;Sketch of the Testing Skeleton</p>
<pre><span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span><br /><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">int startMemoryUsage;</span><br /><br />&#160;&#160;&#160;&#160;<span class="FontName2">//startMemoryUsage must be set directly before ATS_begin</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">startMemoryUsage = ATS_GetFreeMemory();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;Skeleton Test&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">/*</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* Test Run Start</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* Test one passes because result is set to true</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* Test two fails becuase result is set to false</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* You can test memory for any set of tests by using the ATS_ReportMemoryUsage test</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* There is also a way to print current memeory for debugging</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">*/</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;1. Test of true test status&quot;, true);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;2. Test of false test status, this will fail.&quot;, false);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ATS_ReportMemoryUsage(startMemoryUsage);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">/*</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">* Test Run End</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">*/</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ATS_end();</span><br /><span class="FontName2">}</span><br /><span class="FontName2">//************************************************************************</span><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Here is the test result:</p>
<pre><span class="FontName2">info.MANUFACTURER = Arduino</span><br /><span class="FontName2">info.CPU-NAME = ATmega328P</span><br /><span class="FontName2">info.GCC-Version = 4.3.2</span><br /><span class="FontName2">info.AVR-LibC-Ver = 1.6.4</span><br /><span class="FontName2">info.Compiled-date = Oct 20 2010</span><br /><span class="FontName2">info.Test-Suite-Name = Skeleton Test</span><br /><span class="FontName2">info.Free-memory = 1322 bytes</span><br /><span class="FontName2">1. Test of true test status&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ... ok</span><br /><span class="FontName2">2. Test of false test status, this will fail.&#160;&#160;&#160;&#160;&#160;&#160; ... FAIL</span><br /><span class="FontName2">Memory Usage ... ok</span><br /><span class="FontName2">--------------------------</span><br /><span class="FontName2">Ran 3 tests in 1.508s</span><br /><br /><span class="FontName2">FAILED (failures=1)</span></pre>
</div>
<p id="Sec17" class="Heading1">Testing Libraries</p>
<p class="noindent">One of goals of this chapter is to make it possible to test your own libraries. In this section, we will test an Arduino library, which can be used as a model for testing your own. We&#x2019;ll test the SPI library, which is used to communicate digitally with other electronic devices, such as temperature sensors, SD cards, and EEPROM, all of which all support the SPI protocol. To test the SPI protocol of Arduino, we can make two Arduinos talk to each other. We will connect them as a master-and-slave device<a id="cXXX.581" />.</p>
<p class="indent">The tests will be from the point of view of the master and ensure that the functions defined in the library work correctly. The tests will be part of the sketch that we load onto the master Arduino. The slave Arduino will be loaded with a sketch that configures it in slave mode and provides a set of information that will return known data to the master.</p>
<p class="indent"><a href="#Fig5" id="_Fig5">Figure 13-5</a> shows the two Arduinos configured in master-and-slave configuration. Pins 10, 11, 12, and 13 are tied together between them. Power and ground are connected so that the slave Arduino is powered by the master.</p>
<div class="Figure" id="Fig5">
<p class="img"><img src="images/9781430239390_Fig13-05.jpg" alt="9781430239390_Fig13-05.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig5">Figure 13-5</a>. </span>Arduino SPI master-slave wiring<a id="cXXX.582" /> </p>
</div>
<p class="indent">We will use the Arduino SPI master test sketch and an Arduino SPI slave sketch, which will process the commands, expected returns, and values from the master, and confirm that an action occurred properly. <a href="#list8" id="_list8">Listing 13-8</a> shows the configuration of the slave SPI Arduino.</p>
<p class="noindent2"><a href="#_list8" id="list8"><b><i>Listing 13-8.</i></b></a>&#160;&#160;SPI_Slave_test.ino<a id="cXXX.583" /></p>
<pre><span class="FontName2">/*</span><br /><span class="FontName2">* SPI Slave test program</span><br />&#160;<span class="FontName2">* by Rick Anderson</span><br />&#160;<span class="FontName2">*</span><br />&#160;<span class="FontName2">* Set the defaults:</span><br />&#160;<span class="FontName2">* MSBFIRST</span><br />&#160;<span class="FontName2">* DataMode = SPI_MODE0;</span><br />&#160;<span class="FontName2">* Clock divider = SPI_CLOCK_DIV4,</span><br />&#160;<span class="FontName2">*/</span><br /><br /><span class="FontName2">#include &#x003C;SPI.h&#x003E;</span><br /><br /><span class="FontName2">const byte TESTBYTE = 0b11110000;</span><br /><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">//Slave out needs to be enabled by placing the MISO as OUTPUT</span><br />&#160;&#160;<span class="FontName2">pinMode(MISO, OUTPUT);</span><br /><br />&#160;&#160;<span class="FontName2">//Use the AVR Code to turn on slave mode</span><br />&#160;&#160;<span class="FontName2">SPCR |= _BV(SPE);</span><br /><br />&#160;&#160;<span class="FontName2">//Standard Arduino settings for SPI</span><br />&#160;&#160;<span class="FontName2">SPI.setBitOrder(MSBFIRST);</span><br />&#160;&#160;<span class="FontName2">SPI.setDataMode(SPI_MODE0);</span><br />&#160;&#160;<span class="FontName2">SPI.setClockDivider(SPI_CLOCK_DIV4);</span><br /><br />&#160;&#160;<span class="FontName2">//Turn on interrupts for SPI</span><br />&#160;&#160;<span class="FontName2">SPI.attachInterrupt();</span><br />&#160;&#160;<span class="FontName2">Serial.println(&quot;Slave Configured&quot;);</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">/*AVR SPI interrupt callback</span><br /><span class="FontName2">*Process commands sent to slave</span><br /><span class="FontName2">* First transfer is the command value</span><br /><span class="FontName2">* Second command pushes the value to the master</span><br /><span class="FontName2">*/</span><br /><span class="FontName2">ISR (SPI_STC_vect)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">const byte cc = TESTBYTE;</span><br />&#160;&#160;<span class="FontName2">if (SPDR == 0x00) //Only command is 0x00</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SPDR = 0b11110000; // read byte from SPI Data Register</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SPDR = 0b11111111; //Any other command returns 0xff</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.println(&quot;SPI Slave Sketch for testing SPI Master.&quot;);</span><br />&#160;&#160;<span class="FontName2">if (digitalRead (SS) == HIGH)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SPDR = 0;//When not enable set buffer to 0</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">}</span></pre>
<p class="indent">This kind of test requires an Arduino to be configured in slave mode. In order to get the slave to be in SPI slave mode, you must use AVR code. <span class="FontName2">SPCR |= _BV(SPE);</span> enables slave mode for AVR SPI. Additionally, the SPI interrupt needs to be enabled. It is worth noting that you can use the Arduino <span class="FontName2">SPI.attachInterupt()</span> or call the AVR code directly. In <a href="#list9" id="_list9">Listing 13-9</a>, you can see that all the function does is call the AVR code.</p>
<p class="noindent2"><a href="#_list9" id="list9"><b><i>Listing 13-9.</i></b></a>&#160;&#160;SPI.h attachInterrupt Code<a id="cXXX.584" /></p>
<pre><span class="FontName2">void SPIClass::attachInterrupt() {</span><br />&#160;&#160;<span class="FontName2">SPCR |= _BV(SPIE);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Once the interruptions are turned on, you must write the callback function that will run once the SPI interrupt is triggered. This function is</p>
<pre><span class="FontName2">ISR (SPI_STC_vect) {}</span></pre>
<p class="indent">Each function of the SPI library, as well as part of the master Arduino sketch, will need to be tested. The SPI library has defined the following functions:</p>
<ul class="bulleted">
<li><span class="FontName2">begin</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">end</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">setBitOrder</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">setClockDivider</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">setDataMode</span> <span class="FontName2">()</span></li>
<li><span class="FontName2">transfer</span> <span class="FontName2">()</span></li>
</ul>
<p class="indent">The <span class="FontName2">begin()</span> function<a id="cXXX.585" /> instantiates the SPI object. This test will instantiate SPI and determine if the SPI object was created by setting the pin modes for the SPI lines and configuring the hardware SPI feature in master mode.</p>
<p class="indent">The <span class="FontName2">end()</span> function<a id="cXXX.586" /> disables the SPI configuration using the following AVR code:</p>
<pre><span class="FontName2">SPCR &#x0026;= &#x223C;_BV(SPE);</span></pre>
<p class="indent">This leaves the pin modes as they were: <span class="FontName2">INPUT</span> and <span class="FontName2">OUTPUT</span>.</p>
<p class="indent">Given the functions in the SPI library, we can now test them in use. <a href="#list10" id="_list10">Listing 13-10</a> is the SPI master test code. The online version provides the full test, <span class="FontName2"><a href="https://github.com/ProArd/SPI_Master_test">https://github.com/ProArd/SPI_Master_test</a></span>. We will look at a few of the key test cases and examine how they work.</p>
<p class="noindent2"><a href="#_list10" id="list10"><b><i>Listing 13-10.</i></b></a>&#160;&#160;SPI_Master_test.ino<a id="cXXX.587" /></p>
<pre><span class="FontName2">#include &#x003C;ArduinoTestSuite.h&#x003E;</span><br /><span class="FontName2">#include &#x003C;SPI.h&#x003E;</span><br /><br /><span class="FontName2">void setup ()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">// Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">ATS_begin(&quot;Arduino&quot;, &quot;SPI Tests&quot;);</span><br />&#160;&#160;<span class="FontName2">SPI.begin();</span><br />&#160;&#160;<span class="FontName2">//Run tests</span><br />&#160;&#160;<span class="FontName2">refConfig();</span><br /><br />&#160;&#160;<span class="FontName2">testTransfer();</span><br />&#160;&#160;<span class="FontName2">refConfig();</span><br /><br />&#160;&#160;<span class="FontName2">testBitOrderMSB();</span><br />&#160;&#160;<span class="FontName2">refConfig();</span><br /><br />&#160;&#160;<span class="FontName2">testBitOrderLSB();</span><br /><br />&#160;&#160;<span class="FontName2">testDataMode();</span><br />&#160;&#160;<span class="FontName2">refConfig();</span><br /><br />&#160;&#160;<span class="FontName2">testClockDivider();</span><br /><br />&#160;&#160;<span class="FontName2">SPI.end();</span><br />&#160;&#160;<span class="FontName2">ATS_end();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void refConfig()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">SPI.setBitOrder(MSBFIRST);</span><br />&#160;&#160;<span class="FontName2">SPI.setDataMode(SPI_MODE0);</span><br />&#160;&#160;<span class="FontName2">SPI.setClockDivider(SPI_CLOCK_DIV4);</span><br /><span class="FontName2">}</span><br /><span class="FontName2">byte SPITransfer(byte val, uint8_t spi_bitorder, uint8_t spi_mode, uint8_t spi_clockdivider)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br />&#160;&#160;<span class="FontName2">SPI.setBitOrder(spi_bitorder);</span><br />&#160;&#160;<span class="FontName2">SPI.setDataMode(spi_mode);</span><br />&#160;&#160;<span class="FontName2">SPI.setClockDivider(spi_clockdivider);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(SS, LOW);</span><br />&#160;&#160;<span class="FontName2">spireturn = SPI.transfer(val);</span><br />&#160;&#160;<span class="FontName2">delayMicroseconds (10);</span><br />&#160;&#160;<span class="FontName2">spireturn = SPI.transfer(0x00);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(SS, HIGH);</span><br />&#160;&#160;<span class="FontName2">return spireturn;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testTransfer()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br /><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;1. transfer(0x00)&quot;, result);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testBitOrderMSB()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Sets the bit order to MSBFRIST expects byte 0xf0</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;2. setBitOrder(MSBFIRST)&quot;, result);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testBitOrderLSB()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Sets the bit order to LSBFRIST expects byte 0xf</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, LSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;3. setBitOrder(LSBFIRST)&quot;, result);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testDataMode()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//asserting the default mode is true</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;4. setDataMode(SPI_MODE0)&quot;, result);</span><br /><br />&#160;&#160;<span class="FontName2">result = false;</span><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE1, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;5. setDataMode(SPI_MODE1) should fail so reports ok&quot;, !result);</span><br /><br />&#160;&#160;<span class="FontName2">result = false;</span><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE2, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;6. setDataMode(SPI_MODE2) should fail so reports ok&quot;, !result);</span><br /><br />&#160;&#160;<span class="FontName2">result = false;</span><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE3, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;7. setDataMode(SPI_MODE3) should fail so reports ok&quot;, !result);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void testClockDivider()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//asserting the default mode is true</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV2);</span><br />&#160;&#160;<span class="FontName2">//Slave is CLOCK_DIV4 so this should fail</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;8. setClockDivider(SPI_CLOCK_DIV2) should fail so reports ok&quot;, !result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;9. setClockDivider(SPI_CLOCK_DIV4)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV8);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;10. setClockDivider(SPI_CLOCK_DIV8)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV16);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;11. setClockDivider(SPI_CLOCK_DIV16)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV32);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;12. setClockDivider(SPI_CLOCK_DIV32)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV64);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;13. setClockDivider(SPI_CLOCK_DIV64)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV128);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;14. setClockDivider(SPI_CLOCK_DIV128)&quot;, result);</span><br />&#160;&#160;<span class="FontName2">result = false;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop (){}</span></pre>
<div>
<p id="Sec18" class="Heading2">SPI.transfer() Test<a id="cXXX.588" /></p>
<p class="noindent"><span class="FontName2">SPI.transfer()</span><a id="cXXX.589" /> is the main function of this library. In the past, we&#x2019;ve used it to verify that data was sent properly between various configurations. Now we want to test if it sends data as defined in the API. A byte should be sent to the slave device, and a byte will be received as the return value from the slave device, as shown in <a href="#list11" id="_list11">Listing 13-11</a>.</p>
<p class="noindent2"><a href="#_list11" id="list11"><b><i>Listing 13-11.</i></b></a>&#160;&#160;Data Transfer Test</p>
<pre><span class="FontName2">void testTransfer()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br /><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;1. transfer(0x00)&quot;, result);</span><br /><span class="FontName2">}</span></pre>
</div>
<div>
<p id="Sec19" class="Heading2">setBitOrder() Test<a id="cXXX.590" /><a id="cXXX.591" /></p>
<p class="noindent">The bit order of the device must be matched by the Arduino communicating with it. There are two supported configurations:</p>
<ul class="bulleted">
<li>Least significant bit (LSB)</li>
<li>Most significant bit (MSB)</li>
</ul>
<p class="indent">For the first test, the slave Arduino must be configured for LSB, and for the second test, the slave Arduino needs to be configured to MSB, as shown in <a href="#list12" id="_list12">Listing 13-12</a>.</p>
<p class="noindent2"><a href="#_list12" id="list12"><b><i>Listing 13-12.</i></b></a>&#160;&#160;setBitOrder MSB Test</p>
<pre><span class="FontName2">void testBitOrderMSB()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Sets the bit order to MSBFRIST expects byte 0xf0</span><br />&#160;&#160;<span class="FontName2">boolean result = false;</span><br />&#160;&#160;<span class="FontName2">byte spireturn;</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPITransfer(0x00, MSBFIRST, SPI_MODE0, SPI_CLOCK_DIV4);</span><br />&#160;&#160;<span class="FontName2">if (spireturn == 0xf0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;2. setBitOrder: MSBFIRST&quot;, result);</span><br /><span class="FontName2">}</span></pre>
</div>
<div>
<p id="Sec20" class="Heading2">setClockDivider() Test<a id="cXXX.592" /><a id="cXXX.593" /></p>
<p class="noindent">The clock divider changes the SPI speed to be a multiple of the Arduino clock speed. This way, it is possible to change the speed of the SPI bus to match that of the attached device. For this test, we need to set the clock divider at each of its multiples and ask the attached Arduino for a piece of data that matches the clock speed, as shown in <a href="#list13" id="_list13">Listing 13-13</a>.</p>
<p class="noindent2"><a href="#_list13" id="list13"><b><i>Listing 13-13.</i></b></a>&#160;&#160;setClockDivider Test for SPI_CLOCK_DIV2</p>
<pre><span class="FontName2">void testClockDivider()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">boolean result = false;</span><br />&#160;<span class="FontName2">byte spireturn;</span><br />&#160;&#160;<span class="FontName2">//SPI_MODE0 test 3</span><br />&#160;&#160;<span class="FontName2">setSlaveClockDivider(SPI_CLOCK_DIV2);</span><br />&#160;&#160;<span class="FontName2">SPI.setClockDivider(SPI_CLOCK_DIV2);</span><br /><br />&#160;&#160;<span class="FontName2">spireturn = SPI.transfer(0x02);</span><br />&#160;&#160;<span class="FontName2">if (spireturn &#x003E; 0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;4. setClockDivider:SPI_CLOCK_DIV2 (failure is OK)&quot;, result);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The test in <a href="#list13">Listing 13-13</a> is a testing condition for when the clock divider is set to twice the speed of the slave device. This type of test is expected to fail. The code is written to discover the failure and report a completed test. A <span class="FontName2">true</span> result is reported as a pass. The parentheses are used to indicate that the test is OK even though failure was expected.</p>
</div>
<div>
<p id="Sec21" class="Heading2">setDataMode() Test<a id="cXXX.594" /><a id="cXXX.595" /></p>
<p class="noindent">The data mode configures the clock phase and the polarity. For this to be tested, each mode must be set, and the slave Arduino must send a piece of data that shows that it was received and returned properly, as shown in <a href="#list14" id="_list14">Listing 13-14</a>.</p>
<p class="noindent2"><a href="#_list14" id="list14"><b><i>Listing 13-14.</i></b></a>&#160;&#160;SetDataMode Test for SPI_MODE0</p>
<pre><span class="FontName2">void testDataMode()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">boolean result = false;</span><br />&#160;<span class="FontName2">byte spireturn;</span><br />&#160;&#160;<span class="FontName2">//SPI_MODE0 test 3</span><br />&#160;&#160;<span class="FontName2">setSlaveDataMode(SPI_MODE0);</span><br />&#160;&#160;<span class="FontName2">SPI.setDataMode(SPI_MODE0);</span><br />&#160;&#160;<span class="FontName2">spireturn = SPI.transfer(0x02);</span><br />&#160;&#160;<span class="FontName2">if (spireturn &#x003E; 0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">result = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ATS_PrintTestStatus(&quot;3. setDataMode: SPI_MODE0&quot;, result);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The test in <a href="#list14">Listing 13-14</a> will return a <span class="FontName2">TRUE</span> result if you can communicate with the slave device in that mode. If a configuration or communication error occurs, it will fail.</p>
</div>
<div>
<p id="Sec22" class="Heading2">SPI Test Results</p>
<p class="noindent">In conclusion, the complete set of test runs shows that the expected configuration of the master and slave match. The commands that are issued must be valid configurations of SPI in order to work correctly. If we change the slave configuration, we have to change the master test, or else we will see expected failures due to mismatched configurations.</p>
<p class="indent">There are many test cases within each of these variations. The full source for this on the Pro Arduino SPGitHub repository, <span class="FontName2"><a href="http://github.com/proardwebsite">http://github.com/proardwebsite</a></span><a id="cXXX.596" /> goes through many more test cases, each with a single change from the last one. Another good challenge for SPI testing would be to reconfigure the slave device to iterate through each of its configurations. Creating these tests proves that SPI is working and simultaneously gives you a chance to learn how SPI works.</p>
</div>
<p id="Sec23" class="Heading1">Summary</p>
<p class="noindent">This chapter describes the features and benefits of the Arduino Test Suite. The goal is to show how to move from creating examples that demonstrate your code to creating a test that verifies it. Not only is this good for code quality, but it allows you to make custom circuits, shields, and your own verified Arduino-inspired device. As you share your code and hardware with others, testing provides usage examples and behavior confirmation.</p>
<p class="indent">The challenge of creating testable conditions is not simple. The environment of the project must be included, and users are encouraged to submit their tests to the Arduino testing project on GitHub. This ensures that the entire platform is well tested and documented, and provides a high-quality user experience.</p>
</div>
</body>
</html>