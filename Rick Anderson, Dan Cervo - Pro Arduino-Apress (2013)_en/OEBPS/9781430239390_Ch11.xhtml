<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 11 Game Development with Arduino</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap11" />CHAPTER 11</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">Game Development with Arduino<a id="cXXX.436" /></p>
<div>
<p class="noindent">Game development on the Arduino can push both the hardware resources and the developer&#x2019;s imagination to their potential. Games can be simple or extremely complex, challenging skills or even telling a story. This chapter explores game development as it is related to the Arduino. Games can come in all forms, from a few LEDs testing skill or luck to a full graphical side-scroller made with the help of the Gameduino.</p>
<p class="indent">The Arduino is a great platform to get started with when first getting in to game development, being easy to program and expand upon. Modern computer games are incredibly complex and are targeted at a large number of different end devices; they usually involve a lot of development and have game engines that are difficult to understand. This makes it difficult for individual developers to complete these types of projects on their own. With Arduino, developers can build great games, and test and distribute their games with greater ease than with modern computer and console games.</p>
<p id="Sec1" class="Heading1">Games Suitable for the Arduino</p>
<p class="noindent">The average processing power of microcontrollers makes them well suited for the development of coin-operated (coin-op), medal, redemption, and merchandiser-style arcade games. Here are some examples of these types of games:</p>
<ul class="bulleted">
<li>Coin-op<a id="cXXX.437" /><a id="cXXX.438" /> are games usually table sports played on a table (for example, air hockey and pool) that charge a fee for one complete game.</li>
<li>Coin pushers and slot machines are examples of medal games<a id="cXXX.439" /><a id="cXXX.440" />.</li>
<li>Redemption games<a id="cXXX.441" /><a id="cXXX.442" /> include alley roll and whack-a-mole; these games give tickets to be traded for prizes.</li>
<li>Claw cranes are in the game category of merchandisers<a id="cXXX.443" /><a id="cXXX.444" />, which give the prize directly to the player.</li>
<li>The pinball machine is another popular arcade game. This style game is in the same category as the medal and redemption games, but dates back (in its current form) to the 1950s.</li>
</ul>
<p class="indent">These arcade games became quite popular at video arcades in the early to mid-1990s, just after the peak of video arcades themselves and are still used and developed for modern arcades.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Arcade owners began to use coin-op, redemption, medal, and merchandiser games to keep the arcade industry alive after the widespread availability and acceptance of game consoles and personal computers lowered arcade attendance. I&#x2019;ll refer to these types of games as <i>arcade games</i> to avoid any confusion with video arcade games, such as Space Invaders, Centipede, and Pac-Man.</p></div>
<p class="indent"><a id="cXXX.445" />Arcade games are akin to robotics development because of the heavy use of motors and sensors to measure and move game play along. Both arcade and video arcade games rely heavily on the game play being balanced, requiring them to be simple to understand and play but difficult to master. Users must be able to easily identify the game mechanics of an arcade game before choosing to play. The game whack-a-mole, for example, has a mechanism that is easily identifiable by both the game&#x2019;s descriptive name and watching others play&#x2014;but it has a challenge that pits hand-eye coordination to speed. The game play in home consoles and on personal computers can spend more time teaching a user the unique mechanics of the game in the early stages. An example of a game that teaches a complex game mechanism in the early stages is Valve Corporation&#x2019;s first Portal game; the game uses each level to teach only one part of the mechanism at a time, until all the basic components can be used to solve more difficult puzzles.</p>
<p class="indent">The development of arcade games employs a different skill set than that of computer or console games. The skills of problem development, storytelling, programming, and graphic design are common among most digital game development fields. Arcade games make use of carpentry, hardware integration, and electrical engineering. Carpentry is used to make the cabinets that house the actual arcade games. The Behemoth game company, makers of Castle Crashers, posted a video that demonstrates an arcade cabinet being constructed in time lapse (see <span class="FontName2"><a href="http://www.youtube.com/watch?v=MJ6Lp2GqHoU">www.youtube.com/watch?v=MJ6Lp2GqHoU</a></span>), to give you an example of how much is involved. Carpentry is a skill that can be acquired with a little practice and a trip to the local book store for a plethora of information on the subject. Arcade game cabinets are usually the flashiest part of the entire game, designed to entice people to play. They usually make sounds, blink lights, and are covered in graphics or eye-popping colors.</p>
<p class="indent">The distinctly average power of a microcontroller&#x2019;s capabilities for complex video graphics is why other methods of attracting the player are used such as intense cabinet design flashing lights and sounds to make games attractive for play instead of relying on the game graphics the way computer games do. Arcade game cabinets also integrate the game surface and playing area into the cabinet; pinball and alley roll are great examples of the game surface being included in the cabinet. Video arcade games use cabinets for reasons similar to arcade games, but the game play is performed on a screen mounted in the cabinet.</p>
<p class="indent">The skill of hardware to software integration will be familiar to any Arduino developer that uses sensors, motors, and lights in other developments. Arcade games can perform many types of hardware integration&#x2014;for example, using sensors to determine if an object has reached a goal. Game play can use motors and solenoids to manipulate and move physical objects. LED displays can be used to keep score. Each arcade game has different requirements on the type of hardware needed and how it connects.</p>
<p class="indent">Another type of game that is well-suited to the Arduino is the board game<a id="cXXX.446" />. Using electronics in a board game is great for adding game depth that may not be available via any other method. Milton Bradley&#x2019;s Omega Virus and Dark Tower are both classic games that demonstrate how electronics can be integrated into a board game, adding a unique game play experience.</p>
<p class="indent">Electronics can also be used in pen-and-paper role-playing games (RPGs)&#x2014;for example, you could use the simulated RFID reader from <a href="9781430239390_Ch06.xhtml">Chapter 6</a> in a cyber-style RPG to have players &#x201C;hack&#x201D; and intercept access codes for certain game elements. Vintage video games have seen a comeback in the form of stand-alone controllers that integrate one or more games into the controller to provide an easy connection to a display.</p>
<p class="indent">This chapter shows you how to build two proof-of-concept games: one that uses 11 LEDs, 11 resistors, and a button; and one that uses the Gameduino and a button.</p>
<p class="indent">The games are designed to be simple while demonstrating concepts of game development. This chapter&#x2019;s hardware requirements are an Arduino Uno or compatible device with a standard pin interface, some LEDs and buttons, and a Gameduino. The Gameduino is graphic coprocessor shield that enables the Arduino to control sprite based games. The Gameduino shield can be acquired at many online retailers, such as Adafruit Industries, Seeed Studio, and SparkFun electronics.</p>
<p id="Sec2" class="Heading1">A Simple Game</p>
<p class="noindent">Game play is one of the most important parts of game development and is crucial to making a fun and entertaining game. After a game concept has been brainstormed, building a proof of concept<a id="cXXX.447" /> of a game is an important step to iron out details and mechanics. The proof of concept can help determine if the game is feasible early in the development process. Simple tests of working concepts are also useful to figure out if the challenges are too difficult for anyone to complete. Testing concepts<a id="cXXX.448" /> is vital, especially if a game mechanism is going involve components that rely on physics or mechanical contraptions such as a ball toss or claw retrieval. You should develop each game mechanism as best you can before integrating it with other systems, building each and testing for bugs before setting the final product into motion. The extra components that make up an arcade game (such as artwork, coin mechanisms, ticket dispensers, and attractive cabinet accoutrements) can be integrated later in the development process.</p>
<p class="indent">The game that you will set up in section is a simple game that challenges reaction time by making the player stop a sweeping series of LEDs at a specified point within the series. The game is called Stop It<a id="cXXX.449" />, and the main part of this game is the display with the sweeping of a single-light LED from one side of a series to the other. The challenge for this game is the amount of time a player has to react. The game appears to move faster when the time a single LED is on before the next one lights up is lowered. To achieve a level completion the player has to press a button while a specified LED is on. Stop it will use 11 LEDs and a single button; the winning LED is in the middle, and five LEDs are on either side.</p>
<p class="indent">After each level is complete or <i>micro-win</i><a id="cXXX.450" />, Stop It will decrease the time each LED is on before moving on to the next stage. A micro-win will flash an alternating pattern on the LEDs, and after 11 micro-wins, a more elaborate pattern will flash, signifying a <i>big win</i>. If an attempt fails, Stop it will reset back to the first level, and the succession to the big win will be restarted. The flash of the LEDs is the reward for the proof of concept. If Stop it were to be developed in to a full arcade game, the reward would have to be greater than just flashing lights. For example, you might add 1 point to a score or money to a jackpot for every micro-win, and reward the player with tickets for each big win. Stop it will also need a risk for the user to place up front to attempt to play. For example, a number of tokens could be accepted via a coin acceptor before the player is allowed play.</p>
<div>
<p id="Sec3" class="Heading2">Proof of Concept</p>
<p class="noindent">Stop It&#x2019;s proof-of-concept setup is described in <a href="#Fig1" id="_Fig1">Figure 11-1</a>, with 11 1k&#x03A9; resistors connected to 5V power and then to the anode side of 11 LEDs. The cathode side of each LED is connected to pins 3 through 13&#x2014;one cathode per pin. The LEDs will be on when the pin is pulled low, instead of when the pin is high. Turning on the LEDs by grounding is a best practice for lowering the amp draw though the microcontroller. A button is connected to ground on one side and pin 2 on the other so that the interrupt can be utilized to determine when the player has made an attempt to win. Serial is not used for this code, but the pins are left alone so that the serial can be used to communicate to other modules. It is possible to use a couple of shift registers to lessen the pin usage of the Arduino and allow for other devices to connect to digital pins. This example does not use shift registers, keeping the parts requirement to a minimum.</p>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig11-01.jpg" alt="9781430239390_Fig12-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 11-1</a> </span>.&#160;&#160;Stop it&#x2019;s proof-of-concept setup </p>
</div>
<p class="indent">There are two common methods to accomplish the sweep of an LED in a series:</p>
<ul class="bulleted">
<li>The first uses an array to hold the state of each LED and uses a loop to perform a series of digital writes to each individual pin.</li>
<li>The other method is to directly manipulate the pin registers.</li>
</ul>
<p class="indent">The register method<a id="cXXX.451" /> is used for Stop it because it simplifies the program&#x2019;s logic. Register manipulation was introduced in <a href="9781430239390_Ch06.xhtml">Chapter 6</a> to create a fast 10-bit digital-to-analog converter. The method for changing the pin state is the same: a single integer is used to hold the pattern that will be used to turn on or off the pins using bitwise shifts along with <span class="FontName2">AND</span> masks to turn the entire register at once. Stop it&#x2019;s code, shown in <a href="#list1" id="_list1">Listing 11-1</a>, is broken up into 11 parts and contains 12 functions.</p>
</div>
<div>
<p id="Sec4" class="Heading2">Coding Stop It</p>
<p class="noindent">Part 1 of <a href="#list1">Listing 11-1</a> sets up the variables for Stop it and the pins&#x2019; data direction. The proof of concept has five variables in total: one integer, one byte, and three Booleans. The integer is used to manipulate the pattern of the LEDs; this variable is used for everything that will be displayed to the user, and also to determine the direction of the sweep and whether a win has been archived. The byte variable is used to determine the level and to increase the speed of the sweep. The Booleans are used as flags to tell what direction the sweep needs to travel, and tell if a win condition has been achieved and if the button has been pressed.</p>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 11-1.</i></b></a>&#160;&#160;Stop It&#x2019;s Code, Part 1 of 11</p>
<pre><span class="FontName2">int LEDshift = 0x0001;&#160;&#160;&#160;&#160; // holds the LED pattern</span><br /><span class="FontName2">boolean RightLeft = false; // true for right</span><br /><span class="FontName2">boolean Win = false;&#160;&#160;&#160;&#160;&#160;&#160; // when true, a win state has be achived</span><br /><span class="FontName2">boolean button = false;&#160;&#160;&#160;&#160;// flag if the button has been pressed</span><br /><span class="FontName2">byte level = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// curent level holder</span><br /><br /><span class="FontName2">void setup() {</span><br />&#160;&#160;<span class="FontName2">DDRD = DDRD | B11111000; // pins 3 - 7 set data direction</span><br />&#160;&#160;<span class="FontName2">DDRB = DDRB | B00111111; //&#160;&#160;pins 8 - 13</span><br />&#160;&#160;<span class="FontName2">digitalWrite(2,HIGH);&#160;&#160;&#160;&#160;// pull up so the input can be signaled on a low transition</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The code for part 2 of Stop it is the function to perform the LED sweep. The <span class="FontName2">moveLED()</span> function<a id="cXXX.452" /> is called from the main loop. The function first checks if the ON LED is at the first or last LED of the display. The check is performed by <span class="FontName2">AND</span> masking the <span class="FontName2">LEDshift</span> variable. If the mask equals anything other than zero, then the check is <span class="FontName2">true</span>, and depending on which mask is <span class="FontName2">true</span>, you set the flag <span class="FontName2">RightLeft</span> to the proper direction. The function then checks the <span class="FontName2">RightLeft</span> direction variable to bit shift the <span class="FontName2">LEDshift</span> over one every time the <span class="FontName2">moveLED()</span> function is called. The function then calls the <span class="FontName2">displayLED()</span> function<a id="cXXX.453" />.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 2 of 11</p>
<pre><span class="FontName2">void moveLED() {</span><br />&#160;&#160;<span class="FontName2">if (LEDshift &#x0026; 0x0002) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">RightLeft = false;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (LEDshift &#x0026; 0x0800) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">RightLeft = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (!RightLeft ) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift&#160;&#160;&#x003C;&#x003C; 1;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (RightLeft) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift&#160;&#160; &#x003E;&#x003E; 1;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">displayLED();</span><br /><span class="FontName2">}&#160;&#160;// end&#160;&#160;moveLED</span></pre>
<p class="indent">The <span class="FontName2">displayLED()</span> function is part 3 for <a href="#list1">Listing 11-1</a>. This function is responsible for changing the actual pin states to control the LEDs. When the <span class="FontName2">displayLED()</span> function is called, the <span class="FontName2">LEDshift</span> variable is parsed and split to match to the pins that are connected to the LED array. To get the LEDs that are connected to pins 3 through 7, the <span class="FontName2">LEDshift</span> variable is masked against a number that correlates to the position of the bits needed, and the result is then shifted to the left by two positions so that the final result is in the proper position for the pins. Before the total result is written to the register, a <span class="FontName2">NOT</span> operation is performed so that the pins will be in the proper state for the LED.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 3 of 11</p>
<pre><span class="FontName2">void displayLED() {</span><br />&#160;&#160;<span class="FontName2">PORTD =&#160;&#160;&#x223C;((LEDshift &#x0026; 0x003E) &#x003C;&#x003C; 2); // format and place the proper bits into the registers</span><br />&#160;&#160;<span class="FontName2">PORTB =&#160;&#160;&#x223C;((LEDshift &#x0026; 0x0FC0) &#x003E;&#x003E; 6); // portd = low portb = hi</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Part 4 is the function that will be used for the interrupt when the player attempts to stop the LED. This function is held in a loop while the button attached to pin 2 is depressed. The <span class="FontName2">while</span> loop of this function helps to debounce the interrupt because delays do not work inside of interrupts. The function sets the button flag, signifying that the player has made an attempt to stop it. A check of the <span class="FontName2">LEDshift</span> variable verifies that the winning LED is on; this is done by an <span class="FontName2">AND</span> mask. If the proper LED is on, the flag is set to <span class="FontName2">true</span>; otherwise, the flag remains <span class="FontName2">false</span> and will trigger a win or a loss condition when returning from this function.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 4 of 11</p>
<pre><span class="FontName2">void Button(){</span><br />&#160;&#160;<span class="FontName2">while (digitalRead(2)== LOW) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">button = true;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if ((LEDshift &#x0026; 0x0040)) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Win = true;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Win = false;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">} // end while</span><br /><span class="FontName2">} // end button</span></pre>
<p class="indent">Part 5 is the function to check if a button event is a win or a loss. This function is called from the main loop only when a button flag is <span class="FontName2">true</span>. The level gets incremented if a win or a big win is achieved. A big win is achieved when the LED has been stopped 11 successful times. This function calls the <span class="FontName2">flashWin()</span> function for every successful stop and the <span class="FontName2">BigWin()</span> function<a id="cXXX.454" /> for 11 in a row. The level is incremented for every win. If the player does not stop the LED on the winning point, the function will call the <span class="FontName2">notWin()</span> function<a id="cXXX.455" /> to reset the levels and provide the player with the feedback that they have lost.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 5 of 11</p>
<pre><span class="FontName2">void checkWin() {</span><br />&#160;&#160;<span class="FontName2">if (Win) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (level &#x003C; 10) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">flashWin();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (level &#x003E;= 10) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">BigWin();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">IncreaseLevel();</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (!Win) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">notWin();</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">resetPlay ();</span><br /><span class="FontName2">} // end checkWin</span></pre>
<p class="indent"><span class="FontName2">flashWin()</span><a id="cXXX.456" /> is the function that makes up part 6 of the code for Stop it. This function is a reward for the player. A binary pattern is first loaded in to the <span class="FontName2">LEDshift</span> variable of alternating 1s and 0s. Then a loop is used to invert the <span class="FontName2">LEDshift</span> variable, turning 1s into 0s and vice versa. The pattern is displayed by calling the <span class="FontName2">displayLED()</span> function and waiting until the player can see the pattern before continuing through the loop a total of ten times.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 6 of 11</p>
<pre><span class="FontName2">void flashWin() {</span><br />&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">LEDshift = 0xFAAA;</span><br />&#160;&#160;<span class="FontName2">for ( int i = 0 ; i &#x003C; 10; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = &#x223C;LEDshift;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">displayLED();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end flashWin</span></pre>
<p class="indent">The <span class="FontName2">BigWin()</span> function of part 7 is called when the player makes 11 successful wins. This function first calls the <span class="FontName2">flashWin()</span> function and then loads a new pattern, starting from the center LED and radiating outward, turning on all the LEDs. The function does this four times before finishing up with another <span class="FontName2">flashWin()</span>.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 7 of 11</p>
<pre><span class="FontName2">void BigWin () {</span><br />&#160;&#160;<span class="FontName2">flashWin();</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; 4 ; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = 0x0040; // turn on the center LED</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">displayLED();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; 6 ; i++) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift&#160;&#160;| (1&#x003C;&#x003C; 5 - i); // radiate from the center by a logical OR of the 1s</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// into the</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift&#160;&#160;| (1&#x003C;&#x003C; 7 + i); // LEDshift variable</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">displayLED();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (25);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">flashWin();</span><br /><span class="FontName2">} // end BigWin</span></pre>
<p class="indent">Every game has to have a condition for not winning. Part 8 of <a href="#list1">Listing 11-1</a> is the <span class="FontName2">notWin()</span> function. The <span class="FontName2">notWin()</span> function resets the level back to zero and sweeps the LED from right to left. The loop to display the pattern shifts the <span class="FontName2">LEDshift</span> variable to the left by 1, and then increments the variable till the loop is finished.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 8 of 11</p>
<pre><span class="FontName2">void notWin() {</span><br />&#160;&#160;<span class="FontName2">level = 0;</span><br />&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">LEDshift = 0x0001;</span><br />&#160;&#160;<span class="FontName2">for ( int i = 0 ; i &#x003C; 11; i++) {</span><br />&#160;&#160;<span class="FontName2">LEDshift = LEDshift &#x003C;&#x003C; 1;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift++;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">displayLED();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end notWin</span></pre>
<p class="indent">Part 9 is the <span class="FontName2">DspLevel()</span> function<a id="cXXX.457" />, which informs the player what level they are now on. This function is called before the game starts the next level. This function works in the opposite way to the <span class="FontName2">notWin()</span> function, by shifting from left to right. In the loop, 1 is added to the high bit of the <span class="FontName2">LEDshift</span> variable by an <span class="FontName2">OR</span> of <span class="FontName2">0x1000</span>, then bit shifting the variable <span class="FontName2">LEDshift</span> to the right by 1. The loop will run as many times as there are levels.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 9 of 11</p>
<pre><span class="FontName2">void DspLevel() {</span><br />&#160;&#160;<span class="FontName2">LEDshift = 0x0000;</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C;= level ; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift | 0x1000; // add 1 to the high bits of LEDshift</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LEDshift = LEDshift &#x003E;&#x003E; 1 ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">displayLED();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (50);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">delay (500);</span><br /><span class="FontName2">} // end DspLevel</span></pre>
<p class="indent">In part 10 of <a href="#list1">Listing 11-1</a> are the two functions to handle the resetting of game play for each level after the reward and loss patterns are displayed. <a href="#list1">Listing 11-1</a> also includes a function to increment the level after a win condition. The <span class="FontName2">resetPlay()</span> function<a id="cXXX.458" /> first calls the <span class="FontName2">DspLevel()</span> function, and then resets all of the game condition variables to their initial state. The <span class="FontName2">level</span> variable is not reset in this function, but is a condition of a loss.</p>
<p class="indent">When the <span class="FontName2">IncreaseLevel()</span> function<a id="cXXX.459" /> is called, the <span class="FontName2">level</span> variable is incremented by 1. This function also handles the reset to level 0 if the player can make it past level 15; the reset is done by an <span class="FontName2">AND</span> mask. The <span class="FontName2">level</span> variable helps set the speed of the LED sweep and needs to be kept below a certain number; otherwise, the time the LED stays on goes negative and can halt the Arduino. The level reset in this function is also independent of the loss condition reset.</p>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 10 of 11</p>
<pre><span class="FontName2">void resetPlay () {</span><br />&#160;&#160;<span class="FontName2">DspLevel();</span><br />&#160;&#160;<span class="FontName2">Win = false;</span><br />&#160;&#160;<span class="FontName2">button = false;</span><br />&#160;&#160;<span class="FontName2">LEDshift = 0x0001;</span><br />&#160;&#160;<span class="FontName2">RightLeft = false;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void IncreaseLevel() {</span><br />&#160;&#160;<span class="FontName2">level++;</span><br />&#160;&#160;<span class="FontName2">level = level &#x0026; 0x0F;// reset level when greater than 15</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The last function (shown in part 11 of <a href="#list1">Listing 11-1</a>) is the main loop that sets the game into motion and ties together all the functions of <a href="#list1">Listing 11-1</a>. The first thing the <span class="FontName2">loop()</span> function<a id="cXXX.460" /> does is to detach the interrupts so that the player cannot cause false wins or losses. The interrupts are not turned off by the <span class="FontName2">noInterrupts()</span> function<a id="cXXX.461" />, because that would stop the <span class="FontName2">delay()</span> function from working. Once the interrupts have been turned off, the button press and win state flags are checked for handling. After the check for a win or loss, the <span class="FontName2">loop()</span> function moves the ON LED to the next LED in the current direction it is traveling. The <span class="FontName2">moveLED()</span> function handles the movement and direction changes of all the LEDs. After the new LED is on, the interrupt for the <span class="FontName2">button()</span> function<a id="cXXX.462" /> is turned back on, followed by a call to a delay.</p>
<p class="indent">The time<a id="cXXX.463" /> the delay provides is the amount of time that any one LED is on before going to the next LED in the display; this is also the amount of time the player has to react to stop the LED sweep. The time for the delay is set by subtracting the level times 6 from 100. With the first level being equal to 0, the delay will be 100 ms, and every subsequent level shortens the time by 6 ms. the big win occurs after level 11 has been passed; that level has a time of 40 ms between LEDs. This delay sets the difficulty of getting a win a larger delay make the game easier and smaller is more difficult. The difficulty needs to be balanced for the intended audience, and is usually determined by age for arcade games. Games that are for children are often really easy for adults.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; It is important that the delay never goes negative; otherwise, the program will freeze up. Stop it allows a level up to 15 before resetting at a delay 10 ms; at this delay time, it is unlikely that a human player can achieve a win.</p></div>
<p class="noindent2"><b><i>Listing 11-1.</i></b>&#160;&#160;Stop It&#x2019;s Code, Part 11 of 11</p>
<pre><span class="FontName2">void loop() {</span><br /><span class="FontName2">detachInterrupt(0);</span><br /><span class="FontName2">if (button == true) {</span><br />&#160;<span class="FontName2">checkWin();</span><br /><span class="FontName2">}</span><br /><span class="FontName2">moveLED();</span><br /><span class="FontName2">attachInterrupt(0, Button, LOW);</span><br /><span class="FontName2">delay&#160;&#160;( 100 - (level*6));</span><br /><span class="FontName2">}</span></pre>
</div>
<div>
<p id="Sec5" class="Heading2"><a id="cXXX.464" />Verifying the Code</p>
<p class="noindent">Stop it is ready to play after an Arduino is connected to the LEDs and button, as per <a href="#Fig1">Figure 11-1</a> (shown previously in the chapter). Upload all 11 parts of <a href="#list1">Listing 11-1</a> as a single Arduino sketch. Once the upload is finished, the game should start sweeping one LED from one side of the display. Depending on the color of the LEDs used, the display may be reminiscent of the front of a certain black 1980s sports car with artificial intelligence.</p>
<p class="indent">Begin the game by testing your skill, and try to Stop It on the center LED by pressing the button when the center LED is ON. The code should react as describe earlier. Since it may not be easy to test all the way to a big win, this game has a developer (or cheat mode) built in. To enter developer mode and ensure that the code is behaving properly, connect the ground side of the switch to the cathode side of the winning LED. Developer mode will make the button only trigger the interrupt when the center LED is on. Developer mode makes it possible to cycle though all of the levels and back to the first one. </p>
</div>
<div>
<p id="Sec6" class="Heading2">Dirty Little Tricks,</p>
<p class="noindent">Not to detract from the excitement of developing arcade games, but it is worth mentioning the unfair advantage known as rigging that some arcade games might have built into them. Such rigging only allows prizes to be won after certain conditions are met other than those presented within the game (some games never allow prizes to be won at all). This is like the belief that slot machine will only pay out a jack pot when it has received a certain dollar amount. Because arcade games are not regulated the same way as gambling machines, the possible use of rigged mechanisms<a id="cXXX.465" /> has led to some controversy about legalities. Rigging is an unfortunate practice that takes away from a game&#x2019;s entertainment value and in some places can be illegal. Rigging may come up when developing a redemption or merchandiser game for a client.</p>
<p class="indent">It is best practice to make a game as fair as possible but it is up to the developer&#x2019;s judgment. Players will feel cheated when a rigged game is discovered. If the players have an enjoyable gaming experience, they will return to play more games. Games can be challenging, and as long as the players skill is the only factor keeping the player from winning.</p>
<p class="indent">As a game developer be-careful about developing games that are chance based and give prizes, as this can be considered a gambling machine and is highly regulated. But don&#x2019;t be afraid to develop games that provide prizes; it is usually the monetary value of the prize and the frequency that a prize can be won that determines if a game is classified as a gambling machine. A game that always gives a ticket, a piece of candy or a small toy just for starting the game and the game gives more prizes out the longer the player plays is usually not considered gambling because something is awarded for every play and in some cases just putting in a token will award some tickets. Alley roll is an example of this; most alley roll games will provide one ticket for getting the ball to the other end, but if the ball makes it into a scoring ring, more tickets are awarded. However, it is always best to research the laws and regulations when building games that give out prizes.</p>
</div>
<p id="Sec7" class="Heading1">Adding Better Displays and Graphics</p>
<p class="noindent">A lot of unique games can be made with displays made of arrays of LEDs, mechanical flip dots, character LCDs, or small LCD panels. The games made with displays of these styles can sometimes lack the extra shine that may be desired from a television or a computer monitor. The Arduino with a couple of resistors can drive a television using the TV out library (<span class="FontName2"><a href="http://www.arduino.cc/playground/Main/TVout">www.arduino.cc/playground/Main/TVout</a></span>), but is only capable of providing black-and-white images and only works with devices that have an RCA connection. To have the power to drive more complex graphics, additional hardware&#x2014;a graphics processing unit (GPU)&#x2014;is required.</p>
<p class="indent">The Gameduino<a id="cXXX.218a" /> was designed to be a GPU for the Arduino and is a shield that provides a graphics platform<a id="cXXX.466" /> that can create complex graphics and animations. The Gameduino&#x2019;s processor is programmed in to a Xilinx Spartan Field Programmable Gate Array (FPGA) and can connect to any microcontroller that is capable of SPI communication, even though it is packaged as a standard Arduino shield. The Gameduino can output video to a VGA-comparable display at 400&#x00D7;300 pixels with 512 colors, and can fully draw sprites, bitmaps, and backgrounds and generate stereo sound. The Gameduino is compatible with computer monitors with at least 800&#x00D7;600 resolution. The graphics capabilities of the Gameduino are very similar to 1980s video game consoles and older arcade games. The Gameduino also includes a secondary coprocessor that is independent of the main graphics functionality and is used to generate bitmaps for wireframe effects and control the video registers to create split-screen games.</p>
<p class="indent">The use<a id="cXXX.467" /> of the Gameduino<a id="cXXX.468" /> offloads all the graphics and display functions from the Arduino, leaving the Arduino free to control the game logic, handle user input, and track game progress. The Arduino initializes the Gameduino by copying to RAM all image data, sound data, and, if necessary, programming for the secondary processor to the Gameduino&#x2019;s memory. The Gameduino has 32 KB of internal memory and is split up into background images, sprite images, and program space.</p>
<p class="indent">This chapter just introduces the Gameduino basics to show you how to build a functional game. Gameduino reference material is available at <span class="FontName2"><a href="http://www.excamera.com/sphinx/gameduino/">www.excamera.com/sphinx/gameduino/</a></span> and has samples and tutorials for more complex game feature, such as split screen and 3D wireframe. Download the quick-reference poster for working with the example in this section from the above site. The Gameduino is available at many online retailers, such as SparkFun Electronics, Adafruit Industries, and Jameco electronics.</p>
<div>
<p id="Sec8" class="Heading2">Gameduino Library</p>
<p class="noindent">The Gameduino is a SPI device that you can run the with standard SPI communication<a id="cXXX.469" /> practices mentioned in <a href="9781430239390_Ch10.xhtml">Chapter 10</a>. But for ease of getting games working quickly, the Gameduino library will be used for this section, and is available on the Gameduino&#x2019;s website (<span class="FontName2"><a href="http://www.excamera.com/files/gameduino/synth/sketches/Gameduino.zip">www.excamera.com/files/gameduino/synth/sketches/Gameduino.zip</a></span>). The library installs in the standard Arduino location and needs to be modified to work with the Arduino 1.0.1 and above IDE.</p>
<p class="indent">To make the Gameduino library compatible, the <span class="FontName2">include &quot;Wprogram.h</span><a id="cXXX.470" /><span class="FontName2">&quot;</span> in the beginning of <span class="FontName2">GD.cpp</span> needs to be changed to include <span class="FontName2">Arduino.h</span>; this can be done in any text editor.</p>
<p class="indent">The following list is a reference of the most common functions that will be used from the Gameduino&#x2019;s library. All of the functions can be called with a preceding <span class="FontName2">GD.</span> before the function call.</p>
<ul class="bulleted">
<li><span class="FontName2">begin()</span><a id="cXXX.471" />: Starts a connection to the Gameduino; returns <span class="FontName2">true</span> if successful.</li>
<li><span class="FontName2">rd(address)</span><a id="cXXX.472" />: Returns a byte read from the Gameduino&#x2019;s memory located at <span class="FontName2">address</span>.</li>
<li><span class="FontName2">wr(address, data)</span><a id="cXXX.473" />: Writes a byte of data to the Gameduino&#x2019;s memory at specified <span class="FontName2">address</span>.</li>
<li><span class="FontName2">rd16(address)</span><a id="cXXX.474" />: Same as <span class="FontName2">rd()</span>, but reads 16 bits from memory, instead of 8 bits, at <span class="FontName2">address</span> and <span class="FontName2">address</span> +1.</li>
<li><span class="FontName2">wr16(address, data)</span><a id="cXXX.475" />: Writes 16 bits to memory.</li>
<li><span class="FontName2">fill(address, data, amount)</span><a id="cXXX.476" />: Copies 1 byte to consecutive memory addresses up to <span class="FontName2">amount</span>.</li>
<li><span class="FontName2">copy(address, data pointer, amount)</span><a id="cXXX.477" />: Copies data from the Arduino&#x2019;s memory to a Gameduino address.</li>
<li><span class="FontName2">setpal(palett</span>e<span class="FontName2">, RGB)</span><a id="cXXX.478" />: Sets the character color palette.</li>
<li><span class="FontName2">RGB</span><a id="cXXX.479" /><span class="FontName2">(R, G, B)</span>: Converts RGB byte values to 15-bit encoding for the Gameduino.</li>
<li><span class="FontName2">sprite(sprite #, position x, position y, image #, palette, rotation, collision)</span>: Tells the Gameduino to draw a sprite to the display. <a href="#Tab1" id="_Tab1">Table 11-1</a> describes the parameters for drawing sprites to the display.
<div class="Table" id="Tab1">
<p class="TabCapt"><span class="CaptNr"><a href="#_Tab1">Table 11-1</a>. </span>Arguments for the sprite() Function<a id="cXXX.480" /> </p>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="FontName2">sprite #</span></td>
<td>Onscreen sprite number that addresses the individual sprite value between 0 and 255</td>
</tr>
<tr>
<td><span class="FontName2">position x</span></td>
<td>Horizontal sprite position value between 0 and 511; 0 is the left edge of screen</td>
</tr>
<tr>
<td><span class="FontName2">position y</span></td>
<td>Vertical sprite position on the screen value between 0 and 511; 0 is the top edge of screen</td>
</tr>
<tr>
<td><span class="FontName2">image #</span></td>
<td>Selects a background sprite to display from The Gameduino&#x2019;s RAM value between 0 and 63</td>
</tr>
<tr>
<td><span class="FontName2">palette</span></td>
<td>Color palette to use when rendering the sprite value between 0 and15</td>
</tr>
<tr>
<td><span class="FontName2">rotation</span></td>
<td>Sets the rotation and flip of the sprite</td>
</tr>
<tr>
<td><span class="FontName2">collision</span></td>
<td>Sets the collision detect flag</td>
</tr>
</tbody>
</table>
</div></li>
<li><span class="FontName2">sprite2x2</span><a id="cXXX.481" /><span class="FontName2">(sprite #, position x, position y, image #, palette, rotation, collision)</span>: Sets a 2&#x00D7;2 sprite to be drawn at the center four corners; uses same parameters as <span class="FontName2">sprite()</span>.</li>
<li><span class="FontName2">ascii()</span><a id="cXXX.482" />: Loads Gameduino&#x2019;s standard font.</li>
<li><span class="FontName2">putstr</span><a id="cXXX.483" /><span class="FontName2">(position x, position y, string)</span>: Prints a string encapsulated in quotes at the position (x, y). Needs <span class="FontName2">ascii()</span> to be run first to load the default font.</li>
<li><span class="FontName2">voice(voice #, wave type, frequency, left volume, right volume)</span>: Sets a tone to be played out of the Gameduino&#x2019;s audio port. <a href="#Tab2" id="_Tab2">Table 11-2</a> describes the <span class="FontName2">voice()</span> parameters.
<div class="Table" id="Tab2">
<p class="TabCapt"><span class="CaptNr"><a href="#_Tab2">Table 11-2</a>. </span>Arguments for the voice() Function<a id="cXXX.484" /> </p>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="FontName2">voice #</span></td>
<td>Individual hardware voice number used to output sound; takes a value between 0 and 63</td>
</tr>
<tr>
<td><span class="FontName2">wave type</span></td>
<td>Waveform (0 is sine wave, 1 is noise)</td>
</tr>
<tr>
<td><span class="FontName2">frequency</span></td>
<td>Frequency in quarter-Hertz (e.g., 100 Hz is 400)</td>
</tr>
<tr>
<td><span class="FontName2">left volume</span>, <span class="FontName2">right volume</span></td>
<td>Amplitude of the wave output per channel; takes a value between 0 and 255; total volume for all voices should be less than or equal to 255</td>
</tr>
</tbody>
</table>
</div></li>
</ul>
<p class="indent">Some of the functions require a memory address to be able to read or place data into the Gameduino. The library also defines some keywords<a id="cXXX.485" /> that are helpful when calling functions that deal with memory addresses. <a href="#Tab3" id="_Tab3">Table 11-3</a> provides the name, address, and descriptor; the keywords referenced are the common memory locations for developing games. </p>
<div class="Table" id="Tab3">
<p class="TabCapt"><span class="CaptNr"><a href="#_Tab3">Table 11-3</a>. </span>Useful Keywords Specific to the Gameduino&#x2019;s memory sructure and begging adresse locations. memory addresses * Byte length = total bytes in memory </p>
<table>
<thead>
<tr class="header">
<th>Keyword</th>
<th>Address</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="FontName2">RAM_CHR</span></td>
<td><span class="FontName2">0x1000</span></td>
<td>Screen characters (256 &#x00D7;16 = 4096 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">RAM_PAL</span></td>
<td><span class="FontName2">0x2000</span></td>
<td>Screen character palette (256&#x00D7;8 = 2048 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">RAM_SPR</span></td>
<td><span class="FontName2">0x3000</span></td>
<td>Sprite control (512&#x00D7;4 = 2048 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">RAM_SPRPAL</span></td>
<td><span class="FontName2">0x3800</span></td>
<td>Sprite palettes (4&#x00D7;256 = 2048 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">RAM_SPRIMG</span></td>
<td><span class="FontName2">0x4000</span></td>
<td>Sprite image (64&#x00D7;256 = 16384 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">PALETTE16A</span></td>
<td><span class="FontName2">0x2840</span></td>
<td>16-color palette RAM A (32 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">PALETTE16B</span></td>
<td><span class="FontName2">0x2860</span></td>
<td>16-color palette RAM B (32 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">PALETTE4A</span></td>
<td><span class="FontName2">0x2880</span></td>
<td>4-color palette RAM A (8 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">PALETTE4B</span></td>
<td><span class="FontName2">0x2888</span></td>
<td>4-color palette RAM A (8 bytes)</td>
</tr>
<tr>
<td><span class="FontName2">VOICES</span></td>
<td><span class="FontName2">0x2a00</span></td>
<td>Voice controls</td>
</tr>
</tbody>
</table>
</div>
</div>
<div>
<p id="Sec9" class="Heading2">A New Stop It</p>
<p class="noindent">Building on top of other working projects is a great way to help simplify the development of more complex projects. The game for this section takes the idea of Stop it and expands it into the second dimension. The new game, called Stack It<a id="cXXX.486" />, as almost the same challenge as Stop It, but instead of requiring the player to stop a scrolling LED, Stack it uses scrolling sprites that need to be stopped when the current moving sprites are in the same position as the past sprites. Stack it speeds up and moves to the next level up the screen instead of displaying the level between each win.</p>
<p class="indent">There are two mechanisms of difficulty:</p>
<ul class="bulleted">
<li>The speed of the row</li>
<li>The number of sprites that need to be matched</li>
</ul>
<p class="indent">If the player misses the position of the previous row, the game removes sprites for the next level until the player has no more sprites left to play. <a href="#Fig2" id="_Fig2">Figure 11-2</a> shows the game play of Stack it with the last level still in play. The first level is always a gimme; it allows the player to decide where to start the stack and then continue through 16 levels to a big win. </p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig11-02.jpg" alt="9781430239390_Fig12-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 11-2</a> </span>.&#160;&#160;Stack it&#x2019;s game play </p>
</div>
<p class="indent">The hardware setup for Stack it includes the Gameduino and a button; <a href="#Fig3" id="_Fig3">Figure 11-3</a> shows the setup for the Arduino. You need to plug the Gameduino into the Arduino, making sure to align the pins and one lead of a button connected to ground, and the other lead connected to pin 2 in the headers of the Gameduino. The Gameduino only uses digital pins<a id="cXXX.487" /> 9, 11, 12, and 13. Pin 9 is the slave select and is unavailable for any other function. Pins 11, 12, and 13 are the standard SPI connections and can be used to connect other SPI devices, such as SD cards. The power for the Gameduino comes from the 3.3V, 5V, and ground of the Arduino and requires no extra connectors. The Gameduino can be connected to a monitor or a television with a VGA port.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Some televisions may not be compatible with the Gameduino&#x2019;s signal. For best results, use a monitor that is capable of 800&#x00D7;600 resolutions and has 4:3 aspect ratio. You can try a VGA-to-HDMI converter if no analog display inputs are available.</p></div>
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig11-03.jpg" alt="9781430239390_Fig12-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 11-3</a> </span>.&#160;&#160;Stack it&#x2019;s hardware configuration </p>
</div>
</div>
<div>
<p id="Sec10" class="Heading2">Art</p>
<p class="noindent">When developing a game, the art and graphics<a id="cXXX.488" /> usually don&#x2019;t get finished till the all the game mechanisms are working. On the Gameduino, however, some graphics need to be available for display so that the game mechanisms can be developed. The graphics can be a placeholder or a simplistic version of what might be the final graphic. If game is a side-scroller, the player controls a main character that is an animated sprite. For initial development, the sprite can be just a single frame of the animation. Stack it only uses one sprite and the background doesn&#x2019;t move.</p>
<p class="indent">Art for the Gameduino uses a special format that needs to be converted from an existing file or hand coded. Each sprite is 16&#x00D7;16 pixels. The Gameduino does not store each sprite with the color information, but instead uses a separate color palette and draws sprites to the screen in a way similar to color-by-numbers. The Gameduino offers three palette types 4, 16, or 256 and describe the amount of different colors that the palette can hold. The use of the palettes saves memory because each color needs 16 bits and is in ARGB1555 format and if the color information was saved in every pixel, 64 sprites would need 32 KB of memory, as compared to the 16.5 KB used by the separate color palette. <a href="#Fig4" id="_Fig4">Figure 11-4</a> illustrates the ARGB color format used to create color; bit 15 is the flag for transparency and each of the five bits for R, G, and B. The Gameduino is little-endian when it comes to memory; the lower bits (0 through 7) need to be copied to the address and the higher bits (8 through 15) are copied to the address plus 1.</p>
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig11-04.jpg" alt="9781430239390_Fig12-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 11-4</a> </span>.&#160;&#160;ARGB 1555 color format </p>
</div>
<p class="indent">The sprite used for Stack it is illustrated in <a href="#Fig5" id="_Fig5">Figure 11-5</a>, using the coding to the 4-color palette. Each sprite maps 1 byte to the color palette per pixel. One sprite can be made with a 265-color palette, two sprites with a 16-color palette, and four sprites with a 4-color palette. Using the 4-color palette allows more sprites to be in memory, because it takes 2 bits to map to a color, and 8 bits are available. Each 2 bits of the sprite map can describe a different color used; this is good for space saving and making animated sprites. When multiple sprites are combines in one map, they can be added to the screen by changing the palette argument when calling the <span class="FontName2">sprite()</span> function. Larger graphics can be made by placing two or more sprites side by side on the screen. </p>
<div class="Figure" id="Fig5">
<p class="img"><img src="images/9781430239390_Fig11-05.jpg" alt="9781430239390_Fig12-05.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig5">Figure 11-5</a> </span>.&#160;&#160;Stack it&#x2019; s sprite with palette coding </p>
</div>
<p class="indent"><a href="#Fig6" id="_Fig6">Figure 11-6</a> illustrates the color palette used for Stack it. It consists of the colors black, red, green, and blue. Any color value can be used, however There is a limit to amount of different colors that the palette can hold. Stack It&#x2019;s sprite only uses three of the four colors available. You can give sprites transparent pixels by setting bit 15 to 1 on one of the colors. When transparency is used, the color information for R, G, and B are ignored and only one color needs to be transparent. Transparency allows for background colors to show; this is useful for non-square character sprite move over a changing background the background.</p>
<p class="indent"></p>
<div class="Figure" id="Fig6">
<p class="img"><img src="images/9781430239390_Fig11-06.jpg" alt="9781430239390_Fig12-06.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig6">Figure 11-6</a> </span>.&#160;&#160;Four-color palette using black, red, green, and blue (from left to right) </p>
</div>
<p class="indent">The Gameduino Tools Online page (<span class="FontName2"><a href="http://gameduino.com/tools">http://gameduino.com/tools</a></span>) offers three great tools that convert image files to the proper coding to avoid hand coding sprites, backgrounds and lossy images. The tool also provides an Arduino sketch to quickly check the sprites on the display before putting them in a game. The tool provides a <span class="FontName2">.h</span> file that contains the converted image. The three types of conversions tools background, sprite sheets and lossy image conversion requires an image to convert. The sprite sheet tool also has options for the sprite size and color palette type.</p>
<p class="indent">The easiest way to get started making sprites is to use GIMP (<span class="FontName2"><a href="http://www.gimp.org/">www.gimp.org/</a></span>)&#x2014;free, open source image manipulation software that is capable of creating PNG files. When creating a new sprite image, it is best to work at the actual pixel size and with dimensions in multiples of 16. Multiple different sprites can be made in one file, and the conversion tool will divide them up according to the settings. Note that the conversion tool may not always get the colors perfect and manual manipulation of the palette may be required in the Arduino sketch. </p>
</div>
<div>
<p id="Sec11" class="Heading2">Coding Stack It</p>
<p class="noindent">To get started coding Stack it, create a new sketch and add a new file within the Arduino IDE by pressing Ctrl+Shift+N, and enter <b>cube.h</b> when prompted. <a href="#list2" id="_list2">Listing 11-2</a> contains the converted image from the Gameduino image tool&#x2014;the variables names in <span class="FontName2">cube.h</span> are generated by the image tool. <a href="#list2">Listing 11-2</a> uses only the image information<a id="cXXX.489" /> and does not include the function that is autogenerated by the image tool. Two static arrays are declared in <span class="FontName2">cube.h</span>. The first is <span class="FontName2">cube_sprimg[]</span><a id="cXXX.490" />, which is the mapping to the color palette, and the other is <span class="FontName2">cube_sprpal[]</span>. The bytes set in both <span class="FontName2">cube_sprimg[]</span> and <span class="FontName2">cube_sprpal[]</span><a id="cXXX.491" /> are in the order they will be loaded into the Gameduino&#x2019;s memory. Because of the little-endian mode of the Gameduino, the palette has the lower byte of the color set before the higher byte.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 11-2.</i></b></a>&#160;&#160;Sprite Code for Stack It</p>
<pre><span class="FontName2">static PROGMEM prog_uchar cube_sprimg[] = {</span><br /><span class="FontName2">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,</span><br /><span class="FontName2">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,</span><br /><span class="FontName2">};</span><br /><br /><span class="FontName2">static PROGMEM prog_uchar cube_sprpal[] = {</span><br /><span class="FontName2">0x00,0x00,&#160;&#160;0x00,0x7c,&#160;&#160;0xe0,0x03,&#160;&#160;0xff,0xff,</span><br /><span class="FontName2">};</span></pre>
<p class="indent">With the sprite for Stack it ready, the game-play code can be added. Stack it shares a similar concept with Stop it and also shares similar coding methods for the game mechanisms. <a href="#list3" id="_list3">Listing 11-3</a> is entered in to the main part of the sketch and is broken up into seven parts. Part 1 of Stack it sets up the variable decorations, includes, and the <span class="FontName2">setup()</span> function<a id="cXXX.492" />. The Gameduino library (<span class="FontName2">GD.h</span>), SPI library (<span class="FontName2">SPI.h</span>), and cube header (<span class="FontName2">cube.h</span>) needs to be included to have access to the functions used by Stack It. The <span class="FontName2">cube.h</span> file is included with quotes instead of <span class="FontName2">&#x003C; &#x003E;</span>, signaling the compiler to look for a local file in the sketch folder instead of searching for the header file in a library location. The order of the library includes is important; the <span class="FontName2">SPI.h</span> include comes before <span class="FontName2">cube.h</span>, and <span class="FontName2">GD.h</span> is the last include.</p>
<p class="noindent2"><a href="#_list3" id="list3"><b><i>Listing 11-3.</i></b></a>&#160;&#160;Stack It&#x2019;s Sketch, Part 1 of 7</p>
<pre><span class="FontName2">#include &#x003C;SPI.h&#x003E;</span><br /><span class="FontName2">#include &quot;cube.h&quot;</span><br /><span class="FontName2">#include &#x003C;GD.h&#x003E;</span><br /><br /><span class="FontName2">long cubeMove[18];</span><br /><span class="FontName2">boolean RightLeft;</span><br /><span class="FontName2">boolean Win = false;</span><br /><span class="FontName2">boolean button = false;</span><br /><span class="FontName2">int level = 0;</span><br /><br /><span class="FontName2">long initPattern = 0x0000001f;</span><br /><br /><span class="FontName2">void setup() {</span><br />&#160;&#160;<span class="FontName2">pinMode(2,INPUT);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(2,HIGH);</span><br />&#160;&#160;<span class="FontName2">GD.begin();</span><br />&#160;&#160;<span class="FontName2">GD.copy(PALETTE4A, cube_sprpal, sizeof(cube_sprpal));</span><br />&#160;&#160;<span class="FontName2">GD.copy(RAM_SPRIMG, cube_sprimg, sizeof(cube_sprimg));</span><br />&#160;&#160;<span class="FontName2">resetPlay();</span><br /><span class="FontName2">}&#160;&#160;// end setup</span></pre>
<p class="indent">The integer that was the <span class="FontName2">LEDshift</span> variable in Stop it is changed to a long array; this is to account for the increased number of elements that can be displayed on the screen. The array is declared as size 18 so that every level can be accounted for when displaying the sprites. The flags for the win, direction, and button press serve the same function as those used in Stop It. A variable that stores the initial pattern that will be used for the first level of the game is created here. The binary pattern of the variable is used when displaying the sprites. The pattern of the bits can be used to make the game more challenging the more bits that are placed consecutively will provide an easier challenge, allowing for the player to miss the target more often. The bit pattern does not have to be consecutive making the game more interesting. Remember that the Gameduino can only have 256 sprites on the screen at any given moment, so choose an initial pattern that will keep the sprite count<a id="cXXX.493" /> below 256. There are 17 levels of Stack it, but 18 array positions&#x2014;one of the array positions is used to create a base at the bottom of the screen below the first level and will use 24 of the available sprites.</p>
<p class="indent">The <span class="FontName2">setup()</span> function prepares the Arduino pin that will be used for the button, and is similar to the setup function as used in Stop it. The setup function adds the initialization of the Gameduino and copies the sprite and palette to memory. The memory locations used is the first four-color palette and the start of the sprite RAM section. The image is copied from the <span class="FontName2">cube.h</span> variables. The final step in the <span class="FontName2">setup()</span> function is to call <span class="FontName2">resetPlay()</span> to make sure the game is ready to play.</p>
<p class="indent">The function for part 2 is responsible for shifting the row of sprites from one side of the display to the other. The <span class="FontName2">RowShift()</span> function<a id="cXXX.494" /> is almost identical to the <span class="FontName2">moveLED()</span> function for Stop it; it checks for when the bit-shift reaches the existents of the screen changing the bit-shift direction. The only change accounts for the increased bits used for the position, and the level determines what position of the array is currently in play.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 2 of 7</p>
<pre><span class="FontName2">void RowShift() {</span><br />&#160;&#160;<span class="FontName2">if (cubeMove[16-level] &#x0026; 0x00000001){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">RightLeft = false;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (cubeMove[16-level] &#x0026; 0x00800000){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">RightLeft = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (!RightLeft ){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">cubeMove[16-level] = cubeMove[16-level]&#160;&#160;&#x003C;&#x003C; 1;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (RightLeft){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">cubeMove[16-level] = cubeMove[16-level]&#160;&#160;&#x003E;&#x003E; 1;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end row shift</span></pre>
<p class="indent">The function that is responsible for displaying the game to the player is the same in functionality as the display function for Stop it, but is executed differently. The use of the Gameduino allows for dynamic positioning of game elements within the 400&#x00D7;300 pixel viewing area, and there are no registers to directly manipulate. Part 3 is the function for displaying all the sprites to the screen. The <span class="FontName2">cubeMove</span> array<a id="cXXX.495" /> is used to hold the patterns that need to be displayed. Every time the <span class="FontName2">displaySprites()</span> function<a id="cXXX.496" /> is called, it will display all the current values of <span class="FontName2">cubeMove</span>; A value of 1 equals a sprite, and a sprite will be displayed according to position within the array. The array is two dimensional there is a vertical and a horizontal component; the array position is the vertical and the individual bits within the variable makes up the horizontal position. Stepping through the array is done with one <span class="FontName2">for</span> loop, while a nested <span class="FontName2">for</span> loop shifts though the bits of the variable. When there is a 1 in the variable, a sprite is displayed, and when there is a 0, the loop continues to the next step. The position of the sprite on the screen is determined by what step each <span class="FontName2">for</span> loop is at, the sprite is 16&#x00D7;16 pixels. The step count of the <span class="FontName2">for</span> loops is multiplied by 16 so the sprites will be place side by side on the screen. A counter that is incremented when a 1 is found to keep track of the number of sprites being displayed and is used to create a dynamic sprite count for the Gameduino.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 3 of 7</p>
<pre><span class="FontName2">void displaySprites() {</span><br />&#160;&#160;<span class="FontName2">int spriteNum = 0; // start sprite count at 0</span><br />&#160;&#160;<span class="FontName2">for (int y = 0 ; y &#x003C; 18 ; y ++ ) { // loop though the array for y positon</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int x = 0 ; x &#x003C; 24 ; x ++) {&#160;&#160;//&#160;&#160;loop though the variable for x positon</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if ((cubeMove[y] &#x003E;&#x003E; x) &#x0026; 0x00000001) { // check current variable position for a 1</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">GD.sprite(spriteNum, (x* 16)+7, (y*16)+7 ,0, 8 , 0);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">spriteNum++;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">} // end if</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">} // end for loop x</span><br />&#160;&#160;<span class="FontName2">} // end for loop y</span><br /><span class="FontName2">} // end displaySprites</span></pre>
<p class="indent">The <span class="FontName2">buttonInterrupt()</span><a id="cXXX.497" /> and <span class="FontName2">WinState()</span> functions<a id="cXXX.498" /> implement part 4. <span class="FontName2">buttonInterrupt()</span> is called when the player attempts to win the current level and move on to the next. The interrupt is activated in the same fashion as in Stop it. <span class="FontName2">buttonInterrupt()</span> waits in a loop while the button is depressed and calls the <span class="FontName2">WinState()</span> function to determine if the player has won or not. The check for a win condition has been moved to a separate function to allow for possible other functions to check for win conditions outside of the player&#x2019;s control. A win state is <span class="FontName2">true</span> if there is at least 1 bit in common between the current level and the prior level. The first level of the game is compared against the foundation bits in the <span class="FontName2">cubeMove</span> array. The first level is always a gimme, and allows the player to decide where the stack starts. If there are no common bits, the win state is <span class="FontName2">false</span> and the game is reset.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 4 of 7</p>
<pre><span class="FontName2">void buttonInterrupt&#160;&#160;() {</span><br />&#160;&#160;<span class="FontName2">while ( digitalRead(2)== LOW) {</span><br />&#160;&#160; <span class="FontName2">WinState();</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end buttonInterrupt</span><br /><br /><span class="FontName2">void WinState() {</span><br />&#160;&#160;<span class="FontName2">button = true;</span><br />&#160;&#160;<span class="FontName2">if ((cubeMove[16-level] &#x0026; cubeMove[17-level])) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Win = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Win = false;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end WinState</span></pre>
<p class="indent">Part 5 performs actions based on the win state when the player presses the button and increases the level. If the win state is <span class="FontName2">true</span>, then the prior level is masked with the current to determine the amount of sprites that are in common. If some of the sprites are not directly above the prior level, they get removed, and the new amount of sprites is copied to the next level, making it more difficult for the player along with decreasing the time the player has to react. If the win state is <span class="FontName2">false</span>, the game simply resets. The <span class="FontName2">IncreaseLevel()</span> function<a id="cXXX.499" /> works like the one for Stop it, but the masking of the level count is unavailable because of the array. An <span class="FontName2">if</span> statement is used in place of the mask, and when the level reaches 17, the final pattern within <span class="FontName2">cubeMove()</span> is displayed and the game is reset. A reward function can be called at the point the level is maxed.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 5 of 7</p>
<pre><span class="FontName2">void checkWin() {</span><br />&#160;&#160;<span class="FontName2">if (Win) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">// check prior level and set curent level to any misses and copy to next level</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">cubeMove[15-level] = cubeMove[16-level] = cubeMove[16-level] &#x0026; cubeMove[17-level];</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">IncreaseLevel();</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (!Win) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">resetPlay ();</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">button = false;</span><br /><span class="FontName2">} // end checkWin</span><br /><br /><span class="FontName2">void IncreaseLevel() {</span><br />&#160;&#160;<span class="FontName2">level ++ ;</span><br />&#160;&#160;<span class="FontName2">if (level &#x003E;= 17) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">// display winning pattern and reset play</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">displaySprites();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (200);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">resetPlay();</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end IncreaseLevel</span></pre>
<p class="indent">The <span class="FontName2">resetPlay()</span> function<a id="cXXX.500" /> of part 6 ensures that the game is set back to the beginning and ready for a new attempt. The <span class="FontName2">cubeMove</span> array is first zeroed and loaded with the initial state. The Gameduino then needs the sprite buffer cleared, because sprites with a higher number than that currently produced from the <span class="FontName2">cubeMove</span> pattern will remain on the screen. A loop is used to step through all 256 possible sprites and tell the Gameduino to draw blank sprites off the screen.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 6 of 7</p>
<pre><span class="FontName2">void resetPlay () {</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; 17 ; i ++) {</span><br />&#160;&#160;<span class="FontName2">cubeMove [i] = 0x00000000;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">cubeMove[16] = initPattern;</span><br />&#160;&#160;<span class="FontName2">cubeMove[17] = 0x00ffffff;</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; 256 ; i ++) {</span><br />&#160;&#160;<span class="FontName2">GD.sprite(i,450,450,0,0,0);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">level = 0;</span><br /><span class="FontName2">} // end resetPlay</span></pre>
<p class="indent">As with Stop it, the final function is the loop (shown in part 7) sets the play into motion for the game. Other than the names of the functions that are called, this function is nearly identical to the one used in Stop it. To account for the increase in levels and the gimme level, the initial delay has been increased to 120 ms, leaving 18 ms for the player to react at the final level. Because of the increased complexity and the display speeds included with the Gameduino, the program spends a bit more time with the interrupt off.</p>
<p class="noindent2"><b><i>Listing 11-3.</i></b>&#160;&#160;Stack It&#x2019;s Sketch, Part 7 of 7</p>
<pre><span class="FontName2">void loop() {</span><br />&#160;&#160;<span class="FontName2">detachInterrupt(0);</span><br />&#160;&#160;<span class="FontName2">if (button) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">checkWin();</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">RowShift();</span><br />&#160;&#160;<span class="FontName2">displaySprites();</span><br />&#160;&#160;<span class="FontName2">attachInterrupt(0, buttonInterrupt, LOW);</span><br />&#160;&#160;<span class="FontName2">delay (120 - ( level * 6));</span><br /><span class="FontName2">} // end loop</span></pre>
</div>
<div>
<p id="Sec12" class="Heading2">Verifying the Code<a id="cXXX.501" /></p>
<p class="noindent">At this point, the code for Stack it is ready for a trial run. Configure the hardware as per <a href="#Fig3">Figure 11-3</a> (shown earlier in the chapter), and load the sketch onto the Arduino. The game should start immediately after the upload is finished and display four sprites in a row sweeping from side to side above a full row of sprites at the bottom. Once the button is pressed, the current level will stop and move to the next level. Check to see if the game-loss functionality is working by failing to match up the sprites. The game should fully reset when the last sprite is lost. Stack it does not have a convenient developer mode like Stop it has; the final levels have to be reached naturally or the delay has to be increased to check the reset to the beginning from the final win.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; The SPI library is standard and included with the Arduino IDE. Go to the root directory, and then <span class="FontName2">arduino/avr/libraries</span>; also remember to fix the reference to <span class="FontName2">Wprogram.h</span> to point to <span class="FontName2">Arduino.h</span> within <span class="FontName2">GD.cpp</span>.</p></div>
</div>
<div>
<p id="Sec13" class="Heading2">Making Sounds</p>
<p class="noindent">The Gameduino has the capability to produce stereo sounds<a id="cXXX.502" /> via the audio plug. The <span class="FontName2">voice()</span> function in the Gameduino library can play two different types of wave functions: a sine wave and noise. The frequency range is about 10 to 8,000 Hz via a 12-bit synthesizer. The Gameduino is capable of 64 different voices that combine to create the output. The total amplitude of all the playing voices&#x2019; output is a maximum value of 255 per channel&#x2014;to avoid clipping, keep the total amplitude under 255. The frequency argument of the voices is in quarter-Hertz&#x2014;for example, a frequency of 880 Hz (an A note) would require an input of 3,520. By adding the sine waves together simulated square and sawtooth waves can be created to better mimic the sound of old game systems. The noise wave in conjunction with sine waves can create sound effects for rockets, car engines, and even fighting games. Once the Gameduino is told to start making a sound, it will continue till told to change. The sound needs time to be heard by the listener, so there will have to be time delays in the code. This can slow down other aspects in the game. Note that changes should happen between running of loops, or in more advanced cases, run in the Gameduino&#x2019;s secondary processor. Sound is a great way to give the player feedback on what is going on (e.g., for losing or completing a level, or to produce a sense of urgency at certain parts of the game).</p>
<p class="indent">Adding the first sound effect to Stack it provides an auditory signal when the button has been pressed, add the following code line to the beginning of <span class="FontName2">buttonInterrupt()</span> before the loop is entered to have the game make a sound when the button is pressed.</p>
<pre><span class="FontName2">GD.voice(0, 0, 5000,254,254);</span></pre>
<p class="indent">A sound of 1,250 Hz (approximately an E-flat) will start playing from both channels. To get the sound to turn off, add a corresponding call at the end of the <span class="FontName2">buttonInterrupt()</span> that would appear just before the <span class="FontName2">buttonInterrupt()</span>&#160;&#160;function returns:</p>
<pre><span class="FontName2">GD.voice(0,0, 0,0,0);</span></pre>
<p class="indent"><a href="#list4" id="_list4">Listing 11-4</a> describes three functions that produce more complicated sounds to inform the player of a loss, a big win, and that the game is currently being played.</p>
<p class="indent">The first sound function, <span class="FontName2">moveTone()</span>, plays three notes: 500 Hz (&#x223C;B), 750 Hz (&#x223C;F sharp), and 1,000 Hz (&#x223C;B + 1 octave). The note timings are based on the delay of the main loop. <span class="FontName2">moveTone()</span> generates sound that increases in tempo along with the increase in sweep speed of the sprite. The increase in the tempo as the game approaches the final level provides the feeling of greater urgency. <span class="FontName2">moveTone()</span> needs two global variables that are used to count the steps between note changes and to allow other functions to turn the move tone on and off. The variables are an integer and a Boolean declared at the beginning of the code, just after the include section.</p>
<pre><span class="FontName2">int movetonecount = 0;</span><br /><span class="FontName2">boolean moveToneflag = true;</span></pre>
<p class="indent"><a href="#list4">Listing 11-4</a> is split into three parts. The <span class="FontName2">moveTone()</span>, <span class="FontName2">WinTone()</span>, and <span class="FontName2">LossTone()</span> functions are added to the end of the main sketch after the end of the <span class="FontName2">loop()</span> function. The call to <span class="FontName2">moveTone()</span> is at the end of the <span class="FontName2">loop()</span> function just before <span class="FontName2">loop()</span>&#x2019;s ending curly bracket.</p>
<p class="noindent2"><a href="#_list4" id="list4"><b><i>Listing 11-4.</i></b></a>&#160;&#160;moveTone() Sound Functions for Stack It, Part 1 of 3 </p>
<pre><span class="FontName2">void moveTone() {</span><br />&#160;&#160;<span class="FontName2">if (moveToneflag) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (movetonecount &#x003E;= 2) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">GD.voice(0, 0, movetonecount*1000,127,127);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (movetonecount == 5){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">GD.voice(0, 0, 0,0,0);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">movetonecount = 0 ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">movetonecount++;</span><br />&#160;&#160;<span class="FontName2">} // end if moveToneflag</span><br /><span class="FontName2">} // end moveTone</span></pre>
<p class="indent"><a href="#list4">Listing 11-4</a> part 2 is the <span class="FontName2">WinTone()</span> sound function, and is used to signify the final win. <span class="FontName2">WinTone()</span> plays six tones (750 Hz, 1000 Hz, 1250 HZ, 1000 Hz, 750 Hz, and 500 Hz) twice in a row to give the player a pleasant audio reward for completion. The function should be called from the <span class="FontName2">IncreaseLevel()</span> function just after the call to <span class="FontName2">dispaySprites()</span> within the <span class="FontName2">if</span> statement used to roll the game back to the first level when the player surpasses the game limits.</p>
<p class="noindent2"><b><i>Listing 11-4.</i></b>&#160;&#160;moveTone() Sound Functions for Stack It, Part 2 of 3 </p>
<pre><span class="FontName2">void WinTone() {</span><br />&#160;&#160;<span class="FontName2">for (int t =0 ; t &#x003C; 2 ; t ++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for(int i = 3 ; i &#x003C; 5 ; i++) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">GD.voice(0, 0, i*1000,&#160;&#160;&#160;&#160; 254,&#160;&#160;&#160;&#160;254);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (150);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for(int i = 5 ; i &#x003E; 1 ; i--) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">GD.voice(0, 0, i*1000,254,254);;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (150);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">GD.voice(0, 0, 0,0,0);</span><br />&#160;&#160;<span class="FontName2">} // end for loop that plays the tone twice</span><br /><span class="FontName2">} // end WinTone</span></pre>
<p class="indent">In part 3, the third sound function, <span class="FontName2">LossTone()</span>, creates a sound that plays four notes in descending frequency: 1250 HZ, 1000 Hz, 750 Hz, and 500 Hz. This tone is only played once&#x2014;when the player has missed the last sprite available. This function needs to be called from the <span class="FontName2">checkWin()</span> function inside the <span class="FontName2">if</span> statement that checking for a win before the play resets back to the first level.</p>
<p class="noindent2"><b><i>Listing 11-4.</i></b>&#160;&#160;moveTone() Sound Functions for Stack It, Part 3 of 3</p>
<pre><span class="FontName2">void LossTone() {</span><br />&#160;&#160;<span class="FontName2">for(int i = 5 ; i &#x003E; 1 ; i--) {</span><br />&#160;&#160;<span class="FontName2">GD.voice(0, 0, i*500,&#160;&#160;&#160;&#160; 254,&#160;&#160;&#160;&#160;254);</span><br />&#160;&#160;<span class="FontName2">delay (150);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">GD.voice(0, 0, 0,&#160;&#160;&#160;&#160;0,&#160;&#160;&#160;&#160;0);</span><br /><span class="FontName2">} // end loss tone</span><br />&#160; </pre>
</div>
<div>
<p id="Sec14" class="Heading2">Adding a Bit of Splash</p>
<p class="noindent">After the sound is added to the game a bit of more ambience can be achieved by creating a splash screen so the game can advertise itself when it is turned on and is not being played. Stack it will display anything placed in the <span class="FontName2">cubeMove</span> array when <span class="FontName2">displaySprites()</span> is called. Adding a pattern to the screen is the same as Stop It&#x2019;s method of showing status to the player. The two-dimensional nature of the Gameduino allows for the creation<a id="cXXX.231a" /> of text using the placement of sprites with a binary pattern loaded into the <span class="FontName2">cubeMove</span> array.</p>
<p class="indent">The <span class="FontName2">stackIt()</span> function in <a href="#list5" id="_list5">Listing 11-5</a> loads a second array with a binary pattern that represents the words <i>STACK IT</i>. The pattern is backward in the <span class="FontName2">logo</span> array because of how the <span class="FontName2">displaySprites()</span> function steps though the <span class="FontName2">cubeMove</span> array. The function copies and displays one row of the <span class="FontName2">logo</span> array to the <span class="FontName2">cubeMove</span> array every 300 &#x03BC;s; then the win tone is played before the game is prepared for play. The <span class="FontName2">StackIt()</span> function can be called in the <span class="FontName2">setup()</span> function, replacing the <span class="FontName2">resetPlay() function</span> call so that when the game starts, the logo will be displayed.</p>
<p class="noindent2"><a href="#_list5" id="list5"><b><i>Listing 11-5.</i></b></a>&#160;&#160;A Splash Function<a id="cXXX.503" /> for Stack It</p>
<pre><span class="FontName2">void StackIt() {</span><br /><span class="FontName2">GD.voice(0, 0, 0,0,0);</span><br />&#160;&#160;<span class="FontName2">long logo[18];</span><br />&#160;&#160;<span class="FontName2">logo[0]&#160;&#160;= 0x00000000;&#160;&#160;// hex is revese pattern&#160;&#160;1 = # 0 = .</span><br />&#160;&#160;<span class="FontName2">logo[1]&#160;&#160;= 0x00498df6;&#160;&#160;// .##.#####.##...##..#..#.</span><br />&#160;&#160;<span class="FontName2">logo[2]&#160;&#160;= 0x002a5249;&#160;&#160;// #..#..#..#..#.#..#.#.#..</span><br />&#160;&#160;<span class="FontName2">logo[3]&#160;&#160;= 0x00185241;&#160;&#160;// #.....#..#..#.#....##...</span><br />&#160;&#160;<span class="FontName2">logo[4]&#160;&#160;= 0x00185e46;&#160;&#160;// .##&#x2026;#..####.#....##...</span><br />&#160;&#160;<span class="FontName2">logo[5]&#160;&#160;= 0x00285248;&#160;&#160;// ...#..#..#..#.#....#.#..</span><br />&#160;&#160;<span class="FontName2">logo[6]&#160;&#160;= 0x004a5249;&#160;&#160;// #..#..#..#..#.#..#.#..#.</span><br />&#160;&#160;<span class="FontName2">logo[7]&#160;&#160;= 0x00899246;&#160;&#160;// .##...#..#..#..##..#...#</span><br />&#160;&#160;<span class="FontName2">logo[8]&#160;&#160;= 0x00000000;</span><br />&#160;&#160;<span class="FontName2">logo[9]&#160;&#160;= 0x0003e7c0;&#160;&#160;// ......#####..#####......</span><br />&#160;&#160;<span class="FontName2">logo[10] = 0x00008100;&#160;&#160;// ........#......#........</span><br />&#160;&#160;<span class="FontName2">logo[11] = 0x00008100;&#160;&#160;// ........#......#........</span><br />&#160;&#160;<span class="FontName2">logo[12] = 0x00008100;&#160;&#160;// ........#......#........</span><br />&#160;&#160;<span class="FontName2">logo[13] = 0x00008100;&#160;&#160;// ........#......#........</span><br />&#160;&#160;<span class="FontName2">logo[14] = 0x00008100;&#160;&#160;// ........#......#........</span><br />&#160;&#160;<span class="FontName2">logo[15] = 0x000087c0;&#160;&#160;// ......#####....#........</span><br />&#160;&#160;<span class="FontName2">logo[16] = 0x00000000;</span><br />&#160;&#160;<span class="FontName2">logo[17] = 0x00ffffff;&#160;&#160;// ########################</span><br />&#160;&#160;<span class="FontName2">for (int i = 17 ; i &#x003E;= 0 ; i --) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">cubeMove[i] = logo[i];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">displaySprites();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (300);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">WinTone();</span><br />&#160;&#160;<span class="FontName2">delay (500);</span><br />&#160;&#160;<span class="FontName2">resetPlay();</span><br /><span class="FontName2">} // end Stack it logo</span><br />&#160; </pre>
</div>
<div>
<p id="Sec15" class="Heading2">Programming the Game to Play Itself</p>
<p class="noindent">Most arcade games have a demo mode, which shows the game being played without a human player. Unlike console games, arcade machines are left on during business hours at an arcade. The demo mode entices a player to take part in the game and displays information on how to start playing. <a href="#list6" id="_list6">Listing 11-6</a> is split into three parts and demonstrates a method of adding self-play to Stack It. Most games just have a few set patterns that are played before displaying a splash screen; this can be accomplished by creating an array that holds the set patterns. This method would use a lot of program space, however; a procedural method of play, on the other hand, would use less program space and could provide a wider variation on the self-play patters. By utilizing functions used for a human player, Stack it could use random number generation to make decisions on game play. The random numbers could tell the <span class="FontName2">selfPlay()</span> function<a id="cXXX.504" /> to call for a check of <span class="FontName2">WinState()</span> to simulate an actual button press.</p>
<p class="indent"><a href="#list6">Listing 11-6</a>, part 1 is the main <span class="FontName2">selfPlay()</span> function, and is called from the loop just before the delay and after the interrupt function is attached. Every time <span class="FontName2">selfPlay()</span> is called, a check is performed to see if the loop has been executed for a sufficient amount of time without player interaction to initiate the self-play mode. The check is based on a count that increments every time <span class="FontName2">selfPlay()</span> is called and not activated; the count has been chosen to be a reasonable amount of time to consider the player inactive.</p>
<p class="noindent2"><a href="#_list6" id="list6"><b><i>Listing 11-6.</i></b></a>&#160;&#160;Self-Play for Stack It, Part 1 of 3</p>
<pre><span class="FontName2">void selfPlay() {</span><br />&#160;&#160;<span class="FontName2">if (selfPlayCount &#x003E;= 300) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">detachInterrupt(0);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">attachInterrupt(0, exitSelfPlay, LOW);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">GD.putstr(0, 0, &quot;PRESS BUTTON TO PLAY&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">moveToneflag = false;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (logoCount &#x003E;= 51 ){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">StackIt();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">logoCount = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">randomSeed(analogRead(0));</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (level == 0 &#x0026;&#x0026; random(10) == 5){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">selfPlayButton();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">else if ((cubeMove[16-level] == cubeMove[17-level])) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (random(2) == 1){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">RowShift();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (120 - ( level * 6));</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">displaySprites();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (random(2) == 1) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">selfPlayButton();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">} // end else if level check</span><br />&#160;&#160;<span class="FontName2">} // end if self play count check</span><br />&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">selfPlayCount++ ;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end self play</span></pre>
<p class="indent"><span class="FontName2">selfPlay()</span> checks to see if the current level is equal to the last level, and then randomly chooses to push the virtual button by comparing a randomly generated number to a chosen number and when the numbers match the virtual button is pressed.&#160;&#160;A perfect game will be played if the selfPlay() function can only press the virtual button when the current level is perfectly aligned with the last level even with randomly deciding when to press the virtual button.&#160;&#160;To add the feel of imperfection to the <span class="FontName2">selfplay() function the same method used as to determine when to press the virtual button</span>&#160;&#160;to randomly be off by one so that a perfect game is not guaranteed and <span class="FontName2">selfPlay()</span> can lose. When the game is playing, the first level will never equal the foundation level, and the virtual button call will never be activated. <span class="FontName2">selfplay()</span> has to has to trigger the virtual button at a random point to proceed from the first level. The random numbers are generated from seed that is created by reading the Arduino&#x2019;s analog pin 0 while it is not connected and is electrically floating. When a generated random number is checked against a set number, corresponding events will be triggered in the self-play mode. </p>
<p class="indent">The move sound is turned off when the game is in self-play mode so that the game does not get irritating to people when it is idle. <span class="FontName2">selfPlay()</span> displays the splash screen every 51 virtual button presses, or about every three to five <span class="FontName2">selfplay()</span> games. The <span class="FontName2">selfPlay()</span> function attaches a different interrupt function to the physical button so that the self-play can be exited and the game can return to a playable state when a player wants to play it. A few things need to be set up in the beginning of the sketch to enable self-play. Two variables need to be initialized so that the program will know when to play the splash screen and to keep track of whether a player is not at the game. One of the variables is incremented when the self-play is called and is initialized to a value of 300 so the self-play functionality starts when the game is turned on. The other variable is incremented when the self-play presses the virtual button. Both variables are reset when a player engages the game. Add the following two variables to the global declarations after the library includes:</p>
<pre><span class="FontName2">int logoCount = 0;</span><br /><span class="FontName2">int selfPlayCount = 300;</span></pre>
<p class="indent">A reset of the self-play count (<span class="FontName2">selfPlayCount = 0</span>) is added to the beginning of the <span class="FontName2">buttonInterrupt()</span> function so that the self-play will not be engaged while the player is in the middle of a game. Finally, a call is made to <span class="FontName2">GD.ascii() b</span>efore the call to <span class="FontName2">StackIt()</span> in the <span class="FontName2">setup()</span> function, allowing the game to use the standard Gameduino font. The font is used so that a string can be printed to the top-left corner of the display to inform a prospective player on how to start a new game. </p>
<p class="indent">Part 2 is the virtual button the self-play mode uses to advance the game. A tone is played that is similar when the physical button is pressed. The virtual button makes a call to <span class="FontName2">WinState()</span> to check if the self-play has matched the prior level. The self-play mode uses all the game play mechanisms and mimics an actual player. Self-play will not always win or play the same game every time. <span class="FontName2">logoCount</span> is incremented within this function to signal the splash screen to be displayed.</p>
<p class="noindent2"><b><i>Listing 11-6.</i></b>&#160;&#160;Self-Play for Stack It, Part 2 of 3</p>
<pre><span class="FontName2">void selfPlayButton() {</span><br />&#160;&#160;<span class="FontName2">GD.voice(0, 0, 5000, 254, 254);</span><br />&#160;&#160;<span class="FontName2">delay (50);</span><br />&#160;&#160;<span class="FontName2">WinState();</span><br />&#160;&#160;<span class="FontName2">logoCount++;</span><br />&#160;&#160;<span class="FontName2">GD.voice(0,0,0,0,0);</span><br /><span class="FontName2">} // end self play button</span></pre>
<p class="indent">The game will return to a normal play mode because the self-play changes the interrupt function. Part 3 is for handling the returning to normal play when a player presses the button while the self-play mode is activated. The string is removed for the top of the screen, play is reset, the move sound is turned back on, and the counts are set to the appropriate states. The logo count is set to 51 so that self-play will execute after the game goes idle.</p>
<p class="noindent2"><b><i>Listing 11-6.</i></b>&#160;&#160;Self-Play for Stack It, Part 3 of 3</p>
<pre><span class="FontName2">void exitSelfPlay(){</span><br />&#160;&#160;<span class="FontName2">GD.voice(0, 0, 5000,254 ,254);</span><br />&#160;&#160;<span class="FontName2">GD.putstr(0, 0, &quot;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;);</span><br />&#160;&#160;<span class="FontName2">while (digitalRead(2)== LOW){</span><br />&#160;&#160;<span class="FontName2">resetPlay();</span><br />&#160;&#160;<span class="FontName2">selfPlayCount = 0;</span><br />&#160;&#160;<span class="FontName2">logoCount = 51;</span><br />&#160;&#160;<span class="FontName2">moveToneflag = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">GD.voice(0, 0, 0,&#160;&#160; 0 ,&#160;&#160;&#160;&#160;0);</span><br /><span class="FontName2">} // end exit self play</span><br />&#160; </pre>
</div>
<div>
<p id="Sec16" class="Heading2">The Finishing Polish</p>
<p class="noindent">With <a href="#list4">Listings 11-4</a> through <a href="#list6">11-6</a> added to the initial Stack it code and working, the game has moved from a proof of concept to nearing completion. The sprites can be formalized, backgrounds can be created, and coin mechanisms and ticket dispensers can be integrated. The cabinet can be constructed and extras can be added to complete the game for an arcade. By working on small components and adding them to working components one at a time, a fairly complex game can be developed easily.</p>
<p class="indent">It is possible for games to quickly outgrow the Arduino Uno hardware by sheer number of pins or memory space. Using other hardware is always a viable solution, but it is always best to make an attempt to create something on less-equipped hardware. This helps developers create efficient code, which can always be ported to different systems. If the Arduino Uno is not capable, the next step for more pins and memory might be the Arduino Mega. If you&#x2019;ve outgrown the Gameduino, you can modify the processor and upload it to a bigger Field Programmable Gate Array FPGA. Some clones of the Gameduino have also added extra RAM, such as the MOD-VGA made by Olimex (<span class="FontName2"><a href="http://olimex.wordpress.com/">http://olimex.wordpress.com/</a></span>).</p>
<p class="indent">The Gameduino is an SPI device and can be connected to any master SPI-capable device. <a href="#Fig7" id="_Fig7">Figure 11-7</a> shows how to connect the Gameduino shield to an Arduino Mega<a id="cXXX.505" />. This set up opens other opportunities for creating interesting gaming platforms for example integrating hardware such as the ADK Mega and Android devices with the graphics capabilities of the Gameduino. Stack It can be uploaded to an Arduino Mega without any changes to the code by selecting the proper board and connecting the Gameduino as per <a href="#Fig7">Figure 11-7</a>.</p>
<div class="Figure" id="Fig7">
<p class="img"><img src="images/9781430239390_Fig11-07.jpg" alt="9781430239390_Fig12-07.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig7">Figure 11-7</a> </span>.&#160;&#160;Gameduino to Arduino Mega </p>
</div>
</div>
<div>
<p id="Sec17" class="Heading2">Arcade and Game Resources<a id="cXXX.506" /></p>
<p class="noindent">The following list provides some extra resources that might be helpful for further research into game construction and development. It includes examples of suppliers that handle arcade equipment and supplies. Some professional arcade game development<a id="cXXX.235a" /> companies are listed to provide an example of arcade games and the industry.</p>
<ul class="bulleted">
<li><span class="FontName1"><i><a href="http://www.artlum.com">www.artlum.com</a></i></span>: This site has a lot of Gameduino projects, including a tutorial on how to connect a classic NES controller to an Arduino.</li>
<li><span class="FontName1"><i><a href="http://www.brainwagon.org/the-arduino-n-gameduino-satellite-tracker">www.brainwagon.org/the-arduino-n-gameduino-satellite-tracker</a></i></span>: This is a wonderful nongame project that uses the Gameduino.</li>
<li><span class="FontName1"><i><a href="http://www.adafruit.com/products/787">www.adafruit.com/products/787</a></i></span> and <span class="FontName1"><i><a href="http://www.adafruit.com/products/786">www.adafruit.com/products/786</a></i></span>: Provided here are two different coin mechanisms available from Adafruit industries.</li>
<li><span class="FontName1"><i><a href="http://www.coinmech.com">www.coinmech.com</a></i></span> and <span class="FontName1"><i><a href="http://www.imonex.com">www.imonex.com</a></i></span>: These are two good sources for commercial-grade coin mechanisms.</li>
<li><span class="FontName1"><i><a href="http://www.deltroniclabs.com">www.deltroniclabs.com</a></i></span>: This company provides commercial-grade ticket dispersers.</li>
<li><span class="FontName1"><i><a href="http://www.nationalticket.com">www.nationalticket.com</a></i></span> and <span class="FontName1"><i><a href="http://www.tokensdirect.com">www.tokensdirect.com</a></i></span>: These supply tickets and tokens for arcade machines.</li>
<li><span class="FontName1"><i><a href="http://www.uniarcade.com">www.uniarcade.com</a></i></span>, <span class="FontName1"><i><a href="http://www.coinopexpress.com">www.coinopexpress.com</a></i></span>, and <span class="FontName1"><i><a href="http://www.happmart.com">www.happmart.com</a></i></span>: These companies offer various replacement arcade machine components, such as main boards and buttons.</li>
<li><span class="FontName1"><i><a href="http://www.xgaming.com">www.xgaming.com</a></i></span>: This site offers other hardware game development systems, such as the Hydra gaming system.</li>
<li><span class="FontName1"><i><a href="http://www.bmigaming.com">www.bmigaming.com</a></i></span>, <span class="FontName1"><i><a href="http://www.benchmarkgames.com">www.benchmarkgames.com</a></i></span>, <span class="FontName1"><i><a href="http://www.laigames.com">www.laigames.com</a></i></span>, <span class="FontName1"><i><a href="http://www.universal-space.com">www.universal-space.com</a></i></span>, and <span class="FontName1"><i><a href="http://www.baytekgames.com">www.baytekgames.com</a></i></span>: These are a few professional arcade game developers; these companies are a great cross section of the arcade games that are currently in use in a majority of arcades.</li>
<li><span class="FontName1"><i><a href="http://www.iaapa.org">www.iaapa.org</a></i></span>: The International Association of Amusement Parks and Attractions (IAAPA) hosts a few conventions that show off the technology for arcades and amusement parks, and is a great resource for arcade game developers.</li>
<li><span class="FontName1"><i><a href="http://www.paxsite.com">www.paxsite.com</a></i></span> and <span class="FontName1"><i><a href="http://www.gencon.com">www.gencon.com</a></i></span>: These are couple of large conventions that showcase games from many categories&#x2014;including board, card, and computer games&#x2014;from professional and independent developers alike. These conventions are not associated with the IAAPA.</li>
</ul>
</div>
<p id="Sec18" class="Heading1">Summary</p>
<p class="noindent">Developing games of any type is rewarding, fun, and challenging. Game development is a field that combines artistry, storytelling, and many other skills. Starting a game is as simple as having an idea and breaking it down into small components that combine together for a final product. Taking ideas and building them into proofs of concept will help build a game portfolio that can be used to develop more complex games. An increasing number of independent developers are making good games thanks to more outlets for distribution and ease of obtaining skills and knowledge. Arduino development makes a viable platform for developing games because of the unique experience it can provide for any game type.</p>
</div>
</body>
</html>