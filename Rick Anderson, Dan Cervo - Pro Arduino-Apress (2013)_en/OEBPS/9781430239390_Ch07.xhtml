<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 7 PID Controllers</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap7" />CHAPTER 7</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">PID Controllers</p>
<div>
<p class="noindent"><i>Proportional-Integral-Derivative (PID)</i><a id="cXXX.129a" /> is a cornerstone algorithm in control theory. The PID algorithm smoothly and precisely controls a system, such as temperature in an oven or the position of a control surface on an airplane. A PID controller works by calculating an amount of error based upon the difference between a set value and a feedback value, and provides an adjustment to the output to correct that error. The control and decision of the adjustment is done in math instead of pure logic control such as <span class="FontName2">if...else</span> statements. PID controllers have many types of uses, including controlling robotics, temperature, speed, and positioning. The basics, coding setup, and tuning of PID controllers for the Arduino platform are discussed in this chapter.</p>
<p id="Sec1" class="Heading1">The Mathematics</p>
<p class="noindent">Setting up a PID controller involves constantly calculating an algorithm. The following equation is the sum of the three parts of PID: <i>proportional</i>, <i>integral</i>, and <i>derivative</i>. The equation for the PID algorithm attempts to lower the amount of difference between a setpoint (the value desired) and a measured value, also known as the <i>feedback</i>. The output is altered so that the setpoint is maintained. PID controllers can easily work with systems that have control over a variable output.</p>
<p class="indent">The variables of<a id="cXXX.275" /> the equation are</p>
<ul class="bulleted">
<li><span class="FontName2">E</span>: The calculated error determined by subtracting the input from the setpoint (<span class="FontName2">Sp &#x2013; Input</span>)</li>
<li><span class="FontName2">t</span>: The change in time from the last time the equation has run</li>
<li><span class="FontName2">Kp</span>: The gain for the proportional component</li>
<li><span class="FontName2">Ki</span>: The gain for the integral component</li>
<li><span class="FontName2">Kd</span>: The gain for the derivative component</li>
</ul>
<div>
<p id="Sec2" class="Heading2">The Proportional Statement<a id="cXXX.276" /></p>
<p class="noindent">The <i>P</i> in <i>PID</i> is a proportional statement of the error, or the difference between the input and the setpoint value. <span class="FontName2">Kp</span> is the gain value and determines how the P statement reacts to change in error; the lower the gain, the less the system reacts to an error. <span class="FontName2">Kp</span> is what tunes the proportional part of the equation. All gain values are set by the programmer or dynamically via a user input. The proportional statement aids in the steady-state error control by always trying to keep the error minimal. The <i>steady state</i> describes when a system has reached the desired setpoint. The first part of the proportional code will calculate the amount of error and will appear something like this:</p>
<pre><span class="FontName2">error = setpoint &#x2013; input ;</span></pre>
<p class="indent">The second part of the code multiplies the error by the gain variable:</p>
<pre><span class="FontName2">Pout = Kp * error;</span></pre>
<p class="indent">The proportional statement attempts to lower the error by calculating the error to zero where <span class="FontName2">input = setpoint</span>. A pure proportional controller, with this equation and code, will not settle at the setpoint, but usually somewhere below the setpoint. The reason the proportional statement settles below the setpoint is because the proportional control always tries to reach a value of zero, and the settling is a balance between the input and the feedback. The integral statement<a id="cXXX.130a" /> is responsible for achieving the desired setpoint.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;If <span class="FontName2">Kp</span> is set too high, the system will become unstable. The gain value when this happens is different for each system.&#160;&#160;<a id="cXXX.277" /></p>
</div>
</div>
<div>
<p id="Sec3" class="Heading2">The Integral Statement<a id="cXXX.278" /></p>
<p class="noindent">The <i>I</i> in <i>PID</i> is for an integral; this is a major concept in calculus, but integrals are not scary. Put simply, <i>integration</i> is the calculation of the area under a curve. This is accomplished by constantly adding a very small area to an accumulated total. For a refresher of some calculus, the area is calculated by length &#x00D7; width; to find the area under a curve, the length is determined by the function&#x2019;s value and a small difference that then is added to all other function values. For reference, the integral in this type of setup is similar to a Riemann sum.</p>
<p class="indent">The PID algorithm does not have a specific function; the length is determined by the error, and the width of the rectangle is the change in time. The program constantly adds this area up based on the error. The code for the integral is</p>
<pre><span class="FontName2">errorsum = (errorsum + currenterror) * timechange;</span><br /><span class="FontName2">Iout = Ki * errorsum ;</span></pre>
<p class="indent">The integral reacts to the amount of error and duration of the error. The <span class="FontName2">errorsum</span> value increases when the input value is below the setpoint, and decreases when the input is above the setpoint. The integral will hold at the setpoint when the error becomes zero and there is nothing to subtract or add. When the integral is added to proportional statement, the integral corrects for the offset to the error caused by the proportional statement&#x2019;s settling. The integral will control how fast the algorithm attempts to reach the setpoint: lower gain values approach at a slower rate; higher values approach the setpoint quicker, but have the tendency to overshoot and can cause ringing by constantly overshooting above and below the setpoint and never settling. Some systems, like ovens, have problems returning from overshoots, where the controller does not have the ability to apply a negative power. It&#x2019;s perfectly fine to use just the <i>PI</i> part of a PID equation for control, and sometimes a PI controller is satisfactory.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;The integral will constantly get larger or smaller depending on how long there is an error, and in some cases this can lead to windup. <i>Windup</i> occurs when the integral goes outside the feasible output range and induces a lag. This can be corrected by checking if <span class="FontName2">Iout</span> goes outside the output range. To correct for this, check <span class="FontName2">Iout</span> and reset it to the bound it exceeded.&#160;&#160;<a id="cXXX.279" /></p>
</div>
</div>
<div>
<p id="Sec4" class="Heading2">The Derivative Statement<a id="cXXX.131a" /><a id="cXXX.280" /></p>
<p class="noindent">The <i>D</i> in <i>PID</i> is the derivative, another calculus concept, which is just a snapshot of the slope of an equation. The slope is calculated as <i>rise over run</i>&#x2014;the <i>rise</i> comes from the change in the error, or the current error subtracted from the last error; the <i>run</i> is the change in time. When the rise is divided by the time change, the rate at which the input is changing is known. Code for the derivative component is</p>
<pre><span class="FontName2">Derror = (Error &#x2013; lasterror) / timechange ;</span><br /><span class="FontName2">Dout = Kd * Derror ;</span></pre>
<p class="indent">or</p>
<pre><span class="FontName2">Derror = (Input &#x2013; lastinput) / timechange ;</span><br /><span class="FontName2">Dout = Kd * Derror ;</span></pre>
<p class="indent">The derivative aids in the control of overshooting and controls the ringing that can occur from the integral. High gain values in the derivative can have a tendency to cause an unstable system that will never reach a stable state. The two versions of code both work, and mostly serve the same function. The code that uses the slope of the input reduces the derivative kick caused when the setpoint is changed; this is good for systems in which the setpoint changes regularly. By using the input instead of the calculated error, we get a better calculation on how the system is changing; the code that is based on the error will have a greater perceived change, and thus a higher slope will be added to the final output of the PID controller. <a id="cXXX.281" /></p>
</div>
<div>
<p id="Sec5" class="Heading2">Adding It All Up</p>
<p class="noindent">With the individual parts calculated, the proportion, integral, and the derivative have to be added together to achieve a usable output. One line of code is used to produce the output:</p>
<pre><span class="FontName2">Output = Pout + Iout + Dout ;</span></pre>
<p class="indent">The output<a id="cXXX.282" /> might need to be normalized for the input when the output equates to power. Some systems need the output to be zero when the setpoint is achieved (e.g., ovens) so that no more heat will be added; and for motor controls, the output might have to go negative to reverse the motor.</p>
</div>
<div>
<p id="Sec6" class="Heading2">Time<a id="cXXX.283" /></p>
<p class="noindent">PID controllers use the change in time to work out the order that data is entered and relates to when the PID is calculated and how much time has passed since the last time the program calculated the PID. The individual system&#x2019;s implementation determines the required time necessary for calculation. Fast systems like radio-controlled aircraft may require time in milliseconds, ovens or refrigerators may have their time differences calculated in seconds, and chemical and HVAC systems may require minutes. This is all based on the system&#x2019;s ability to change; just as in physics, larger objects will move slower to a given force than a smaller ones at the same force.</p>
<p class="indent">There are two ways to set up time calculation. The first takes the current time and subtracts that from the last time and uses the resulting change in the PID calculation. The other waits for a set amount of time to pass before calculating the next iteration. The code to calculate based on time is as follows and would be in a loop:</p>
<pre><span class="FontName2">// loop</span><br /><span class="FontName2">now = millis() ;</span><br /><span class="FontName2">timechage = (now &#x2013; lasttime);</span><br /><span class="FontName2">// pid caculations</span><br /><span class="FontName2">lasttime = now;</span></pre>
<p class="indent">This method is good for fast systems like servo controllers where the change in time is based on how fast the code runs through a loop. Sometimes it is necessary to sample at a greater time interval than that at which the code runs or have more consistency between the time the PID calculates. For these instances, the time change can be assumed to be 1 and can be dropped out of the calculation for the I and D components, saving the continual multiplication and division from the code. To speed up the PID calculation, the change in time can be calculated against the gains instead of being calculated within the PID. The transformation of the calculation is <span class="FontName2">Ki * settime</span> and <span class="FontName2">Kd / settime</span>. The code then looks like this, with gains of .5 picked as a general untuned starting point:</p>
<pre><span class="FontName2">// setup</span><br /><span class="FontName2">settime = 1000 ; // 1000 milliseconds is 1 second</span><br /><span class="FontName2">Kp = .5;</span><br /><span class="FontName2">Ki = .5 * settime;</span><br /><span class="FontName2">Kd = .5 / settime;</span><br /><span class="FontName2">// loop</span><br /><span class="FontName2">now = millis() ;</span><br /><span class="FontName2">timechage = (now &#x2013; lasttime);</span><br /><span class="FontName2">if (timechange &#x003E;= time change){</span><br />&#160;&#160; <span class="FontName2">error = Setpoint &#x2013; Input;</span><br />&#160;&#160; <span class="FontName2">errorsum = errorsum + error;</span><br />&#160;&#160; <span class="FontName2">Derror = (Input &#x2013; lastinput);</span><br />&#160;&#160; <span class="FontName2">Pout = Kp * error;</span><br />&#160;&#160; <span class="FontName2">Iout = Ki * errorsum ;</span><br />&#160;&#160; <span class="FontName2">Dout = Kd * Derror ;</span><br />&#160;&#160; <span class="FontName2">Output = Pout + Iout + Dout ;</span><br /><span class="FontName2">}</span></pre>
</div>
<p id="Sec7" class="Heading1">PID Controller Setup</p>
<p class="noindent">Now that the math and the framework are out of the way, it is time to set up a basic PID system on an Arduino. This example uses an RC low-pass filter (from <a href="9781430239390_Ch06.xhtml">Chapter 6</a>) with an added potentiometer to simulate external disturbance.</p>
<div>
<p id="Sec8" class="Heading2">Wiring the Hardware<a id="cXXX.284" /></p>
<p class="noindent">Set up an Arduino as per <a href="#Fig1" id="_Fig1">Figure 7-1</a>. After the Arduino is set up with the components, upload the code in <a href="#list1" id="_list1">Listing 7-1</a>.</p>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig07-01.jpg" alt="9781430239390_Fig07-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 7-1</a> </span>.&#160;&#160;PID example circuit setup </p>
</div>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 7-1.</i></b></a>&#160;&#160;Basic PID Arduino Sketch</p>
<pre><span class="FontName2">float Kp = .5 , Ki = .5, Kd = .5 ; // PID gain values</span><br /><span class="FontName2">float Pout , Iout , Dout , Output; // PID final ouput variables</span><br /><span class="FontName2">float now , lasttime = 0 , timechange; // important time</span><br /><span class="FontName2">float Input , lastinput , Setpoint = 127.0; // input-based variables</span><br /><span class="FontName2">float error , errorsum = 0, Derror; // output of the PID components</span><br /><span class="FontName2">int settime = 1000; // this = 1 second, so Ki and Kd do not need modification</span><br /><span class="FontName2">void setup (){</span><br />&#160;&#160; <span class="FontName2">Serial.begin(9600); // serial setup for verification</span><br /><span class="FontName2">} // end void setup (){</span><br /><br /><span class="FontName2">void loop (){</span><br />&#160;&#160; <span class="FontName2">now = millis() ; // get current milliseconds</span><br />&#160;&#160; <span class="FontName2">timechange = (now &#x2013; lasttime); // calculate difference</span><br />&#160;&#160; <span class="FontName2">if (timechange &#x003E;= settime) { // run PID when the time is at the set time</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Input = (analogRead(0)/4.0); // read Input and normalize to output range</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">error = Setpoint &#x2013; Input; // calculate error</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">errorsum = errorsum + error; // add curent error to running total of error</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Derror = (Input &#x2013; lastinput); // calculate slope of the input</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Pout = Kp * error;&#160;&#160;// calculate PID gains</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Iout = Ki * errorsum ;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Dout = Kd * Derror ;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (Iout &#x003E; 255)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// check for integral windup and correct</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Iout = 255;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (Iout &#x003C; 0)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Iout = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Output = Pout + Iout + Dout ; // prep the output variable</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (Output &#x003E; 255)&#160;&#160;// sanity check of the output, keeping it within the</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Output = 255; // available output range</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (Output &#x003C; 0)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Output = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">lastinput = Input; // save the input and time for the next loop</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">lasttime = now;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">analogWrite (3, Output); // write the output to PWM pin 3</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (Setpoint); // print some information to the serial monitor</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot; : &quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (Input);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot; : &quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (Output);</span><br />&#160;&#160; <span class="FontName2">} // end if (timechange &#x003E;= settime)</span><br /><span class="FontName2">}&#160;&#160;// end void loop ()</span></pre>
</div>
<div>
<p id="Sec9" class="Heading2">Verifying the Code<a id="cXXX.285" /></p>
<p class="noindent">Run the code uploaded to the Arduino and start the serial monitor. The code will print one line containing the <span class="FontName2">Setpoint : Input : Output</span> values, and print one line per iteration of the running PID about every second. The system will stabilize around a value of the setpoint&#x2014;the first value of every printed line in the serial monitor. However, because of the inherent noise in the RC filter, it will never settle directly at the setpoint. Using an RC circuit is one of the easier ways to demonstrate a PID controller in action, along with the noise simulating a possible jitter in the system. The potentiometer is used to simulate a negative external disturbance; if the resistance on potentiometer is increased, the controller will increase the output to keep the input at the setpoint.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;If the Arduino were fast enough and had a higher precision on the PWM, it would be possible to eliminate the jitter in the RC filter with a PID controller.</p></div>
</div>
<p id="Sec10" class="Heading1">PID Tuner<a id="cXXX.286" /></p>
<p class="noindent">To graphically represent the different controllers in real time and on actual hardware, there is an app called PID tuner available at the books github repository (<span class="FontName2"><a href="https://github.com/ProArd/Pidtuner">https://github.com/ProArd/Pidtuner</a></span>). PID Tuner implements the P, I, and D types of controllers with the openFrameworks-and-Firmata combination (as in <a href="9781430239390_Ch03.xhtml">Chapter 3</a>). <a href="#Fig2" id="_Fig2">Figures 7-2</a> through <a href="#Fig4" id="_Fig4">7-4</a> were made from the PID Tuner app (see the next section, in which we&#x2019;ll start to examine different types of controllers in more detail). The PID Tuner application was developed to provide a functional graphical front end to the Arduino hardware and implement a few control algorithms for testing and tuning<a id="cXXX.134c" /> purposes. With PID Tuner, it is possible to test many different gain values without having to upload a new sketch to the Arduino each time.</p>
<p class="indent">After downloading the file, do the following:</p>
<ol class="OrderedList">
<li>Unzip it to the openFrameworks apps /myapps folder.</li>
<li>Change the serial port connection to connect to an Arduino configured as shown in <a href="#Fig1">Figure 7-1</a> and loaded with the standard Firmata sketch.</li>
<li>Open the <span class="FontName2">PID</span> folder and compile the project.</li>
</ol>
<p class="indent">Once the PID Tuner is compiled and running, and the Arduino is set up as per <a href="#Fig1">Figure 7-1</a>, the program controls the PWM pin for the PID controller and simulates a linear rise and fall time for both an ON/OFF and a DEAD BAND controller;<a id="cXXX.135c" /> the application uses single key commands to set tuning.</p>
<ul class="bulleted">
<li>Keys <span class="FontName2">o</span>, <span class="FontName2">y</span>, and <span class="FontName2">h</span> turn on or off a single controller type:</li></ul>
<ul class="bulletedin">
<li><span class="FontName2">o</span> = PID</li>
<li><span class="FontName2">y</span> = ON/OFF</li>
</ul>
<ul class="bulleted">
<li>Keys <span class="FontName2">c</span>, <span class="FontName2">r</span>, and <span class="FontName2">z</span> clear, reset, and zero the graph:</li>
</ul>
<ul class="bulletedin">
<li><span class="FontName2">c</span> = clear</li>
<li><span class="FontName2">r</span>= reset</li>
<li><span class="FontName2">z</span> = zero</li>
</ul>
<ul class="bulleted">
<li>Keys <span class="FontName2">S</span> and <span class="FontName2">s</span> increase and decrease the first setpoint, and <span class="FontName2">A</span> and <span class="FontName2">a</span> increase and decrease the second setpoint that is used for the DEAD BAND controller.</li>
<li>Keys <span class="FontName2">M</span> and <span class="FontName2">m</span> increase and decrease the PWM output on the Arduino.</li>
<li>Keys <span class="FontName2">p</span>, <span class="FontName2">i</span>, and <span class="FontName2">d</span> turn on and off the individual statements of the PID controller.</li>
<li>Keys <span class="FontName2">Q</span>, <span class="FontName2">W</span>, and <span class="FontName2">E</span> increase the individual gain values for the PID controller in .01 increments. <span class="FontName2">q</span>, <span class="FontName2">w</span>, and <span class="FontName2">e</span> decreases the gains:</li>
</ul>
<ul class="bulletedin">
<li><span class="FontName2">Q</span> = <span class="FontName2">Kp</span> + .01</li>
<li><span class="FontName2">q</span> = <span class="FontName2">Kp</span> &#x2013; .01</li>
<li><span class="FontName2">W</span> = <span class="FontName2">Ki</span> + .01</li>
<li><span class="FontName2">w</span> = <span class="FontName2">Ki</span> &#x2013; .01</li>
<li><span class="FontName2">E</span> = <span class="FontName2">Kd</span> + .01</li>
<li><span class="FontName2">e</span> = <span class="FontName2">Kd</span> &#x2013; .01</li>
</ul>
<ul class="bulleted">
<li>The spacebar starts and stops the reading of controllers and pauses the graph&#x2019;s output.</li>
</ul>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;As of the writing of this book, the PID Tuner app is in preliminary development; it may be a bit buggy, and it requires the connection to be manually changed in the code. The application also runs at the fastest running speed and assumes a nonadjustable time of 1.</p></div>
<p id="Sec11" class="Heading1">Comparing PID, DEAD BAND, and ON/OFF Controllers</p>
<p class="noindent">With a basic PID controller set up and running, it is time to discuss a couple of other common control methods and how they compare to PID. Both DEAD BAND and ON/OFF controllers are from the logic controller family, meaning they use logic controls such as <span class="FontName2">if</span>/<span class="FontName2">else</span> statements to determine how to change the output.</p>
<p class="indent">The DEAD BAND controller<a id="cXXX.287" /> is common for thermostats, where a high and a low value are set. If the input is below the low value, the controller turns on the output, and vice versa for the high value, creating a range that output must be kept within.</p>
<p class="indent">The ON/OFF controller<a id="cXXX.288" /><a id="cXXX.136a" /> is much like the DEAD BAND controller, but uses only a single setpoint. When the input is below the value, the output<a id="cXXX.136b" /> is turned on, and then it is turned off when above the setpoint.</p>
<p class="indent"><a href="#Fig2">Figure 7-2</a> is the graph of a PID using the RC filter; the gains are equal to .5 for this particular tuning and setup. There is a slight overshoot produced, but the system quickly reaches a steady state, with an approximate steady-state error of +/&#x2013;4. This is normal for the noise produced in the system. <a id="cXXX.289" /></p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig07-02.jpg" alt="9781430239390_Fig07-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 7-2</a> </span>.&#160;&#160;A graph of a PID setup<a id="cXXX.136d" /> with an RC low-pass filter<a id="cXXX.136c" /> </p>
</div>
<p class="indent"><a href="#Fig3" id="_Fig3">Figure 7-3</a> demonstrates an ON/OFF controller<a id="cXXX.291" /> that has a higher rise and a slower fall per program step; this simulates how an thermostat might work. This controller is set up with the same components as <a href="#Fig2">Figure 7-2</a>, just using different code. One of the biggest comparisons between the ON/OFF and the PID is the steady state contains much more disturbance and there is no direct control on how long the system will stay at the setpoint.</p>
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig07-03.jpg" alt="9781430239390_Fig07-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 7-3</a> </span>.&#160;&#160;An ON/OFF controller </p>
</div>
<p class="indent"><a href="#Fig4">Figure 7-4</a> shows a DEAD BAND controller using the same setup as the preceding graphs. The DEAD BAND is formed by a high setpoint and a low setpoint. The advantage this provides over a basic ON/OFF is that the cycle frequency is decreased to lower the amount of switching of the state either on or off. This is the average controller style for HVAC systems, where turning on and off can lead to higher power consumption and increased mechanical fatigue.</p>
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig07-04.jpg" alt="9781430239390_Fig07-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 7-4</a> </span>.&#160;&#160;A DEAD BAND controller </p>
</div>
<p class="indent">The main disadvantages of the both of these logic controllers is in the control of the output being discrete. With the output control being just on or off, there is no prediction on the change of the output that will allow us to determine how far they are from the setpoints. However, logic controllers are usually easier to set up and implement than PID controllers, which is why it is more common to see these controllers in commercial products. PID controllers, though, have a distinct advantage over logic controllers: if they are implemented properly, PID controllers won&#x2019;t add more noise to a system and will have tighter control at a steady state. But after the math, it is the implementations that make PID controllers a bit more difficult to work with.</p>
<p id="Sec12" class="Heading1">PID Can Control</p>
<p class="noindent">There are many ways to implement a PID with a proper match to a sensor and an output method. The math will remain reliability constant. There may be a need for some added logic control to achieve a desired system, however. This next section provides a glimpse of other PID implementations and some possible ideas.</p>
<p class="indent">It is common for PID controllers to be used in positioning for flight controls, balancing robots, and some CNC systems. A common setup is to have a motor for the output and a potentiometer for the input, connected through a series of gears, much the same way a servo is set up. Another common implementation is to use a light-break sensor and a slotted disk as the input, as would be found in a printer. This implementation requires some extra logic to count, store, and manipulate steps of the input. The logic would be added to control the motor&#x2019;s forward or reverse motion when counts are changed. It is also possible to use rotary encoders or flex sensors for the input. Many types of physical-manipulation system can be created from electric-type motors and linear actuators&#x2014;for example, air and hydraulic systems.</p>
<p class="indent">Systems that control speed need sensors that calculate speed to power output, such as in automotive cruise control<a id="cXXX.294" />, where the speed is controlled by the throttle position. In an automotive application, a logic controller would be impractical for smoothly controlling the throttle.</p>
<p class="indent">Controlling temperature systems<a id="cXXX.295" /> may require other logic to control heating and cooling elements, with discrete output such as relays. PID controllers are fairly simple to plan when the output is variable, but in systems that provide only on-or-off output, this planning can be more complicated. This is accomplished in much the same way as PWM charges a compositor to produce a voltage output that an ADC can read. The PID controller needs a bit of logic to control the time at which the element is turned on. With temperature-based PID controllers, the gains may have to be negative to achieve a controller that cools to a setpoint.</p>
<p class="indent">With a proper type of sensor and a way to control output, a PID can be implemented for chemical systems, such as controlling the pH value<a id="cXXX.296" /> of a pool or hot tub. When dealing with systems that work with chemicals, it is important that the reaction time is taken into account for how and when the reagents are added.</p>
<p class="indent">Other PID systems can control flow rates for fluids, such as using electric valves and moisture meters to control watering a garden or lawn. If there is a sensor that can measure and quantify, and a way to control, a PID can be implemented.</p>
<div>
<p id="Sec13" class="Heading2">Tuning</p>
<p class="noindent">The tuning of a PID can be where most of the setup time is spent; entire semesters can be spent in classes on how to tune and set up PID controllers. There are many methods and mathematical models for achieving a tune that will work. In short, there is no absolute correct tuning, and what works for one implementation may not work for another. How a particular setup works and reacts to changes will differ from one system to another, and the desired reactions of the controller changes how everything is tuned. Once the output is controllable with the loopback and the algorithm, there are three parameters that tune the controller: the gains of <span class="FontName2">Kp</span>, <span class="FontName2">Ki</span>, and <span class="FontName2">Kd</span>. <a href="#Fig5" id="_Fig5">Figures 7-5</a> through <a href="#Fig7" id="_Fig7">7-7</a> show the differences between low gain and high gain using the same setup from earlier in the chapter.</p>
<p class="indent">The proportional control gains control how aggressively the system reacts to error and the distance from the setpoint at which the proportional component will settle. On the left of <a href="#Fig5">Figure 7-5</a>, using a gain of 1, the system stabilizes at about 50 percent of the setpoint value. At a gain of 7 (the right side of <a href="#Fig5">Figure 7-5</a>), the system becomes unstable. To tune a decent gain for a fast-reacting system, start with the proportion, set the integral and the derivative to zero, and increase the <span class="FontName2">Kp</span> value until the system becomes unstable; then back off a bit until it becomes stable again. This particular system becomes stable around a <span class="FontName2">Kp</span> value of 2.27. For a slower system or one that needs a slower reaction to error, a lower gain will be required. After the proportional component is set, move on to the integral.</p>
<div class="Figure" id="Fig5">
<p class="img"><img src="images/9781430239390_Fig07-05.jpg" alt="9781430239390_Fig07-05.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig5">Figure 7-5</a> </span>.&#160;&#160;Proportional control: Kp = 1 (left) and Kp = 7 (right) </p>
</div>
<p class="indent"><a href="#Fig6" id="_Fig6">Figure 7-6</a> demonstrates the addition of the integral component<a id="cXXX.297" />, making a PI controller. The left side of the figure shows that a lower <span class="FontName2">Ki</span> gain produces a slower controller that approaches the setpoint without overshoot. The right side of the figure, with a gain of 2, shows a graph with a faster rise, followed by overshoot and a ringing before settling at the setpoint. Setting a proper gain for this part is dependent on the needs of the system and the ability to react to overshoot. A temperature system may need a lower gain than a system that controls positing; it is about finding a good balance.</p>
<div class="Figure" id="Fig6">
<p class="img"><img src="images/9781430239390_Fig07-06.jpg" alt="9781430239390_Fig07-06.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig6">Figure 7-6</a> </span>.&#160;&#160;Proportional integral control: Kp = .5; Ki = .1 (left) and Ki = 2 (right) </p>
</div>
<p class="indent">The derivative value is a bit more difficult to tune because of the interaction of the other two components. The derivative is similar to a damper attempting to limit the overshoot. It is perfectly fine omit the derivate portion and simply use a PI controller. To tune the derivative, the balance of the PI portions should be as close as possible to the reaction required for the setup. Once you&#x2019;ve achieved this, then you can slowly change the gain in the derivative to provide some extra dampening. <a href="#Fig7">Figure 7-7</a> demonstrates a fully functional PID with the PID Tuner program. In this graph, there is a small amount of overshoot, but the derivate function corrects and allows the setpoint to be reached quickly.</p>
<div class="Figure" id="Fig7">
<p class="img"><img src="images/9781430239390_Fig07-07.jpg" alt="9781430239390_Fig07-07.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig7">Figure 7-7</a> </span>.&#160;&#160;A full PID controller using an Arduino and an RC low-pass filter<a id="cXXX.140b" />, with the following gains: Kp = 1.5, Ki =.8, and Kd = .25 </p>
</div>
</div>
<div>
<p id="Sec14" class="Heading2">PID Library<a id="cXXX.299" /></p>
<p class="noindent">There is a user-made library available from Arduino Playground that implements all the math and control for setting up a PID controller on an Arduino (see <span class="FontName2"><a href="http://www.arduino.cc/playground/Code/PIDLibrary/">www.arduino.cc/playground/Code/PIDLibrary/</a></span>). The library makes it simple to have multiple PID controllers running on a single Arduino.</p>
<p class="indent">After downloading the library, set it up by unzipping the file into the Arduino <span class="FontName2">libraries</span><a id="cXXX.140a" /> folder. To use a PID controller in Arduino code, add <span class="FontName2">#include &#x003C;PID_v1.h&#x003E;</span> before declaring variables <span class="FontName2">Setpoint</span>, <span class="FontName2">Input</span>, and <span class="FontName2">Output</span>. After the library and variables are set up, you need to create a <span class="FontName2">PID</span> object, which is accomplished by the following line of code:</p>
<pre><span class="FontName2">PID myPID(&#x0026;Input, &#x0026;Output, &#x0026;Setpoint, Kp, Ki, Kd, DIRECT);</span></pre>
<p class="indent">This informs the new <span class="FontName2">PID</span> object about the variables used for <span class="FontName2">Setpoint</span>, <span class="FontName2">Input</span>, and <span class="FontName2">Output</span>, as well as the gains <span class="FontName2">Kp</span>, <span class="FontName2">Ki</span>, and <span class="FontName2">Kd</span>. The final parameter is the direction: use <span class="FontName2">DIRECT</span> unless the system needs to drop to a setpoint.</p>
<p class="indent">After all of this is coded, read the input before calling the <span class="FontName2">myPID.Compute()</span> function.</p>
</div>
<div>
<p id="Sec15" class="Heading2">PID Library Functions</p>
<p class="noindent">Following is a list of the important basic functions for the PID library:</p>
<ul class="bulleted">
<li><span class="FontName2">PID(&#x0026;Input, &#x0026;Output, &#x0026;Setpoint, Kp, Ki, Kd, Direction)</span>: This is the constructer function, which takes the address of the <span class="FontName2">Input</span>, <span class="FontName2">Output</span>, and <span class="FontName2">Setpoint</span> variables, and the gain values.</li>
<li><span class="FontName2">Compute()</span>: Calling <span class="FontName2">Compute()</span> after the input is read will perform the math required to produce an output value.</li>
<li><span class="FontName2">SetOutputLimits(min ,max)</span>: This sets the values that the output should not exceed.</li>
<li><span class="FontName2">SetTunings(Kp,Ki,Kd)</span>: This is used to change the gains dynamically after the PID has been initialized.</li>
<li><span class="FontName2">SetSampleTime(milliseconds)</span>: This sets the amount of time that must pass before the <span class="FontName2">Compute()</span> function will execute the PID calculation again. If the set time has not passed when <span class="FontName2">Compute()</span> is called, the function returns back to the calling code without calculating the PID.</li>
<li><span class="FontName2">SetControllerDirection(direction)</span>: This sets the controller direction. Use <span class="FontName2">DIRECT</span> for positive movements, such as in motor control or ovens; use <span class="FontName2">REVERSE</span> for systems like refrigerators.</li>
</ul>
<p class="indent"><a href="#list2" id="_list2">Listing 7-2</a> is a modified version of the basic PID example using the PID library given at the library&#x2019;s Arduino Playground web page (<span class="FontName2"><a href="http://www.arduino.cc/playground/Code/PIDLibrary/">www.arduino.cc/playground/Code/PIDLibrary/</a></span>). The modifications to the sketch include a serial output to display what is going on. There is a loss in performance when using the library compared to the direct implementation of <a href="#list1">Listing 7-1</a>, and the gains had to be turned down in comparison while using the same hardware configuration as in <a href="#Fig1">Figure 7-1</a>. The library can easily handle slower-reacting systems; to simulate this. a lager capacitor can be used in the RC circuit.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 7-2.</i></b></a>&#160;&#160;PID Impemented with the PID Library</p>
<pre><span class="FontName2">#include &#x003C;PID_v1.h&#x003E;</span><br /><br /><span class="FontName2">double Setpoint, Input, Output;</span><br /><span class="FontName2">float Kp = .09;</span><br /><span class="FontName2">float Ki = .1;</span><br /><span class="FontName2">float Kd = .07;</span><br /><br /><span class="FontName2">// set up the PID&#x0027;s gains and link to variables</span><br /><span class="FontName2">PID myPID(&#x0026;Input, &#x0026;Output, &#x0026;Setpoint,Kp,Ki,Kd, DIRECT);</span><br /><br /><span class="FontName2">void setup(){</span><br /><br />&#160;&#160;<span class="FontName2">Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">// variable setup</span><br />&#160;&#160;<span class="FontName2">Input = analogRead(0) / 4; // calculate input to match output values</span><br />&#160;&#160;<span class="FontName2">Setpoint = 100&#160;&#160;;</span><br />&#160;&#160;<span class="FontName2">// turn the PID on</span><br />&#160;&#160;<span class="FontName2">myPID.SetMode(AUTOMATIC);</span><br />&#160;&#160;<span class="FontName2">// myPID.SetSampleTime(100);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop(){</span><br /><br />&#160;&#160;<span class="FontName2">// read input and calculate PID</span><br />&#160;&#160;<span class="FontName2">Input = analogRead(0) / 4;</span><br />&#160;&#160;<span class="FontName2">myPID.Compute();</span><br />&#160;&#160;<span class="FontName2">analogWrite(3,Output);</span><br />&#160;&#160; <br />&#160;<span class="FontName2">// print value to serial monitor</span><br />&#160;&#160;<span class="FontName2">Serial.print(Setpoint);</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot; : &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.print(Output);</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot; : &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.println(Input);</span><br /><span class="FontName2">}</span></pre>
</div>
<p id="Sec16" class="Heading1">Other Resources</p>
<p class="noindent">For reference, here is a list of some online resources<a id="cXXX.142a" /><a id="cXXX.300" /> that will help expand your knowledge of the topics covered in this chapter:</p>
<ul class="bulleted">
<li><span class="FontName2"><a href="http://wikipedia.org/wiki/PID_controller">http://wikipedia.org/wiki/PID_controller</a></span></li>
<li><span class="FontName2"><a href="http://www.siam.org/books/dc14/DC14Sample.pdf">www.siam.org/books/dc14/DC14Sample.pdf</a></span></li>
<li><span class="FontName2"><a href="http://www.arduino.cc/playground/Code/PIDLibrary/">www.arduino.cc/playground/Code/PIDLibrary/</a></span></li>
<li><span class="FontName2"><a href="http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/">http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/</a></span></li>
<li><span class="FontName2"><a href="http://sourceforge.net/projects/pidtuner/">http://sourceforge.net/projects/pidtuner/</a></span></li>
</ul>
<p id="Sec17" class="Heading1">Summary</p>
<p class="noindent">This chapter provided the basic information for setting up a PID controller on an Arduino and listed some possible applications. There are a lot of different setups that a PID can fulfill, and some can be difficult to achieve. However, with some experimentation and exploration, you can learn to use PID controllers to your advantage.</p>
</div>
</body>
</html>