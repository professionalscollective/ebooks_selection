<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 4 Android ADK</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap4" />CHAPTER 4</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">Android ADK</p>
<div>
<p class="noindent">Since the introduction of the Android operating system in 2007, Android has become one of the more popular embedded Linux distributions available to consumers and hobbyist for development purposes. Google provides a vast knowledge base to help with getting started in developing Android-specific applications; the Google documentation, reference material, and SDK are available at <span class="FontName2"><a href="http://developer.android.com">http://developer.android.com</a></span>.</p>
<p class="indent">The popularity of Android development for the hobbyist can be attributed to the ease and cost of the available information. The draw for vendors to use Android as an operating system for many types of consumer electronics is that Android provides a great starting point by having much of the development for an operating system completed, and by providing the capacity for many different hardware configurations. As an operating system, Android provides a framework for vendors to add their own unique functionality, while having a support structure and standards of compatibility for third-party content developers. The market environment for Android mimics that of Linux&#x2014;each system has variations within its individual distributions. The differences between Android versions and the modifications by vendors have led to a fragmentation in support for development. This became more apparent when Google announced the Accessory Development Kit (ADK) in 2011.</p>
<p class="indent">The ADK was announced to provide a toolkit to developers so that third-party devices could be made to expand the hardware functionality of systems running Android. The ADK was first released for version 3.1 and then ported back to version 2.3.4. The fragmentation of Android devices has made it difficult to develop commercial devices that could be supported on a majority of systems running Android. The amount of off-the-shelf device support that can support the ADK protocols could change as more devices adopt the Ice Cream Sandwich version of Android. The ADK is comprised of two parts: a protocol for the device and hardware for the actual accessory.</p>
<p class="indent">When Google released the ADK software and libraries for the operating system, it also released a hardware kit that resembles an Arduino Mega with a shield attachment, and since then, many open source hardware developers have made boards compatible with the original ADK device. Seeed Studio and Arduino both make an ADK board that uses the ATMega 2560 chip. Both boards work the same and can be programmed in the Arduino development environment. SparkFun Electronics makes an ADK-compatible board named IOIO (pronounced <i>Yo-Yo</i>), but is based on a PIC microcontroller and has a different programming environment.</p>
<p class="indent">At the heart of ADK methodology having a device that can act as a USB host give the impression that the Android device is plugged into a computer to initiate communications. On the Arduino Mega ADK board, this is done by adding an SPI-based USB host processor. The chip used in creating the host connection uses the SPI bus for data transmission and is connected to the appropriate MOSI (master out slave in), MISO (master in slave out), SS (slave select), and SCLK (serial clock) pins. The USB functionality also uses pin 7, making it unavailable for other uses. Arduino shields are available to add the ADK functionality to other Arduino boards, such as the UNO and the basic Mega. Theses ADK shields are created by third-party vendors, including SparkFun for the USB host (<span class="FontName2"><a href="http://www.sparkfun.com/products/9947">www.sparkfun.com/products/9947</a></span>). A variety of different host shields are also available from <span class="FontName2"><a href="mailto:Circuits@Home">Circuits@Home</a></span> (<span class="FontName2"><a href="http://www.circuitsathome.com">www.circuitsathome.com</a></span>).</p>
<p class="indent">Devices that use the USB host chip are not limited to working with Android; they are also capable of working with other client devices, such as USB keyboards. But the focus in this chapter is Android-specific functionality with the Arduino Mega ADK. Before the ADK was available, hobbyists and makers were using a method that involved the Android Debugging Bridge (ADB) to add the functionality that is available with the ADK. The ADK can be used to add controls for robotics, read from nonstandard sensors, and interface with machines such as the MakerBot.</p>
<p id="Sec1" class="Heading1">Android Devices<a id="cXXX.116" /></p>
<p class="noindent">Before getting a board that is capable of USB hosting, you must locate a suitable Android target. As mentioned before, not all Android devices are currently capable of handling the ADK protocol. Devices that were made before the release of the ADK are the ones most likely not able to support ADK protocol without modification. Devices that use versions of Android as old as or older than 2.3.3 are not capable of handling the ADK methods at all. The older devices are still capable of using the ADB to create data connections.</p>
<p id="Sec2" class="Heading1">What to Check For</p>
<p class="noindent">For a device running Android to be nativity capable of using the ADK, the version must be 2.3.4 or later, but this not conclusive. The conclusive check is in the Google Play app market: search for &#x201C;ADK demo kit<a id="cXXX.117" />.&#x201D; If it&#x2019;s not available, the device does not have the required libraries installed. It has been found that some devices are capable of installing the demo kit, but lack an option that needs to be compiled into the operating systems kernel. This will show up when the demo kit is installed and run. The ADK hardware does not have to be connected; if the demo kit app shows a screen that asks for an ADK board to be connected the device is ready for ADK development.</p>
<p id="Sec3" class="Heading1">Known Working Devices<a id="cXXX.118" /></p>
<p class="noindent">Following is a list of Android devices that have been found to nativity work with ADK. (There are possibly more, with new Android devices coming out almost daily.) The devices that have native support are prime targets for commercial applications for developing accessories.</p>
<ul class="bulleted">
<li><i>Acer Iconia A100</i><a id="cXXX.119" />: This is a 7-inch tablet running Android version 3.2, running a dual-core 1 GHz Cortex-A9 with 1 GB of RAM.</li>
<li><i>Acer Iconia A500</i><a id="cXXX.120" />: This is a 10.1-inch tablet with the same processor and RAM as the Iconia A100, running Android version 3.2. Both of the Acer tablets are planned to be upgraded to Ice Cream Sandwich at some point.</li>
<li><i>ASUS Eee Pad Transformer TF101</i><a id="cXXX.121" />: This is 10.1-inch tablet with the same processor and RAM as the Acer tablets; it runs Android version 3.2 and is upgradable to Ice Cream Sandwich.</li>
<li><i>Google Nexus S</i><a id="cXXX.122" />: This is a phone made by Samsung for Google. This device runs a single-core 1 GHz Arm Cortex-A8 with 512 MB of RAM, running Android version 2.3 and upgradable to Ice Cream Sandwich. This device is a Google development phone providing great support for new APIs and developments.</li>
<li><i>Google Galaxy Nexus</i><a id="cXXX.123" />: This is also a Google development phone made by Samsung. It uses a dual-core 1 GHz Cortex-A9 with 1 GB of RAM and the Ice Cream Sandwich version of Android.</li>
<li><i>LG Optimus Pad</i><a id="cXXX.124" />: This is an 8.9-inch tablet with a dual-core 1 GHz Cortex-A9 with 1 GB of RAM running Android version 3.0.</li>
<li><i>Motorola Xoom</i><a id="cXXX.125" />: This is a 10.1-inch tablet with a dual-core 1 GHz NVIDIA Tegra 2 with 1 GB of RAM running Android version 3.0.</li>
<li><i>Samsung Galaxy Tab 10.1</i><a id="cXXX.126" />: This is a 10.1-inch tablet with a dual-core 1 GHz NVIDIA Tegra 2 with 1 GB of RAM running Android version 3.1.</li>
<li><i>Samsung Galaxy S</i><a id="cXXX.127" />: This is a phone with a single-core 1 GHz Arm Cortex-A8 with 512 MB of RAM. This device can be factory-upgraded to Android 2.3 to work with the ADK.</li>
<li><i>Samsung Galaxy Ace</i><a id="cXXX.128" />: This is a phone with an 800 MHz ARM 11 and 278 MB of RAM running Android version 2.3.</li>
</ul>
<p id="Sec4" class="Heading1">Modding<a id="cXXX.129" /></p>
<p class="noindent">The devices branded by Google are the better choice for heavy development. There are many devices that can be made to work with the ADK, but may require modding, also known as <i>rooting</i>. Modding is a great way to achieve extra functionality in an Android device. Modding is not without risks&#x2014;for example, so-called <i>bricking</i>, voiding of warranties, and the possibility of devices becoming unstable are the biggest problems.</p>
<p class="indent">If you decide to modify a device, do a sufficient amount of research and weigh the risks and cost before proceeding. If you&#x2019;re unsure about mods, either don&#x2019;t do them or consult someone who has.</p>
<p class="indent">This chapter was developed with a Barnes and Noble NOOK Color running both CyanogenMod 7<a id="cXXX.130" /> (Android 2.3) and CyanogenMod 9 (Android 4.0), dual-boot from the SD card. <i>CyanogenMod</i> is an aftermarket Android distribution providing custom ROM for a variety of devices. You can find more information about it at the CyanogenMod web site (<span class="FontName2"><a href="http://www.cyanogenmod.com">www.cyanogenmod.com</a></span>). CyanogenMod is developed by the community and has a lot of support, and is one of the more popular aftermarket Android distributions. You can find great resources for modding and development of Android systems at the XDA Developers forums (<span class="FontName2"><a href="http://www.xda-developers.com">www.xda-developers.com</a></span>).</p>
<p class="indent">I chose the NOOK Color as a development platform because of the cost, ease of modification, and decent hardware specifications. CyanogenMod 7 for this device had to have a custom kernel compiled with the configure flag <span class="FontName2">CONFIG_USB_ANDROID_ACCESSORY</span> set during the compile, and the <span class="FontName2">usb.jar</span> libraries added to the system. CyanogenMod 9 for the NOOK Color can be installed on an 8 GB microSD card and booted&#x2014;just like having multiple bootable devices on a normal PC. You don&#x2019;t need a NOOK Color for the examples in this chapter, although you will need an Android device capable of using the ADK protocols.</p>
<p id="Sec5" class="Heading1">Arduino IDE<a id="cXXX.131" /> Setup</p>
<p class="noindent">This chapter will provide an introduction to building a classic Hello World hardware example with an Android twist. An Android device and an Arduino Mega ADK are needed for the rest of this chapter. Before any programming can be done, the Android and Arduino environments need to be set up. The Arduino 1.0 IDE (or later) should already be available, but a library is needed to work with the ADK protocol. The appropriate library<a id="cXXX.132" /> is available from the Arduino labs web site (<span class="FontName2"><a href="http://labs.arduino.cc/uploads/ADK/GettingStarted/ArduinoADK-beta-001.zip">http://labs.arduino.cc/uploads/ADK/GettingStarted/ArduinoADK-beta-001.zip</a></span>).</p>
<p class="indent">Contained in the ZIP file are files for Processing and Arduino; you can ignore the <span class="FontName2">Processing</span> folder. In the Arduino folder are two versions of the library. Extract the folder named <span class="FontName2">UsbHost</span> and the files located in the <span class="FontName2">libraries</span> folder to the <span class="FontName2">libraries</span> folder for the Arduino IDE. Start or restart the Arduino IDE, finishing the installation<a id="cXXX.133" /> of the new library. Under File <img src="images/arrow.jpg" alt="image" /> Examples <img src="images/arrow.jpg" alt="image" /> UsbHost, examples should now be available. Open the first example and verify that it can compile. Once finished, the Arduino IDE will be ready to program ADK applications.</p>
<p class="indent">You need to set up a development environment<a id="cXXX.134" /> to write the Android code and make the installation packages. Both Processing (<span class="FontName2"><a href="http://processing.org">http://processing.org</a></span>) and Eclipse (<span class="FontName2"><a href="http://eclipse.org">http://eclipse.org</a></span>) can create Android applications. Programming in Processing is similar to programming Arduino code, but lacks some finesse and control. This chapter focuses on the Eclipse IDE<a id="cXXX.135" />, which provides greater functionality but is a bit cumbersome. When using Eclipse for Android development, you need to understand two different styles of code: the main Java-related portion and XML. The Java-styled code is the grunt of any Android application and is the main programming language; XML is the fluff that defines the layout, objects, and text that gets displayed. I&#x2019;ll describe the programming methodologies for application development a bit later in the chapter. If this is your first introduction to Android development, check out Wallace Jackson&#x2019;s <i>Android Apps for Absolute Beginners</i> (Apress, 2011).</p>
<p class="indent">Installing the Eclipse IDE is fairly straightforward. For best results, follow the instructions on the Android Developers web site for your specific system (<span class="FontName2"><a href="http://developer.android.com/sdk/installing.html">http://developer.android.com/sdk/installing.html</a></span>). The complicated part of the setup is making sure that the ADB functions<a id="cXXX.136" /> properly; this may actuality require that you have root access and that you turn on USB debugging in the device settings. To check if the ADB is working, in a command prompt change to the <span class="FontName2">platform-tools</span> directory and run the command <span class="FontName2">adb</span>, and the command&#x2019;s help should be printed to the screen. If the command does not run from any other directory, check to see if the SDK&#x2019;s installation directory has been added to the environment variables.</p>
<p class="indent">Once the help is displayed plug the intended device for development into the computer, and run the command <span class="FontName2">adb devices</span> to print a list of connected devices. If no device shows up, USB debugging might be turned off or root accesses might be needed. The ADB is not necessary for loading applications on the device, but it is helpful to be able to have the application automatically uploaded to the device from Eclipse when in development stages. If the ADB is not available, the application&#x2019;s APK file has to be manually installed on the system. For each change, a file manager will have to be installed from the market, and the system has to allow for untrusted sources. You can set this in the Manage Applications section in the systems settings. Eclipse has the ability to run emulators and use actual hardware for debugging. It is helpful if the ADB is available to run an application called ADB Wireless<a id="cXXX.137" /><a id="cXXX.138" />, available from the apps market. Note that this app requires root access. Running the ADB over a wireless network allows for the Arduino Mega ADK<a id="cXXX.139" /> to be constantly attached to the Android device and the computer during developments.</p>
<div>
<p id="Sec6" class="Heading2">Android Application Creation<a id="cXXX.66a" /></p>
<p class="noindent">After the Eclipse IDE is set up, you&#x2019;ll create a new Android project from the New Project wizard in Eclipse.</p>
<ol class="OrderedList">
<li>Choose File <img src="images/arrow.jpg" alt="image" /> New <img src="images/arrow.jpg" alt="image" /> Project, and then select Android Application Project in the Android folder within the wizard selector, as shown in <a href="#Fig1" id="_Fig1">Figure 4-1</a>.
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig04-01.jpg" alt="9781430239390_Fig04-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 4-1</a> </span>.&#160;&#160;Eclipse&#x2019;s New Project dialog<a id="cXXX.140" /> </p>
</div>
<p class="indent">The next prompt (see <a href="#Fig2" id="_Fig2">Figure 4-2</a>) requires an application name, project name, package name, and declaration of the Android SDK version.</p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig04-02.jpg" alt="9781430239390_Fig04-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 4-2</a></span> .&#160;&#160;The New Android App dialog<a id="cXXX.145" /> </p>
</div></li>
<li>Enter <span class="FontName2">ADK blink</span><a id="cXXX.141" /> as the application name for this chapter.</li>
<li>Name<a id="cXXX.142" /> the project <span class="FontName2">CH4Examples</span>.</li>
<li>Name the package <span class="FontName2">CH4.example.proarduino</span>. The package name is a triplet descriptor that defines a base Java package that will be the program&#x2019;s entry point. The application name, project name, and package name can be set to anything for later projects and should be set in the wizard when creating projects; note that once you&#x2019;ve created these names for a project, it is difficult to change them later on.</li>
<li>Next, you&#x2019;ll set which API level<a id="cXXX.143" /> to use. Select Google APIs for the 2.3.3 platform, API version 10. The API sets the minimum version of Android that the application will work on, API version 10 will work on future Android releases. Do not use Android <i>X.X.X</i>, where <i>X.X.X</i> is the target version of Android, when developing ADK applications. Only the Google APIs have the required support for the ADK.</li>
<li>You can also choose to create a custom logo for the application. For now, though, deselect the &#x201C;Create custom launcher icon&#x201D; option. If the option is selected, you will be given an additional set of prompts for setting the application logo<a id="cXXX.144" />.</li>
<li>Finally, leave the &#x201C;Mark this project as a library&#x201D; and &#x201C;Create Project in Workspace&#x201D; options at their defaults, and then click Next.</li>
<li>On the next page of the wizard, you&#x2019;ll select options for the type of activity to create (see <a href="#Fig3" id="_Fig3">Figure 4-3</a>). The activity is the main form of user interaction. Not all Android apps need an activity to run, and different API levels give different options. The only one that can be used for the project&#x2019;s current API is BlankActivity<a id="cXXX.146" />, so choose that, and then click Next.
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig04-03.jpg" alt="9781430239390_Fig04-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 4-3</a></span> .&#160;&#160;Activity-creation options<a id="cXXX.147" /> </p>
</div></li>
<li>Finally, you&#x2019;ll set some of the names for some of the project&#x2019;s internal files (see <a href="#Fig4" id="_Fig4">Figure 4-4</a>)<a id="cXXX.148" />. Make sure that the names in the Activity Name and Title fields match those of the project&#x2019;s name, followed by <span class="FontName2">Activity</span> (e.g., <span class="FontName2">CH4ExamplesActivity</span>). For this exercise, change the layout name to <span class="FontName2">main</span>. The layout name describes the first user interface that the program will use by default. You can leave Navigation Type at the default of &#x201C;None,&#x201D; since this is going to be a stand-alone application and does not require a parent program. For more advanced applications, you can change this to accommodate different user interactions, such as tabbed navigation.
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig04-04.jpg" alt="9781430239390_Fig04-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 4-4</a> </span>.&#160;&#160;Activity name and layout options </p>
</div></li>
</ol>
<p class="indent">When you click Finish, the wizard creates an autogenerated Hello World project and a <span class="FontName2">*.apk</span> file; these form the framework<a id="cXXX.69a" /> for the rest of the examples in this chapter. If this is the first time an Android application is being set up, there may be a need for the wizard to automatically download some extra software components.</p>
<p class="indent">If the ADB is set up and the device is available, you can load the basic app and start it on an Android device by clicking on the Play button on the toolbar, selecting Run from the Run menu, or pressing Ctrl+F11. When the project is initiated for the first time, Eclipse will ask how to run the application. Make sure to select &#x201C;Android application&#x201D; from the options. After you have selected the Run As options<a id="cXXX.149" />, you need to select the device to run; if the ADB is working and the device is connected an option will be shown to choose a running Android device. You can create an Android Virtual Device (AVD)<a id="cXXX.150" /><a id="cXXX.151" /> to test running an application if a physical device is not plugged in or one is simply not available. Note that the AVD is not capable of testing ADK functionality, because of a USB host conflict.</p>
<p class="indent">The next section focuses on the Arduino and preparing to communicate with the ADK before building the actual Android app.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;If you&#x2019;re not running the ADB, you can copy the <span class="FontName2">.apk</span> file to an Android device from the workspace <i>project name</i><span class="FontName2">/bin</span> folder and install it by running <span class="FontName2">.apk</span> from the Android device.</p>
</div>
<div>
<p id="Sec7" class="Heading2">The Arduino Sketch<a id="cXXX.69b" /></p>
<p class="noindent">Working with the ADK with the Arduino is similar to working with software serial, in that a header needs to be included, an object declared, and that object started. The library that was added to the Arduino&#x2019;s IDE provides a clean method of declaring and initializing the host connection when compared to other libraries that are available, and is based on the <span class="FontName2"><a href="mailto:Circuits@Home libraries">Circuits@Home libraries</a></span><a id="cXXX.152" />. The header that needs to be included is <span class="FontName2">AndroidAccessory.h</span>. The object is of type <span class="FontName2">AndroidAccessory</span><a id="cXXX.153" /> and can be named anything; it has some information that is declared upon object creation. The data that is declared when the <span class="FontName2">AndroidAccessory</span> object is created is for identification to any Android device that the board is connected to, thus registering the Arduino to a particular application. The data is enclosed in parentheses and separated by commas after the object&#x2019;s name. The declared data is ordered and defined as manufacturer, model, description, version, Uniform Resource Identifier (URI), and serial. The data is represented as a character string and can be any reasonable number of printable characters. It&#x2019;s always available to the connected Android device. The manufacturer, model, and version are used to identify the accessory to a program on the Android device. The rest of declaration information can be used for tracking and debugging<a id="cXXX.154" /> reports in applications for widespread or commercial use.</p>
<p class="indent">The accessory is started the same way as software serial: by calling <span class="FontName2">name.begin</span> in the <span class="FontName2">setup</span> function of the Arduino sketch. The object&#x2019;s public functions&#x2014;<span class="FontName2">available</span>, <span class="FontName2">write</span>, <span class="FontName2">peek</span>, and <span class="FontName2">flush</span>&#x2014;perform the same work as their serial or software-serial counterparts, along with <span class="FontName2">print</span> and <span class="FontName2">println</span>. There are two other functions to note when working with the <span class="FontName2">AndroidAccessory</span> library. One is <span class="FontName2">isConnected</span><a id="cXXX.155" />, which returns a Boolean for the status of the connection between Arduino and Android. The last added function is <span class="FontName2">refresh</span><a id="cXXX.156" />; it&#x2019;s used to reset and reinitialize the connection between the two devices after the devices have been reconnected. If the Arduino code checks for a connection from the <span class="FontName2">isConnected</span> function, it will also call <span class="FontName2">refresh</span> to try to reestablish the connection every time <span class="FontName2">isConnected</span> called. The use of <span class="FontName2">refresh</span> or an <span class="FontName2">isConnected</span> check in the Arduino code&#x2019;s main loop creates the ability to connect devices without having to power-cycle or rest the Arduino.</p>
<p class="indent">The first example sets up an LED to change state on the Arduino when a virtual button on the Android device is pressed. The Arduino is set up as per <a href="#Fig5" id="_Fig5">Figure 4-5</a>, with an optional LED connected to Arduino pin 13. The code accomplishes the state change by receiving a <span class="FontName2">1</span> to turn on the LED and any other byte value from the Android device to turn it off. The code also implements the <span class="FontName2">refresh</span> function to allow for reconnecting the two devices without resetting the Arduino.</p>
<div class="Figure" id="Fig5">
<p class="img"><img src="images/9781430239390_Fig04-05.jpg" alt="9781430239390_Fig04-05.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig5">Figure 4-5</a></span> .&#160;&#160;Arduino-to-Android configuration<a id="cXXX.157" /> </p>
</div>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;The host port on the Arduino Mega ADK provides some power to signify a live connection to the Android device; however, it is not capable of providing a charge. As such, extra circuitry is needed to introduce enough power to charge a connected device.</p>
</div>
<p class="indent">Connect the Arduino as in the preceding figure; it needs to be connected to the computer for programming, and then later to the Android via a micro USB-to-USB A cable after the Android application has been completed. Step through <a href="#list1" id="_list1">Listing 4-1</a> and upload the code to the Mega ADK board, remembering to switch the board type. To select the board type in the Arduino IDE, choose Tools <img src="images/arrow.jpg" alt="image" /> Board <img src="images/arrow.jpg" alt="image" /> Arduino Mega 2560 or Mega ADK. In conjunction with the connection between Android and the Arduino, the code also sets up a serial connection to the computer for debugging purposes at a baud rate of 115200. The code will print <span class="FontName2">ready</span> to the serial port when the <span class="FontName2">setup</span> function has finished, and other debugging information will be printed when the code is connected to a working application later.</p>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 4-1.</i></b></a>&#160;&#160;Arduino Code for Connecting<a id="cXXX.158" /> to an Android Application</p>
<pre><span class="FontName2">#include &#x003C;AndroidAccessory.h&#x003E;&#160;&#160; // needed library to work with ADK connections</span><br /><span class="FontName2">// initialize the accessory object with identifying data</span><br /><span class="FontName2">AndroidAccessory ADK(&quot;Manufacturer&quot;, &quot;Model&quot;, &quot;Description&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;1.0&quot;, &quot;Pro Arduino&quot;, &quot;0000000012345678&quot;);</span><br /><span class="FontName2">void setup() {</span><br />&#160;&#160; <span class="FontName2">Serial.begin(115200);</span><br />&#160;&#160; <span class="FontName2">ADK.begin();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// start the connection to the Android</span><br />&#160;&#160; <span class="FontName2">pinMode(13, OUTPUT);</span><br />&#160;&#160; <span class="FontName2">Serial.print(&quot;ready&quot;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }&#160;&#160;&#160;&#160;// end setup</span><br /><span class="FontName2">void loop() {</span><br />&#160;&#160; <span class="FontName2">if (ADK .isConnected()) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// check for live connection</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (ADK.available() &#x003E; 0){&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // check for incoming data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Serial.println(ADK .peek());&#160;&#160;&#160;&#160;&#160;&#160; // print incoming data for visible inspection</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">if (ADK.read() == 1)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // pin HIGH for an incoming value of 1</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// everything else pin is low</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(13 , HIGH);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">else</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(13 , LOW);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160; // end if (ADK .available() &#x003E; 0)</span><br />&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160; // end if (ADK .isConnected())</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160; // end void loop()</span></pre>
</div>
<div>
<p id="Sec8" class="Heading2">The Android ADK<a id="cXXX.71a" /> Application<a id="cXXX.71b" /></p>
<p class="noindent">Programming apps for Android can be an involved process, especially for widespread or commercial programs. This section provides a crash course in the development of Android applications; some of the ADK code is based on work from AllAboutEE (<span class="FontName2"><a href="http://allaboutee.com">http://allaboutee.com</a></span>). The focus is getting Arduinos to communicate with the Android devices&#x2014;note that some of the fundamentals of Java and some advanced features of Android application programming may be glossed over. The hardest part for some when deciding to start writing applications for Android is the change in languages<a id="cXXX.159" />&#x2014;Arduinos are coded in C++ and Android is developed in Java. For others, the event-driven GUI development<a id="cXXX.160" /> might be a new experience. <a href="9781430239390_Ch03.xhtml">Chapter 3</a> introduced some of the concepts of event-driven applications and working with two different code structures. Aside from Java, Android also introduces XML resources; XML is another code language that is necessary when developing Android applications. Four different XML files are used when working with Android code; three are automatically generated during project generation: <span class="FontName2">main.xml</span>, <span class="FontName2">strings.xml</span>, and <span class="FontName2">AndroidManifest.xml</span>; the fourth, <span class="FontName2">accessory_filter.xml</span>, is not. The following list describes these four files:</p>
<ul class="bulleted">
<li><span class="FontName2">main.xml</span><a id="cXXX.161" /><a id="cXXX.162" /> contains the layout for an application&#x2019;s first screen. The file contains descriptors for onscreen object layout, type, and identification. Eclipse has a built-in graphical tool for choosing and placing objects, and gives you the ability to view the XML. The <span class="FontName2">main.xml</span> file is located in the workspace of the project, in the <span class="FontName2">res/layout/main.xml</span> folder.</li>
<li><span class="FontName2">strings.xml</span><a id="cXXX.163" /><a id="cXXX.164" /> is used to define static information in the form of character strings. This file can be used to define information from many different attributes, such as object names, information for text fields, and file locations. This file is not absolutely necessary for small applications being developed, but note that Eclipse will throw a warning when strings are hard coded. Using <span class="FontName2">strings.xml</span> is good programming practice and is useful for when multiple instances of data are used throughout an application, providing a single place to update instead of requiring that every occurrence in the code be changed. The <span class="FontName2">strings.xml</span> file is located in the workspace of the project, in the <span class="FontName2">res/values/strings.xml</span> folder.</li>
<li><span class="FontName2">AndroidManifest.xml</span><a id="cXXX.165" /><a id="cXXX.166" /> defines what package and activity need to start when the application is launched, the type of the application, what system events are responded to, and some miscellaneous information for the Android device, along with the icons to be used. <span class="FontName2">AndroidManifest.xml</span> is similar to a <span class="FontName2">main</span> function in C or C++; this is where the application enters and starts. Android uses intent filters that are checked when a system event occurs, and if the filter in the file matches the event, the application can be started (e.g., when a call is received, an application is run for the user). The <span class="FontName2">AndroidManifest.xml</span> file is located in the workspace root.</li>
<li>The <span class="FontName2">accessory_filter.xml</span> file<a id="cXXX.167" /><a id="cXXX.168" /> needs to be created by the programmer and is used when <span class="FontName2">AndroidManifest.xml</span> responds when accessories are attached. The data in this file is compared to the created data in the Arduino sketch when a connection is getting established. To create this file, you need to create a folder in the workspace&#x2019;s <span class="FontName2">res</span> folder named <span class="FontName2">xml</span> and add a new file to this folder, named <span class="FontName2">accessory_filter.xml</span>.</li>
</ul>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Before you insert the code from the listings in this chapter, you need to delete the <span class="FontName2">styles.xml</span> file and the <span class="FontName2">menus</span> folder from the <span class="FontName2">res</span> folder and the project&#x2019;s workspace.</p>
</div>
<p class="indent">The application framework and workspace were already created for this example when the Hello World application was created to test the functionality of the development environment. Step through the code in the examples following and compare to the code generated to get a feel for how everything is structured, and then replace the code in the workspace project with the appropriate example code.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Eclipse with the Android SDK is sometimes a bit temperamental; errors that report that <span class="FontName2">R.*</span> is not capable of resolving are caused by the <span class="FontName2">R.java</span> not being generated. Try a clean and rebuild the project after checking for errors in the XML files. Try ctrl + shift + o to organize imports and select the activity if clean and rebuild doesn&#x0027;t work.</p>
</div>
<div>
<p id="Sec9" class="Heading3">AndroidManifest.xml</p>
<p class="noindent">The manifest file is the best place to start when developing applications, because it is the entry point for every Android application. The manifest is fairly consistent between applications and can be reused with minor changes across many different applications. The first line defines the XML version and the encoding, and will be the same in all the XML files. The tags following define the systems resources, package name, versions, main icon, application name, and activity to be used in the application. The package name has to match that of the first Java container that contains the code for the project to tell the operating system where to look, and the activity name has to match that of the first activity that will be run. Also, the entry point to an app is the constructor for the main activity class. The rest of the manifest file defines what needs to be done when the application is started either by the user or a system event, as well as any extra libraries on the system that the application needs.</p>
<p class="indent">This application is an activity-based program and has a user interface when started (alternatively, applications can be started as a process to run in the background and can have no user interface). Replace the original <span class="FontName2">AndroidManifest.xml</span> file with <a href="#list2" id="_list2">Listing 4-2</a>; to make things easier, make sure that the <span class="FontName2">package</span> attribute and <span class="FontName2">&#x003C;activity&#x003E;</span> tag match those of the original code generated.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 4-2.</i></b></a>&#160;&#160;AndroidManifest.xml Replacing the Autogenerated Original</p>
<pre><span class="FontName2">&#x003C;?xml version=</span><i>&quot;1.0&quot;</i><span class="FontName2">encoding=</span><i>&quot;utf-8&quot;</i><span class="FontName2">?&#x003E;</span><br /><span class="FontName2">&#x003C;!-- define entry package name, name space and code version --&#x003E;</span><br /><span class="FontName2">&#x003C;manifest xmlns:android=</span><i>&quot;</i><span class="FontName2"><a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a></span><i>&quot;</i><br />&#160;&#160;<span class="FontName2">package=</span><i>&quot;CH4.example.proArduino&quot;</i><span class="FontName2">android:versionCode=</span><i>&quot;1&quot;</i><br />&#160;&#160;<span class="FontName2">android:versionName=</span><i>&quot;1.0&quot;</i><span class="FontName2">&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;!-- define minimum usable android version--&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;uses-sdk android:minSdkVersion=</span><i>&quot;10&quot;</i><span class="FontName2">/&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;!-- application&#x0027;s definitions icons, name and entry activity --&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;application android:icon=</span><i>&quot;@drawable/ic_launcher&quot;</i><span class="FontName2">android:label=</span><i>&quot;@string/app_name&quot;</i><span class="FontName2">&#x003E;</span><br />&#160;<span class="FontName2">&#x003C;!-- activity to be launched when program starts --&#x003E;</span><br />&#160;<span class="FontName2">&#x003C;activity android:name=</span><i>&quot;.CH4ExamplesActivity&quot;</i><span class="FontName2">android:label=</span><i>&quot;@string/app_name&quot;</i><span class="FontName2">&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;!-- define events that this app responds to --&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;intent-filter&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;action android:name=</span><i>&quot;android.intent.action.MAIN&quot;</i><span class="FontName2">/&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;category android:name=</span><i>&quot;android.intent.category.LAUNCHER&quot;</i><span class="FontName2">/&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;/intent-filter&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;!-- respond when attaching accessories&#160;&#160;--&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;intent-filter&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;action android:name=</span><i>&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</i><span class="FontName2">/&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;/intent-filter&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;!-- use listed file to determine if accessory is for this application --&#x003E;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;meta-data android:name=</span><i>&quot;android.hardware.usb.action.USB_ACCESSORY_ATTACHED&quot;</i><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">android:resource=</span><i>&quot;@xml/accessory_filter&quot;</i><span class="FontName2">/&#x003E;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;/activity&#x003E;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;!-- ADK programs need this library --&#x003E;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">&#x003C;uses-library android:name=</span><i>&quot;com.android.future.usb.accessory&quot;</i><span class="FontName2">&#x003E;&#x003C;/uses-library&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;/application&#x003E;</span><br /><span class="FontName2">&#x003C;/manifest&#x003E;</span><br /><span class="FontName2">&#x003C;!-- end of AndroidManifest.xml --&#x003E;</span></pre>
</div>
<div>
<p id="Sec10" class="Heading3">res/xml/accessory_filter.xml<a id="cXXX.169" /><a id="cXXX.170" /></p>
<p class="noindent">The <span class="FontName2">accessory_filter.xml</span> file is created in a folder that is added after program creation in the workspace location <span class="FontName2">res/xml</span>. The information contained in this file is used by the manifest to load values for comparison into variables used by the main program when an accessory is detected and determines if the accessory belongs to the program. The code uses the manufacturer, model number, and version to detect a match. The description, URI, and serial number can be accessible to the program, but are not needed here. This file changes the accessory that the code will respond to upon a system event. The manifest and this file remain fairly consistent, although there are minor changes between programs that have user interaction and utilize ADK accessories. <a href="#list3" id="_list3">Listing 4-3</a> shows this file for our app.</p>
<p class="noindent2"><a href="#_list3" id="list3"><b><i>Listing 4-3.</i></b></a>&#160;&#160;<i>accessory_filter.xml </i></p>
<pre><span class="FontName2">&#x003C;?xml version=</span><i>&quot;1.0&quot;</i><span class="FontName2">encoding=</span><i>&quot;UTF-8&quot;</i><span class="FontName2">?&#x003E;</span><br /><span class="FontName2">&#x003C;resources&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;!-- match to Arduino sketch&#x0027;s accessory declaration object --&#x003E;</span><br />&#160;&#160; <span class="FontName2">&#x003C;usb-accessory manufacturer=</span><i>&quot;Manufacturer&quot;</i><span class="FontName2">model=</span><i>&quot;Model&quot;</i><span class="FontName2">version=</span><i>&quot;1.0&quot;</i><span class="FontName2">/&#x003E;</span><br /><span class="FontName2">&#x003C;/resources&#x003E;</span><br /><span class="FontName2">&#x003C;!-- end of accessory-filter.xml --&#x003E;</span></pre>
</div>
<div>
<p id="Sec11" class="Heading3">res/layout/main.xml<a id="cXXX.171" /><a id="cXXX.172" /></p>
<p class="noindent">This is the first file of the Android application that is different from one program to another, because this file defines the user interface. There can be multiple layout files in an Android application containing different objects to display information or receive interaction from the user. This file&#x2019;s initial section creates the layout area with specifications on how much of the device&#x2019;s screen is used. Following the layout area definition are tags for defining an object&#x2019;s ID, placement, and size, and the function to use when a user interface object is manipulated, either from the user or code.</p>
<p class="indent">There is a plethora of defining parameters for each object, such as the ability to define what function to run in the Java code when a button is pressed. The tag for the toggle button used in this example demonstrates implementing a called function; when the toggle button is pressed, a <span class="FontName2">blinkLED</span> function is called in the Java code. Eclipse has the ability to graphically lay out objects for the application and generates the required XML needed. Look over and compare the <a href="#list4" id="_list4">Listing 4-4</a> to the generated XML for <span class="FontName2">main.xml</span> and replace it.</p>
<p class="noindent2"><a href="#_list4" id="list4"><b><i>Listing 4-4.</i></b></a>&#160;&#160;main.xml Replacing the Autogenerated Original</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;RelativeLayout xmlns:android=&quot;</span><span class="FontName2"><span class="FontName2"><a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a></span></span><span class="FontName2">&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/relativeLayout1&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_weight=&quot;0.72&quot; &#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;ToggleButton</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/toggleButtonLED&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;200dp&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;100dp&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_centerInParent=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_marginTop=&quot;89dp&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:onClick=&quot;blinkLED&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:text=&quot;@string/ToggleButton&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:textSize=&quot;50dp&quot; /&#x003E;</span><br /><span class="FontName2">&#x003C;/RelativeLayout&#x003E;</span><br /><span class="FontName2">&#x003C;!-- end of main.xml --&#x003E;</span></pre>
</div>
<div>11
<p id="Sec12" class="Heading3">res/values/strings.xml<a id="cXXX.173" /><a id="cXXX.174" /></p>
<p class="noindent">The <span class="FontName2">strings.xml</span> file is a container for reusable data such as button and application names. The strings are static, but could be uses throughout the program. It is good programming practice to define the strings in this file instead of hard-coding them into other locations. In the manifest <span class="FontName2">@string/app_name</span> and <span class="FontName2">@string/ToggleButton</span> are used as static variable containers, as shown in <a href="#list5" id="_list5">Listing 4-5</a>. It is possible to replace the variable with the actual string value to save on code length, but it is not recommended.</p>
<p class="noindent2"><a href="#_list5" id="list5"><b><i>Listing 4-5.</i></b></a>&#160;&#160;strings.xml Replacing the Autogenerated Original</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;resources&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;app_name&quot;&#x003E;Mega ADK&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;ToggleButton&quot;&#x003E;ToggleButton&#x003C;/string&#x003E;</span><br /><span class="FontName2">&#x003C;/resources&#x003E;</span><br /><span class="FontName2">&#x003C;!-- end of strings.xml --&#x003E;</span></pre>
</div>
<div>
<p id="Sec13" class="Heading3">src/CH4.example.proArduino/CH4ExamplesActivity.java<a id="cXXX.175" /></p>
<p class="noindent">Here is the heart and soul of an Android app. <a href="#list6" id="_list6">Listing 4-6</a> is broken up in to seven parts to help explain everything that goes into the Java portion of Android applications. <a href="#list6">Listing 4-6</a> code appears in order of placement in the <span class="FontName2">CH4ExamplesActivity.java</span> file and makes up the complete file located in the workspace under <span class="FontName2">src/ch4.example.proArduino</span>. Most of the code for this example starts the basic framework to send data to the accessory board. Parts 3 through 6 are set up to be reusable. After we&#x2019;ve finished this example, we&#x2019;ll set up a framework to perform two-way communications that you can use in any project by changing the activity class and the package name. Aside from the project name, package name, activity name, and accessory definition, <span class="FontName2">manifest.xml</span>, <span class="FontName2">accessory_filter.xml</span>, and <a href="#list6">Listing 4-6</a> remain relatively unchanged for new projects. Part 7 of <a href="#list6">Listing 4-6</a> is where you will change the code between projects.</p>
<p class="indent">Part 1, line 1 of <a href="#list6">Listing 4-6</a> describes the package that the Java file belongs to. This is also the entry package that was defined in the manifest file. The rest of the file imports needed functions and classes for the rest of the program. Imports are mostly equivalent to C/C++ <span class="FontName2">#include</span> statements and inform the code what classes are needed. USB communication is handled through a file, so the Java I/O file handlers need to be imported, but not all of the I/O library classes are needed and only a subset of the classes are imported. The same is true for the <span class="FontName2">android.*</span>libraries&#x2014;only the ones that are actually needed are imported. It is possible to import every class in a library at once with a wildcard character (<span class="FontName2">*</span>), as is done with the <span class="FontName2">com.android.future.usb.*</span> libraries. When adding objects to the user interface, each object type will need to be imported from widgets in the same fashion as the toggle button.</p>
<p class="noindent2"><a href="#_list6" id="list6"><b><i>Listing 4-6.</i></b></a>&#160;&#160;CH4ExamplesActivity.java<a id="cXXX.176" />, Part 1 of 7</p>
<pre><span class="FontName2">package ch4.example.proArduino;</span><br />&#160;&#160;<span class="FontName2">import java.io.FileDescriptor;</span><br />&#160;&#160;<span class="FontName2">import java.io.FileInputStream;</span><br />&#160;&#160;<span class="FontName2">import java.io.FileOutputStream;</span><br />&#160;&#160;<span class="FontName2">import java.io.IOException;</span><br /><br />&#160;&#160;<span class="FontName2">// Android components</span><br />&#160;&#160;<span class="FontName2">import android.app.Activity;</span><br />&#160;&#160;<span class="FontName2">import android.app.PendingIntent;</span><br />&#160;&#160;<span class="FontName2">import android.content.BroadcastReceiver;</span><br />&#160;&#160;<span class="FontName2">import android.content.Context;</span><br />&#160;&#160;<span class="FontName2">import android.content.Intent;</span><br />&#160;&#160;<span class="FontName2">import android.content.IntentFilter;</span><br />&#160;&#160;<span class="FontName2">import android.os.Bundle;</span><br />&#160;&#160;<span class="FontName2">import android.os.ParcelFileDescriptor;</span><br />&#160;&#160;<span class="FontName2">import android.util.Log;</span><br />&#160;&#160;<span class="FontName2">import com.android.future.usb.*;</span><br /><br />&#160;&#160;<span class="FontName2">// UI components</span><br />&#160;&#160;<span class="FontName2">import android.view.View;</span><br />&#160;&#160;<span class="FontName2">import android.widget.ToggleButton;</span></pre>
<p class="indent">Part 2 of the code starts the new class activity and inherits functionality from the parent class of the activity by extending the original class&#x2019;s functionality. This part also creates the object variable needed by the rest of the code to set up the ADK functionality, and create containers to hold user interface object registrations and debugging tags. Debugging tags are used to show what program sent a flag to the ADB. A function named <span class="FontName2">Log</span> sends the flag to the ADB as a string and can be read by issuing the command <span class="FontName2">adb logcat</span> in a command terminal on computer connected to the Android device when the ADB is available.</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 2 of 7</p>
<pre><span class="FontName2">public class CH4ExamplesActivity&#160;&#160;extends Activity&#160;&#160; {</span><br />&#160;&#160; <span class="FontName2">// ADK input and output declaration</span><br />&#160;&#160; <span class="FontName2">UsbAccessory ARDUINO_ADK; // the Accessory object</span><br />&#160;&#160; <span class="FontName2">ParcelFileDescriptor ADKstreamObj;</span><br />&#160;&#160; <span class="FontName2">FileInputStream ReciveFromADK;</span><br />&#160;&#160; <span class="FontName2">FileOutputStream SendtoADK;</span><br /><br />&#160;&#160; <span class="FontName2">// setup and logging</span><br />&#160;&#160; <span class="FontName2">private static final String ACTION_USB_PERMISSION = &quot;MEGA_ADK.USB_PERMISSION&quot;;</span><br />&#160;&#160; <span class="FontName2">private static final String TAG = &quot;MEGA ADK&quot;;&#160;&#160; // debug tag sent Log</span><br />&#160;&#160; <span class="FontName2">private UsbManager UsbManagerOBJ;</span><br />&#160;&#160; <span class="FontName2">private PendingIntent Needed_Permission;</span><br />&#160;&#160; <span class="FontName2">private boolean IsPermissionNeeded;</span><br /><br />&#160;&#160; <span class="FontName2">// UI components</span><br />&#160;&#160; <span class="FontName2">private ToggleButton buttonLED;</span></pre>
<p class="indent">Part 3 is a collection of functions used for program handling. The constructor and destructor are defined in this section along with definitions of how to handle the program when paused and resumed. These functions are overridden from the originals contained in the original activity class so that the extra functionality of the ADK protocol can be added.</p>
<p class="indent">The <span class="FontName2">@Override</span> lines tell the program that the function below is different from the function that is defined in the parent class; however, by using <span class="FontName2">super.</span><i>functionName</i> we make sure that the parent&#x2019;s function is also called in the new code. In the <span class="FontName2">onCreate</span> function, the accessory is set up, the main view is registered to the program, and the user interface objects are linked. Because of the differences in the user interface layout between different projects, a <span class="FontName2">registerUIobjects</span> function has been created to contain and handle these differences.</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 3 of 7</p>
<pre><span class="FontName2">@Override</span><br /><span class="FontName2">public void onCreate(Bundle savedInstanceState) {</span><br />&#160;&#160; <span class="FontName2">super.onCreate(savedInstanceState);</span><br />&#160;&#160; <span class="FontName2">setupAccessory();</span><br />&#160;&#160; <span class="FontName2">setContentView(R.layout.main);</span><br />&#160;&#160; <span class="FontName2">registerUIobjects();</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end onCreate</span><br /><br /><span class="FontName2">@Override</span><br /><span class="FontName2">public void onDestroy() {</span><br />&#160;&#160; <span class="FontName2">unregisterReceiver(ADKReceiver);</span><br />&#160;&#160; <span class="FontName2">super.onDestroy();</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end onDestroy</span><br /><br /><span class="FontName2">@Override</span><br /><span class="FontName2">public void onPause() {</span><br />&#160;&#160; <span class="FontName2">super.onPause();</span><br />&#160;&#160; <span class="FontName2">closeAccessory();</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160; // end onPause()</span><br /><br /><span class="FontName2">@Override</span><br /><span class="FontName2">public void onResume() {</span><br />&#160;&#160; <span class="FontName2">super.onResume();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (ReciveFromADK != null &#x0026;&#x0026; SendtoADK != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">return;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160; // end&#160;&#160;if (ReciveFromADK != ...</span><br />&#160;&#160; <span class="FontName2">UsbAccessory[] accessories = UsbManagerOBJ.getAccessoryList();</span><br />&#160;&#160; <span class="FontName2">UsbAccessory accessory = (accessories == null ? null : accessories[0]);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (accessory != null) {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">if (UsbManagerOBJ.hasPermission(accessory)) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">openAccessory(accessory);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end if (UsbManagerOBJ.hasPermission(accessory))</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">synchronized (ADKReceiver) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">if (IsPermissionNeeded == true) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">UsbManagerOBJ.requestPermission(accessory, Needed_Permission);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">IsPermissionNeeded = false;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160; // end&#160;&#160;if (IsPermissionNeeded == true)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end synchronized ADKReceiverr)</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160; // end else for&#160;&#160;if (UsbManagerOBJ...</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end if (accessory != null)</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Log.d(TAG, &quot;mAccessory is null&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end else if (accessory != null)</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end onResume()</span></pre>
<p class="indent">Part 4 handles the programs auto-start functionality and the request of permissions when the application is started. When a device is plugged in, this code receives information from the operating system&#x2019;s event broadcast and will ask the user to grant permission to use the application with the accessory. If the program is started by the user and not by a system event, the permission is assumed.</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 4 of 7</p>
<pre><span class="FontName2">private BroadcastReceiver ADKReceiver = new BroadcastReceiver() {</span><br />&#160;<span class="FontName2">@Override</span><br />&#160;<span class="FontName2">public void onReceive(Context context, Intent intent) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">String action = intent.getAction();</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">if (ACTION_USB_PERMISSION.equals(action) == true) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">synchronized (this) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">UsbAccessory accessory = UsbManager.getAccessory(intent);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">openAccessory(accessory);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Log.d(TAG, &quot;permission denied for accessory &quot;+ accessory);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">IsPermissionNeeded = true;</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160;// end synchronized (this)</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end if (ACTION_USB_PERMISSION.equals...</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">else if (UsbManager.ACTION_USB_ACCESSORY_DETACHED.equals(action)) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">UsbAccessory accessory = UsbManager.getAccessory(intent);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (accessory != null &#x0026;&#x0026; accessory.equals(ARDUINO_ADK)) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">closeAccessory();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">} // end else if (UsbManager...</span><br />&#160;<span class="FontName2">}&#160;&#160;&#160;&#160; // end void onReceive(Context contex ...</span><br /><span class="FontName2">};&#160;&#160;&#160;&#160; // end private BroadcastReceiver..</span><br /><br /><span class="FontName2">@Override</span><br /><span class="FontName2">public Object onRetainNonConfigurationInstance() {</span><br />&#160;&#160; <span class="FontName2">if (ARDUINO_ADK != null) {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">return ARDUINO_ADK;</span><br />&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160; <span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">return super.onRetainNonConfigurationInstance();</span><br />&#160;&#160; <span class="FontName2">}</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;// end public Object&#160;&#160;onRetainNon*...</span></pre>
<p class="indent">Part 5 sets up the accessory to be used and handled by the program with the registration of the accessory object and the I/O streams. This section defines what needs to be done when opening and closing the accessory.</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 5 of 7</p>
<pre><span class="FontName2">private void openAccessory(UsbAccessory accessory) {</span><br />&#160;&#160; <span class="FontName2">ADKstreamObj = UsbManagerOBJ.openAccessory(accessory);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (ADKstreamObj != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ARDUINO_ADK = accessory;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">FileDescriptor fd = ADKstreamObj.getFileDescriptor();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ReciveFromADK = new FileInputStream(fd);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SendtoADK = new FileOutputStream(fd);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Log.d(TAG, &quot;accessory opened&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">} // end if (ADKstreamObj</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Log.d(TAG, &quot;accessory open fail&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end void openAccessory...</span><br /><span class="FontName2">private void setupAccessory() {</span><br />&#160;&#160; <span class="FontName2">UsbManagerOBJ = UsbManager.getInstance(this);</span><br />&#160;&#160; <span class="FontName2">Needed_Permission = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);</span><br />&#160;&#160; <span class="FontName2">IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);</span><br />&#160;&#160; <span class="FontName2">filter.addAction(UsbManager.ACTION_USB_ACCESSORY_DETACHED);</span><br />&#160;&#160; <span class="FontName2">registerReceiver(ADKReceiver, filter);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (getLastNonConfigurationInstance() != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">ARDUINO_ADK = (UsbAccessory) getLastNonConfigurationInstance();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">openAccessory(ARDUINO_ADK);</span><br />&#160;&#160; <span class="FontName2">}</span><br /><span class="FontName2">} // end private void setupAccessory()</span><br /><span class="FontName2">private void closeAccessory() {</span><br />&#160;&#160; <span class="FontName2">try {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (ADKstreamObj != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ADKstreamObj.close();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160; <span class="FontName2">}// end try</span><br />&#160;&#160; <span class="FontName2">catch (IOException e) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Log.e(TAG, &quot;IO Exception&quot;, e);</span><br />&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160; <span class="FontName2">finally {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ADKstreamObj = null;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ARDUINO_ADK = null;</span><br />&#160;&#160; <span class="FontName2">}&#160;&#160;&#160;&#160;// end of all try catch finally</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160; // end private void closeAccessory()</span></pre>
<p class="indent">Part 6 contains a function that writes data to the output file stream that can be read by the Mega ADK board&#x2019;s programming. For this example, only the output direction has been created. The <span class="FontName2">write</span> function accepts an array of bytes of any size and will send all the bytes contained in the array; there is no need to define an amount&#x2014;the whole array is sent.</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 6 of 7</p>
<pre><span class="FontName2">private void write(byte[] send){</span><br />&#160;&#160; <span class="FontName2">if (SendtoADK != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">try {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SendtoADK.write(send);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">catch (IOException e){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Log.e(TAG, &quot;write failed&quot;, e);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160; <span class="FontName2">}// end if (SendtoADK != null)</span><br /><span class="FontName2">}// end private void write...</span></pre>
<p class="indent">Part 7 is where the code performs functions based upon user interaction and later actions performed by the Mega ADK. For the program to be able to interact with user interface objects (such as showing dynamic information or reading object information), the objects need to be registered. The <span class="FontName2">registerUIobjects</span> function is responsible for the registration; it finds the ID of the desired object and sets it to the variable created in the beginning of the class. The variable is not defined in the function because other functions will need to use the objects.</p>
<p class="indent">The <span class="FontName2">blinkLED</span> function is run every time the toggle button is pressed. This function creates an array of 1 byte that is set based upon what state the toggle button is in. The toggle button&#x2019;s state is handled by the widget class, so code does not need to be added. Once the array value is set, the <span class="FontName2">write</span> function is called to send the byte to the Arduino. Any number of buttons can be created to send any amount of data (for example, to create a directional pad to use an Android device as a robot controller).</p>
<p class="noindent2"><b><i>Listing 4-6.</i></b>&#160;&#160;CH4ExamplesActivity.java, Part 7 of 7</p>
<pre><span class="FontName2">private void registerUIobjects(){</span><br />&#160;&#160; <span class="FontName2">buttonLED = (ToggleButton) findViewById(R.id.toggleButtonLED);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">public void blinkLED(View v) {</span><br />&#160;&#160; <span class="FontName2">byte[] BytestoSend = new byte[1];</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (buttonLED.isChecked())</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">BytestoSend[0] = (byte) 1; // button shows current LED State &quot;ON&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">BytestoSend[0] = (byte) 0; // button shows current LED State &quot;OFF&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">write(BytestoSend); // sends the byte to the ADK</span><br /><span class="FontName2">} // end void blinkLED(View v)</span><br /><span class="FontName2">} // end public class CH4ExamplesActivity</span></pre>
</div>
<div>
<p id="Sec14" class="Heading3">Verifying the Code<a id="cXXX.177" /></p>
<p class="noindent">Now that both parts of the example are complete, the Mega ADK board should already have the sketch from <a href="#list1">Listing 4-1</a> installed. The code for the Android needs to be installed on a supporting device. You can accomplish this by running the application from the Eclipse IDE with the Android device connected via the ADB or by manually installing it from the <span class="FontName2">.apk</span> file located in the <span class="FontName2">bin</span> folder of the <span class="FontName2">workspace/</span> <i>project name</i> folder. When the application is installed on the Android device, make sure that it can run; it will automatically start if the program was installed by Eclipse. The program will have a single button centered on the screen; the button will be in the off state.</p>
<p class="indent">Close the program for now and plug the Mega ADK into the computer to power the board. For debugging on the Arduino side, start the serial monitor at 115200 baud. After the Arduino is powered on, plug the Android device into the host side with the appropriate USB cable (in most circumstances, the cable used to charge the device will work). If all is working, a pop-up should appear on the Android screen asking for permission to start the application shortly after the board is plugged in. If the pop-up does not appear, try pressing the reset button on the Arduino or reconnecting the USB cable to the Android device.</p>
<p class="indent">Once the program is running, the toggle button should now be able to turn the LED off and on over the USB connection. The serial monitor should have printed the connection initiation and should echo a <span class="FontName2">1</span> or <span class="FontName2">0</span> every time the toggle button is pressed. If the ADB is available over wireless, type <span class="FontName2">adb logcat</span> into a terminal and check the printing log for mentions of the <span class="FontName2">MEGA_ADK</span> program.</p>
</div></div>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;If using completed Android project from Apress check that the Build target is GoogleAPIs API level 10 located in Project <img src="images/arrow.jpg" alt="image" /> Properties <img src="images/arrow.jpg" alt="image" /> Android <img src="images/arrow.jpg" alt="image" /> Build target.</p>
</div>
<p id="Sec15" class="Heading1">Completing the Framework</p>
<p class="noindent">Now that Arduino and Android have been introduced to each other, the next example expands on the code from last example. The next example uses the same project and introduces the handling of two-way communication by creating an ADK monitor with similar functionality to the serial monitor included with the Arduino IDE.</p>
<p class="indent">The ability to send data is already complete and handled by the <span class="FontName2">write</span> function. The ability to receive data is not as straightforward. Because the code is event driven and normally responds to user interaction, a type of continuous loop needs to be created that does not interfere with the rest of the program. This is accomplished by implementing a thread that will listen to the incoming file stream for new data and call a function so that the data can be worked with. To implement a thread, we need to create and start a <span class="FontName2">Runnable</span> class<a id="cXXX.178" />, so add <span class="FontName2">implements Runnable</span> to the end of the activity declaration just before the starting curly brace and after <span class="FontName2">extends Activity</span> making the class declaration read as.</p>
<pre><span class="FontName2">public class CH4ExamplesActivity extends Activity implements Runnable {</span></pre>
<p class="indent">The thread needs to be created and started. This is done in the <span class="FontName2">openAccessory</span> function<a id="cXXX.179" /> located in part 5 <a href="#list6">Listing 4-6</a>. The two lines of code in <a href="#list7" id="_list7">Listing 4-7</a> are placed between the following existing lines:</p>
<pre><span class="FontName2">SendtoADK = new FileOutputStream(fd);</span><br /><span class="FontName2">Log.d(TAG, &quot;accessory opened&quot;);</span></pre>
<p class="indent">The new lines of code will start a function named <span class="FontName2">run</span> in the current class every time the <span class="FontName2">openAccessory</span> function is executed.</p>
<p class="noindent2"><a href="#_list7" id="list7"><b><i>Listing 4-7.</i></b></a>&#160;&#160;New Lines for the openAccessory Function</p>
<pre><span class="FontName2">Thread ADKreadthread = new Thread(null, this, &quot;ADK_Read_Thread&quot;);</span><br /><span class="FontName2">ADKreadthread.start();</span></pre>
<p class="indent">The <span class="FontName2">run</span> function<a id="cXXX.180" /> needs to be defined within the class and can be added below the <span class="FontName2">write</span> function<a id="cXXX.181" /> of part 6 <a href="#list6">Listing 4-6</a>. The functions must be named <span class="FontName2">run</span> because of the abstraction from the runnable class. The new function<a id="cXXX.182" /> is as described in <a href="#list8" id="_list8">Listing 4-8</a>. The function normally would execute once and end as a separate thread from the original program. In this case, it needs to run in a continuous loop, so we create a <span class="FontName2">while (true)</span> loop. Under normal circumstances, once a loop of this nature is encountered, the rest of the program cannot continue to function until the loop is finished. However, this loop is in a separate place and acts as a different program from the main program, and allows for the rest of the code to execute as normal. This function constantly monitors the <span class="FontName2">ReceiveFromADK</span> data stream<a id="cXXX.183" /> for new information, places the data in a new data class, and informs a function that there is new data ready to be handled by the main program.</p>
<p class="noindent2"><a href="#_list8" id="list8"><b><i>Listing 4-8.</i></b></a>&#160;&#160;New Function to Constantly Check for New Incoming Data</p>
<pre><span class="FontName2">public void run() {</span><br /><span class="FontName2">int RevivedBytes&#160;&#160;= 0;</span><br />&#160;<span class="FontName2">while (true) { // run constantly</span><br />&#160;&#160;<span class="FontName2">byte[] buffer = new byte[80]; // max size capable is 16384 but slows the program down</span><br />&#160;&#160;<span class="FontName2">try {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">RevivedBytes = ReciveFromADK.read(buffer);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">catch (IOException e) {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">Log.e(TAG, &quot;Read failed&quot;, e);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">break;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if&#160;&#160;(RevivedBytes &#x003E;= 1 ) {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">Message MakeBufferTransferable = Message.obtain(IncomingDataHandler);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">MakeBufferTransferable.obj = new BufferData( buffer ,RevivedBytes);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">IncomingDataHandler.sendMessage(MakeBufferTransferable);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;<span class="FontName2">}// end while</span><br /><span class="FontName2">}// end public void run()</span></pre>
<p class="noindent">A new data class has to be created to efficiently pass information from the thread to a receiving function. The class is created outside of the current Java file but still within the same package. Right-click the package name <span class="FontName2">ch4.example.proArduino</span> and select a new file to bring up a wizard, and enter the name <span class="FontName2">BufferData.java</span> for the newly created file. This new file will contain the <span class="FontName2">BufferData</span><a id="cXXX.82a" /> class called by <span class="FontName2">run</span> and used for a data handler. The class declares two variables and has three functions; the variables are for the buffer and the amount of revived bytes. The first function takes both values in at once and stores them in the appropriate variable. The next two functions will return one of the two variables depending on the functions called. The class is outlined in <a href="#list9" id="_list9">Listing 4-9</a> because this file is part of the same package&#x2014;the class does not need to be imported.</p>
<p class="noindent2"><a href="#_list9" id="list9"><b><i>Listing 4-9.</i></b></a>&#160;&#160;Buffer Data Container Class<a id="cXXX.184" /></p>
<pre><span class="FontName2">package ch4.example.proArduino;</span><br />&#160;<span class="FontName2">public class BufferData {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">private byte[] Buffer;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">private int length;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">public BufferData ( byte[] Buffer , int length) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">this.Buffer = Buffer;&#160;&#160; // set data to variables</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">this.length = length;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">public byte[] getBuffer() {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">return Buffer;&#160;&#160; // set data out</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">public int getLength(){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">return length; // set data out</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;<span class="FontName2">}// end BufferData</span></pre>
<p class="indent">The last thing needed to complete the framework for use in this application or other applications is a handler. This mechanism allows the rest of the program to work with the incoming data. The handler is included via an Android class and needs to be imported along with a message class so that <span class="FontName2">run</span> can notify the main program of changes. The <a href="#list10" id="_list10">Listing 4-10</a> shows the two import lines that need to be added to the import section at the beginning of the file.</p>
<p class="noindent2"><a href="#_list10" id="list10"><b><i>Listing 4-10.</i></b></a>&#160;&#160;Two New Lines for the Import Section</p>
<pre>&#160;<span class="FontName2">import android.os.Handler;</span><br />&#160;<span class="FontName2">import android.os.Message;</span></pre>
<p class="indent">For convenience, the function to be created in <a href="#list11" id="_list11">Listing 4-11</a> that uses the two new classes will be placed toward the end of the main file, or what was part 7 in <a href="#list6">Listing 4-6</a>, just after the <span class="FontName2">registerUIobjects</span> function. The placement is important because the handler function is heavily modified between different projects. This function is wrapped inside of a class of type <span class="FontName2">Handler</span> and overrides the original class function of <span class="FontName2">handleMessage</span>. The original functionality of <span class="FontName2">handleMessage</span> is not needed and not included with a call to <span class="FontName2">super.&#x003C;functions name&#x003E;</span>. The function <span class="FontName2">handleMessage</span><a id="cXXX.185" /> links the data sent from <span class="FontName2">run</span> to a new <span class="FontName2">BufferData</span> object. At this point, the framework is complete and ready for the development of the rest of the program. To prep the data for the user, the code converts the <span class="FontName2">BufferData</span> to a string and appends the string to an <span class="FontName2">editText</span> widget for display.</p>
<p class="noindent2"><a href="#_list11" id="list11"><b><i>Listing 4-11.</i></b></a>&#160;&#160;The Last Part of the Framework</p>
<pre><span class="FontName2">Handler IncomingDataHandler = new Handler() {</span><br />&#160;<span class="FontName2">@Override</span><br />&#160;<span class="FontName2">public void handleMessage(Message msg) {</span><br />&#160;<span class="FontName2">BufferData IncomingBuffer = (BufferData) msg.obj;</span><br />&#160;<span class="FontName2">// after this point the data is available for manipulation</span><br />&#160;&#160; <span class="FontName2">String str = new String(IncomingBuffer.getBuffer());</span><br />&#160;&#160; <span class="FontName2">DataFromArduino.append(str);</span><br />&#160;<span class="FontName2">}// end handleMessage(Message msg)</span><br /><span class="FontName2">}; // end Handler IncomingDataHandler = new Handler()</span></pre>
<div>
<p id="Sec16" class="Heading2">Completing the Application</p>
<p class="noindent">Now that the framework is complete, the rest of this section focuses on the creation of a serial monitor<a id="cXXX.186" /> replica for use with the ADK protocol. The best place to start is with the user interface to get a feel for how the interaction will work, and at the same time prepare the resources to link to the Java portion of the application. The Arduino IDE has a serial monitor for ease of development; it is capable of printing any information at specified points in the code, and it is also capable of sending data to the Arduino. The application for the ADK side has to mimic the same functionality as the serial monitor. Two different text boxes are used: one for incoming data and one for outgoing; a single button is used to send the data from the outgoing text box. At bare minimum, three objects are needed to create the same user interface experience: two Android <span class="FontName2">EditText</span> boxes<a id="cXXX.187" /> for the data and a regular button to send. To add a little extra flair, the program includes a second button for clearing the data in the user interface.</p>
<p class="indent"><a href="#Fig6" id="_Fig6">Figure 4-6</a><a id="cXXX.188" /> shows what user interface layout was chosen for this application. The send and clear buttons are at the bottom right, the input box it placed next to them at the bottom left, and the rest of the screen is filled with the data-revived box. For simplicity, the autoscroll is not implemented along with the line-ending options or the baud select. The <span class="FontName2">TextEdit</span> boxes automatically wrap the characters to a new line when used in a multiple-line configuration, as is need for the incoming data box, and will scroll automatically when the end of the box is reached. There is no speed setting because the ADK protocol&#x2019;s speed is set globally for all accessory devices. <a href="#list12" id="_list12">Listing 4-12</a> shows the <span class="FontName2">main.xml</span> file that produces the user interface shown in <a href="#Fig6">Figure 4-6</a>. There are a few settings for each object. To better describe each of the objects, the example is divided it to three parts, ordered as they appear in the XML file. The XML file for <a href="#list12">Listing 4-12</a> replaces that used for the prior examples.</p>
<div class="Figure" id="Fig6">
<p class="img"><img src="images/9781430239390_Fig04-06.jpg" alt="9781430239390_Fig04-06.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig6">Figure 4-6</a></span> .&#160;&#160;Layout for the ADK monitor </p>
</div>
<p class="indent">Part 1 of the XML file describes the overall layout style and the first <span class="FontName2">EditText</span> box along with the associated information, such as IDs, fill, location, and relative layout type. The ID for the first <span class="FontName2">EditText</span> box is <span class="FontName2">incomingData</span>. Because there is no need for the incoming-data box to be edited, the flags after the ID and positional definitions for this <span class="FontName2">EditText</span> box are set to turn off this functionality. The options for focus, cursor viability, and click ability of the box are turned off by setting the associated Android flags to <span class="FontName2">false</span>. The next two options set a scroll bar to show when the text has gone past the box&#x2019;s bottom edge. The gravity is set to the top so the incoming text does not sit centered. The flag <span class="FontName2">android:inputType</span><a id="cXXX.189" /> sets two options, telling the code that this box is a multiline box and that the spell check needs to be turned off and not show any spelling suggestions. The last flag sets the hint to a string located in the <span class="FontName2">strings.xml</span> file.</p>
<p class="noindent2"><a href="#_list12" id="list12"><b><i>Listing 4-12.</i></b></a>&#160;&#160;main.xml<a id="cXXX.190" />, Part 1 of 3</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;RelativeLayout xmlns:android=&quot;</span><span class="FontName2"><span class="FontName2"><a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a></span></span><span class="FontName2">&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/relativeLayout1&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_weight=&quot;0.72&quot; &#x003E;</span><br /><span class="FontName2">&#x003C;EditText</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:id=&quot;@+id/incomingData&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_above=&quot;@+id/outgoingData&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentLeft=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentRight=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentTop=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:clickable=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:cursorVisible=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:focusable=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:focusableInTouchMode=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:scrollbars=&quot;vertical&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:gravity=&quot;top&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:inputType=&quot;textMultiLine|textNoSuggestions&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:hint=&quot;@string/hint&quot; &#x003E;</span><br /><span class="FontName2">&#x003C;/EditText&#x003E;</span></pre>
<p class="indent">Part 2 describes the <span class="FontName2">EditText</span> box, which is to be used as the output box to send data to the Arduino. The box will be identifiable to the code as <span class="FontName2">outgoingData</span>. The size is not described as absolute, as in the blink example, but as dynamic compared to the other objects&#x2014;this user interface will always use the available screen no matter the size. The hint for this box is also set in the <span class="FontName2">strings.xml</span> file. Finally the input type is defined as text. This is a single-line input box with the overflow continuing to scroll horizontally. This box also turns off the spell check.</p>
<p class="noindent2"><b><i>Listing 4-12.</i></b>&#160;&#160;main.xml, Part 2 of 3</p>
<pre><span class="FontName2">&#x003C;EditText</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:id=&quot;@+id/outgoingData&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentBottom=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentLeft=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_toLeftOf=&quot;@+id/sendbutton&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:hint=&quot;@string/sendhint&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:inputType=&quot;text|textNoSuggestions&quot; &#x003E;</span><br /><span class="FontName2">&#x003C;/EditText&#x003E;</span></pre>
<p class="indent">Part 3 describes the last two objects of the user interface: the buttons. These two buttons take up the reaming space at the bottom right of the screen, with the send button located closer to the input box. Both buttons are set up as the toggle button was in the blink example; the text of the button is linked to a string and the button is set up to call a function when it is pressed. As compared to the toggle button, these buttons are momentary and do not hold a changed state when released.</p>
<p class="noindent2"><b><i>Listing 4-12.</i></b>&#160;&#160;main.xml, Part 3 of 3</p>
<pre><span class="FontName2">&#x003C;Button</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:id=&quot;@+id/clear&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentBottom=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentRight=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:onClick=&quot;clearScreen&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:text=&quot;@string/clear&quot; &#x003E;</span><br /><span class="FontName2">&#x003C;/Button&#x003E;</span><br /><span class="FontName2">&#x003C;Button</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:id=&quot;@+id/sendbutton&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_alignParentBottom=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:layout_toLeftOf=&quot;@+id/clear&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:onClick=&quot;SendData&quot;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">android:text=&quot;@string/send&quot;</span><br /><span class="FontName2">&#x003C;/Button&#x003E;</span><br /><span class="FontName2">&#x003C;/RelativeLayout&#x003E;</span></pre>
<p class="indent">The <span class="FontName2">strings.xml</span> file<a id="cXXX.191" /> needs to be modified to contain the resources for the buttons and the <span class="FontName2">EditText</span> boxes; <a href="#list13" id="_list13">Listing 4-13</a> shows the required changes. The new <span class="FontName2">strings.xml</span> file contains five tags: the app name, two hints, and two button names. <span class="FontName2">strings.xml</span> is the only other XML file that needs to be modified for this example. <span class="FontName2">AndroidManifest.xml</span> and <span class="FontName2">accessory_filter.xml</span> are needed, but require no modification.</p>
<p class="noindent2"><a href="#_list13" id="list13"><b><i>Listing 4-13.</i></b></a>&#160;&#160;New strings.xml File</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;resources&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;app_name&quot;&#x003E;Mega ADK&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;hint&quot;&#x003E;Data from Arduino board will be displayed here&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;sendhint&quot;&#x003E;Type data to send&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;send&quot;&#x003E;Send&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;clear&quot;&#x003E;Clear&#x003C;/string&#x003E;</span><br /><span class="FontName2">&#x003C;/resources&#x003E;</span></pre>
<p class="indent">With the user interface finished, the code can be added to the main Java file to complete the functionality of the serial monitor clone. Two different objects are used and therefore need to be imported. The following lines of code need to replace the <span class="FontName2">import android.widget.ToggleButton;</span> line in the import section of <span class="FontName2">CH4ExamplesActivity.java</span>:</p>
<pre><span class="FontName2">import android.widget.Button;</span><br /><span class="FontName2">import android.widget.EditText;</span></pre>
<p class="indent">The toggle button is no longer needed for this example, and the variable declaration can be replaced by the following four lines of code in the variable section inside the class:</p>
<pre><span class="FontName2">private Button buttonSend;</span><br /><span class="FontName2">private Button ScreenClear;</span><br /><span class="FontName2">private EditText DataFromArduino;</span><br /><span class="FontName2">private EditText outgoingData ;</span></pre>
<p class="indent"><a href="#list14" id="_list14">Listing 4-14</a> describes the last three functions needed to complete the application. The data-handling function<a id="cXXX.192" /> was described in <a href="#list11">Listing 4-11</a> and should already be located below the <span class="FontName2">registerUIobjects</span> function<a id="cXXX.193" /><a id="cXXX.194" />. The <span class="FontName2">IncomingDataHandler</span><a id="cXXX.195" /><a id="cXXX.196" /> is already to go and includes the code to print the data to the <span class="FontName2">EditText</span> box. The <span class="FontName2">EditText</span> box, along with the three other user interface objects, needs to be linked to the program by type casting the return value of the <span class="FontName2">findViewById</span> method; the type cast follows this format:</p>
<pre><span class="FontName2">(&#x003C;object type&#x003E;) findViewById(R.id.&#x003C;object ID&#x003E;);</span></pre>
<p class="indent">The <span class="FontName2">clearScreen</span><a id="cXXX.197" /> and <span class="FontName2">SendData</span> functions<a id="cXXX.198" /><a id="cXXX.199" /> are called when the user instates the event that is associated with the button in <span class="FontName2">main.xml</span>. When the <span class="FontName2">clearScreen</span> function is called, it sets the <span class="FontName2">EditText</span> box identified as <span class="FontName2">incomingData</span> back to the original sate by setting the text to <span class="FontName2">null</span>. The last function, <span class="FontName2">SendData</span>, grabs the text in <span class="FontName2">outgoingData</span> as a string and then converts that data to a byte array before calling the <span class="FontName2">write</span> function.</p>
<p class="noindent2"><a href="#_list14" id="list14"><b><i>Listing 4-14.</i></b></a>&#160;&#160;New and Edited Functions for CH4ExamplesActivity.java<a id="cXXX.200" /></p>
<pre>&#160;<span class="FontName2">private void registerUIobjects(){</span><br />&#160;&#160; <span class="FontName2">buttonSend = (Button) findViewById(R.id.sendbutton); // called in for other use, not</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// implemented</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ScreenClear = (Button) findViewById(R.id.clear);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// in this program</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DataFromArduino = (EditText)findViewById(R.id.incomingData);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">outgoingData =&#160;&#160;(EditText)findViewById(R.id.outgoingData);</span><br />&#160;<span class="FontName2">}&#160;&#160;&#160;&#160; // end registerUIobjects</span><br /><br />&#160;<span class="FontName2">//////////////////////////////////////////////</span><br />&#160;<span class="FontName2">// <a href="#list11">Listing 4-11</a> code is inserted inplace of this block</span><br />&#160;<span class="FontName2">//////////////////////////////////////////////</span><br /><br />&#160;<span class="FontName2">public void clearScreen (View v) {</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">DataFromArduino.setText(null);</span><br />&#160;<span class="FontName2">}&#160;&#160;&#160;&#160; // end clearScreen (View v)</span><br />&#160;<span class="FontName2">public void SendData(View v) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">String convert = outgoingData.getText().toString();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte[] BytestoSend = convert .getBytes();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">write(BytestoSend); // sends buffer to the ADK</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">outgoingData.setText(null);</span><br />&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;// end void SendData(View v)</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160; // end class CH4ExamplesActivity</span></pre>
<p class="indent">The Android application is ready to be installed after any possible errors are fixed. The Eclipse IDE throws two warnings for this code because the buttons are declared and initialized but not referenced elsewhere in the code. It is good practice to declare the buttons even if the attributes or functions of the object are not going to be used; having the objects all set up and ready helps keep track of the objects available. This program will respond to any accessory that has the proper identifiable information, and will take the incoming bytes and print the value as related to ASCII&#x2014;a value of <span class="FontName2">0x61</span> sent will print an <i>a</i>. The Android app is ready to accept incoming messages from any Arduino sketch that is using the <span class="FontName2">AndroidAccessory.h</span><a id="cXXX.201" /> library, giving the same feeling as the serial functions.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;The <span class="FontName2">AndroidAccessory.h</span> functions replicate the serial functions and inherit the functionality of <span class="FontName2">print</span> and <span class="FontName2">println</span>, and offer formatting options such as <span class="FontName2">BIN</span>, <span class="FontName2">DEC</span>, and <span class="FontName2">HEX</span>.</p>
</div>
</div>
<div>
<p id="Sec17" class="Heading2">Arduino<a id="cXXX.202" /></p>
<p class="noindent">The Arduino could be left up to the imagination at this point, but the next example sets up a quick echo from the serial monitor to the ADK application and vice versa. This is handled by two <span class="FontName2">while</span> loops that will write the incoming data when available from one side to the other. This example does not require any extra hardware connected to the pins on the Arduino.</p>
<p class="indent">Load the sketch in <a href="#list15" id="_list15">Listing 4-15</a> to the Arduino Mega ADK.</p>
<p class="noindent2"><a href="#_list15" id="list15"><b><i>Listing 4-15.</i></b></a>&#160;&#160;Modified Software Serial Sketch to Link the Echo Serial to the ADK and Vice Versa</p>
<pre><span class="FontName2">#include &#x003C;AndroidAccessory.h&#x003E;</span><br /><span class="FontName2">AndroidAccessory ADK(&quot;Manufacturer&quot;, &quot;Model&quot;, &quot;Description&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">&quot;1.0&quot;, &quot;Pro Arduino&quot;, &quot;0000000012345678&quot;);</span><br /><span class="FontName2">void setup() {</span><br />&#160;&#160; <span class="FontName2">Serial.begin(115200);</span><br />&#160;&#160; <span class="FontName2">ADK.begin();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop() {</span><br />&#160;&#160; <span class="FontName2">if (ADK.isConnected()) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">while ( Serial.available() &#x003E; 0){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ADK.write (Serial.read());</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">while ( ADK.available() &#x003E; 0){</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">Serial.write(ADK.read());</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160; <span class="FontName2">}&#160;&#160; // end if (ADK.isConnected)</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end loop</span></pre>
</div>
<div>
<p id="Sec18" class="Heading2">Verifying the Code</p>
<p class="noindent">With the application on the Android device and the sketch installed on the Arduino, plug the USB from the computer into the Arduino and start a serial monitor at baud 115200. Once the monitor is ready, make sure that the application is not currently open on the Android device and plug the Mega ADK host side into the Android USB. The application should automatically ask for permission to start with the attached accessory. If after a few second the pop-up does not appear, try reconnecting the USB on the Android side or pressing the reset button on the Arduino. Once the program starts, the serial monitor should have printed some connection information, and data can be entered into either side&#x2019;s input boxes and sent, and should appear on the output box on the other device.</p>
</div>
<p id="Sec19" class="Heading1">SPI<a id="cXXX.203" /> and ADK</p>
<p class="noindent">On the Mega ADK, as with other shields, the functionality to allow for the communication happens through a USB host processor that uses the SPI protocol to communicate with the microcontroller. To demonstrate that other SPI-capable devices still work with the ADK quite effectively, this last example reads a file from an SD card connected to the Mega ADK board and prints the contents to the ADK monitor installed on the Android device. <a href="#list16">Listing 4-16</a> requires an SD card and an SD breakout board. The SD board that was used in the development of this example was the microSD breakout made by Adafruit Industries (<span class="FontName2"><a href="http://www.adafruit.com/products/254">www.adafruit.com/products/254</a></span>) and was chosen for its level-conversion feature, which converts from 5V to 3.3V logic and has the form factor of a breakout instead of a shield. A microSD card will also be needed for the Adafruit board. If a different SD board is currently available, there is no need to get the Adafruit board, provided your board has the capability to directly connect to the correct SPI pins. Shields for Atmel 328&#x2013;based Arduino boards, such as the UNO, will not work because of the different SPI pin location.</p>
<p class="indent"><a href="#list16">Listing 4-16</a> is an Arduino sketch and uses the same Android application developed in the first example in this chapter. The Mega ADK needs to be connected to the SD breakout board as described in <a href="#Fig7" id="_Fig7">Figure 4-7</a>. The pins marked DO (data out), DI (data in) and Clk (clock) on the SD breakout are connected to the MISO, MOSI, and SCK pins on the Arduino Mega ADK board. Also on the SD breakout, the pin marked CS (chip select) is connected to pin 10 on the Arduino. The power pins complete the setup, with 5V to 5V and ground to ground.</p>
<div class="Figure" id="Fig7">
<p class="img"><img src="images/9781430239390_Fig04-07.jpg" alt="9781430239390_Fig04-07.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig7">Figure 4-7</a></span> .&#160;&#160;Layout for the ADK monitor </p>
</div>
<p class="indent">The sketch created in <a href="#list16">Listing 4-16</a> uses two libraries, <span class="FontName2">SD.h</span> and <span class="FontName2">AndroidAccessory.h</span>; to solve any pin definition conflicts the <span class="FontName2">SD.h</span> library need to be included first. A byte array of 80 elements is created to buffer the data gathered from the SD file before sending to the Android device. This is done to speed up the transfer, accommodating for both devices on the SPI bus. The accessory object is defined in the same way as in the other examples. Once the code enters the setup function, the ADK object is started and waits for the connection to be ready before proceeding to start the SD reader. Waiting for the connection to be fully operational allows for the information about the setup of the SD reader to be caught and printed to the Android application. The loop function checks for the connection and will try to reestablish the connection if disconnected. The code waits for a defined incoming character from the Android before opening and reading the test file on the SD card to the buffer. If the file is not available, an error is printed in the Android application. Step through <a href="#list16" id="_list16">Listing 4-16</a> and upload it to the Mega ADK board.</p>
<p class="noindent2"><a href="#_list16" id="list16"><b><i>Listing 4-16.</i></b></a>&#160;&#160;Arduino SD Reader<a id="cXXX.204" /> and ADK Sketch</p>
<pre><span class="FontName2">#include &#x003C;SD.h&#x003E; // must be included before AndroidAccessory.h</span><br /><span class="FontName2">#include &#x003C;AndroidAccessory.h&#x003E; // needed library to work with ADK connections</span><br />&#160;&#160;<span class="FontName2">byte buffer[80];</span><br />&#160;&#160;<span class="FontName2">// initialize the accessory object with identifying data</span><br />&#160;&#160;<span class="FontName2">AndroidAccessory ADK(&quot;Manufacturer&quot;, &quot;Model&quot;, &quot;Description&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;1.0&quot;, &quot;Pro Arduino&quot;, &quot;0000000012345678&quot;);</span><br /><span class="FontName2">void setup() {</span><br />&#160;&#160;<span class="FontName2">ADK.begin();&#160;&#160;&#160;&#160; // start the connection to the Android</span><br />&#160;&#160;<span class="FontName2">while(!ADK.isConnected());&#160;&#160; // wait till the ADK is connected to finish setup</span><br />&#160;&#160;<span class="FontName2">pinMode(10, OUTPUT);&#160;&#160; // SD chip select</span><br />&#160;&#160;<span class="FontName2">if (!SD.begin(10)) {&#160;&#160;&#160;&#160;// start the SD and check for failure</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ADK.println(&quot;SD initialization failed!&quot;);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ADK.println(&quot;SD initialization done.&quot;);</span><br /><span class="FontName2">}&#160;&#160;// end setup</span><br /><span class="FontName2">void loop() {</span><br />&#160;&#160;<span class="FontName2">if (ADK.isConnected()) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // check for connection</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (ADK.available() &#x003E; 0){&#160;&#160;&#160;&#160;&#160;&#160;//check for incoming data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (ADK.read() == &#x0027;a&#x0027;) {&#160;&#160;&#160;&#160; // look for an incoming &#x0027;a&#x0027; to start file transfer</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">File TestFile = SD.open(&quot;test.txt&quot;);&#160;&#160;&#160;&#160;// open the test.txt</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (TestFile) { // if file did not open, throw an error</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">while (TestFile.available()) { // read till the file end has been reached</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; 80 ; i ++ ){ // read 80 bytes into buffer before sending</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">buffer[i] = TestFile.read();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ADK.write (buffer , 80); // send buffer to the Android</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">} // end while (TestFile.available())</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">TestFile.close(); // close the file no longer needed</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;// end if (TestFile)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">else{</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">ADK.println (&quot;File Error&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;// end if (ADK.read() == &#x0027;a&#x0027;)</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;// end if (ADK .available() &#x003E; 0)</span><br />&#160;&#160;<span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;// end if (ADK .isConnected())...</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// end void loop()</span></pre>
<p class="indent">Once the Arduino is configured with the SD reader and programmed with the sketch, a <span class="FontName2">test.txt</span> file must be created and located in the root directory of a FAT-formatted SD card. Copy any text readme file to the SD card from a computer and rename it <span class="FontName2">test.txt</span> on the SD card. Plug the Arduino into the Android device, insert the SD card into the reader, and power it on.</p>
<p class="indent">When the ADK application starts, the status of the SD initialization should be printed to the screen. You should see that the SD card has been found and is ready to use. If it fails, recheck the connections or reinsert the card. When the initialization is done, type <span class="FontName2">a</span> into the input box and press send. The <span class="FontName2">text.txt</span> file should start printing; the whole file will be printed 80 bytes at a time. If the file size does not divide evenly by 80 bytes, the last transmission will contain and print garbage characters in the bytes the file does not fill. This sketch&#x2019;s methods can be useful for pulling logs from a sensor network or interfacing with other SPI devices, such as the Ethernet shield, with modifications to work with the Mega-style pin out.</p>
<p id="Sec20" class="Heading1">Summary</p>
<p class="noindent">The world of Android-to-Arduino accessory development is now available to be further explored. Any Arduino code that outputs through a serial connection can output to the ADK by including the <span class="FontName2">AndroidAccessory.h</span> library and making a few changes to the serial references in any existing code.</p>
<p class="indent">This chapter demonstrated some of the basic workings of the Arduino Mega ADK. For further reading and more in-depth information, check out the Android Developers web site (<span class="FontName2"><a href="http://developer.android.com">http://developer.android.com</a></span>) and <i>Beginning Android ADK with Arduino</i>, by Mario B&#x00F6;hmer (Apress, 2012).</p>
<p class="indent">This chapter described how to create a framework that can be used as a starting point for any Android application that connects to an accessory device, along with a tool that is helpful for debugging. With the ADK, you can build smarter robots, cooler blinking devices, and more dynamic art installations without having to lug around a bulky laptop. It is even possible to develop an IDE to program other Arduinos from an Android device connected through the Mega ADK. Aside from hardware constraints, imagination is the limit.</p>
<p class="indent">The software used in this chapter is sometimes a bit buggy and isn&#x2019;t supported on all devices because of their relative ages. As newer Android devices become available, support will increase, making it easier to develop accessories for a broader market. The open hardware community has done a wonderful job of adopting this new technology, with an ever-increasing number of development boards available&#x2014;from the IOIO to the Mega ADK. The community of developers has also kept up on the software; for example, when version 1.0 of the Arduino IDE was released, the accessory library was difficult to work with and required some changes; now the Accessory library is as simple to work with as serial and is continually improved upon.</p>
</div></div>
</body>
</html>