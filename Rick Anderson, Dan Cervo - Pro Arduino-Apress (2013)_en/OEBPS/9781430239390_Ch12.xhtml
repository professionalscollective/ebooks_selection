<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 12 Writing Your Own Arduino Libraries</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap12" />CHAPTER 12</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">Writing Your Own Arduino Libraries</p>
<div>
<p class="noindent">Arduino libraries are written in standard C/C++ code and contain either a set of useful functions or an object that is initialized and used in Arduino sketches. The advantage of this is that you can share these libraries across your own projects and with other users. In this chapter, we will create an example &#x201C;Hello World&#x201D; library, a Motor control library, and a more complex DS1631 I2C temperature sensor library.</p>
<p id="Sec1" class="Heading1">What you need to know to write your own libraries</p>
<p class="noindent">The choice to program libraries in C or C++ is up to you. Standard C works when using the Arduino library conventions. If you plan to use <span class="FontName2">structs</span> and <span class="FontName2">enum</span> variables you will have to place them in a header file.</p>
<p class="indent">C++<a id="cXXX.507" /> gives you the ability to create objects, but since we are working with an 8-bit MCU, there is limited memory space and usually little or no memory management. Make sure to test your code for memory use and heap fragmentation. Remember that not everything must be an object; it is acceptable to have a set of functions that you use as libraries without writing them from scratch for each sketch.</p>
<p class="indent">The major difference between Arduino sketches<a id="cXXX.508" /> and Arduino libraries is that a sketch is pre-processed, meaning that you do not have to prototype your functions or write a header file for your main sketch. For this reason, a sketch is easy to use and a good starting place for beginners. Libraries, on the other hand, have to conform to the full rules of C/C++. The C/C++ compiler is powerful, but if you use functions, and variables before they are defined, the compiler will indicate an error and ultimately fail. A helpful metaphor is the idea of enrolling a course that has a required prerequisite, but the system cannot identify what the prerequisite is.</p>
<p class="indent">A compiler reads from the top of the file to the bottom. If any variables or functions depend on others and one is not defined, an error occurs. These prototypes and header files are a list of all the functions and variables used in the sketch and library code. The only solution is to place a prototype of your function at the top of your sketch or in the header file. For example, let&#x2019;s say you a have a function that adds two integers. The prototype would be:</p>
<pre><span class="FontName2">int add(int aa, int bb);</span></pre>
<p class="indent">The prototype<a id="cXXX.509" /> needs only minimal information about return type, function name, and expected types that it will encounter.&#160;&#160;The implementation, on the other hand, can be done any way that follows the rules set by the prototype.</p>
<pre><span class="FontName2">int add(int aa, int bb) {</span><br />&#160;<span class="FontName2">int res = aa + bb;</span><br />&#160;<span class="FontName2">return res;</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Another valid implementation:</p>
<pre><span class="FontName2">int add(int aa, int bb) {</span><br />&#160;<span class="FontName2">return aa + bb;</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Preprocessing scans<a id="cXXX.510" /> the sketch for functions and libraries that are included in your sketch. This process generates a file that ends in the <span class="FontName2">.h</span> extension&#x2014;the standard extension for a header file. Arduino does that for you, but libraries require a header file and an implementation file. The header file is a list of all the function signatures, including the return type, function name, and the function parameters. In certain cases, you will need to use in-line functions in order to an optimizing goal. If you are defining your library as a C++ object, you should including the following information in the header file: what the object inherits from, the object class name, when functions are members of the class, and whether these functions are public or private.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Arduino IDE forces the implementation file to have the <i>*.cpp</i> extension. If you use <i>*.c</i>, you will get errors.</p></div>
<p class="indent">One reason you may opt for a C function rather than a C++ object has to do with the potentiometer. In order to read a potentiometer<a id="cXXX.511" />, you issue a function like <span class="FontName2">analogRead(A0)</span>. If all you are doing is reading values from the potentiometer, you are already in good shape. Creating a single potentiometer as an object takes memory and can quite easily overcomplicate a simple read from a device. However, if you are trying to avoid a huge number of global variables, it makes sense to have a single object contain all of the information. If needed, you can create libraries just for a single sketch. If your code starts to take multiple pages and you are writing many helper functions, you can transfer that code into sketch-based libraries. Your project will load with all the library code together, and you&#x2019;ll see multiple tabs. Eventually, you may want to use those libraries in more than one project. To do so, you will need to separate each into their own library area and package them to install easily across the system. Header files can also be used to create hardware profile<a id="cXXX.512" />s. The pins indicate what is used for custom shields, breadboard circuits, and even custom Arduino-compatible boards. This would allow for portable code between hardware devices and configurations.</p>
<p class="indent"><a href="#Fig1" id="_Fig1">Figure 12-1</a> shows the <span class="FontName2">#include &quot;HardwareProfile.h&quot;</span>, which pulls in the header file <span class="FontName2">HardwareProfiles.h</span>. In this file, you can define custom variables for a piece of hardware and set their default values.</p>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig12-01.jpg" alt="9781430239390_Fig12-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 12-1</a>. </span>Hardware Profile included into an Arduino Sketch </p>
</div>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 12-1.</i></b></a>&#160;&#160;Example defines in HardwareProfile.h<a id="cXXX.513" /></p>
<pre><span class="FontName2">#define motor1Dir 7</span><br /><span class="FontName2">#define motor2Dir 8</span><br /><span class="FontName2">#define motor1PWM 9</span><br /><span class="FontName2">#define motor2PWM 10</span><br /><span class="FontName2">#define motor1Enable 11</span><br /><span class="FontName2">#define motor2Enable 12</span></pre>
<p class="indent"><a href="#list1" id="_list1">Listing 12-1</a> shows a set of pins defined from the Motor Library example. This guarantees that you use the correct pins every time you work with the same hardware. If you need to change from the default pins, you can redefine the pin numbers in your sketch.</p>
<div>
<p id="Sec2" class="Heading2">Creating a simple library</p>
<p class="noindent">There are typically two &#x201C;Hello World&#x201D; programs<a id="cXXX.514" /> for Arduino. One blinks an LED on and off, and the other sends a <span class="FontName2">&quot;Hello, World!&quot;</span> message over the serial connection. Here, we will convert the sketch into a simple library. <a href="#Fig2" id="_Fig2">Figure 12-2</a> shows a visualization<a id="cXXX.515" /> of the library, implementation, and sketch file that we are creating.</p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig12-02.jpg" alt="9781430239390_Fig12-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 12-2</a>. </span>SimpleHello.ino<a id="cXXX.518" /> sketch and code layout </p>
</div>
<p class="indent">The starter sketch<a id="cXXX.516" /> for this is example is <a href="#list2" id="_list2">Listing 12-2</a>.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 12-2.</i></b></a>&#160;&#160;Initial sketch code</p>
<pre><span class="FontName2">const int LED_PIN = 13;</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">pinMode(LED_PIN, OUTPUT);</span><br /><span class="FontName2">}</span><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.println(&quot;Hello, World!&quot;);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(LED_PIN, HIGH);</span><br />&#160;&#160;<span class="FontName2">delay(1000);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(LED_PIN, LOW);</span><br />&#160;&#160;<span class="FontName2">delay(1000);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">There are several small details in this code that we can clean up and place into a library. The pin can differ between boards, so we will want to define a default pin of 13 and allow for it to be overridden.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Not all boards have the same LED pin. For example the Arduino Ethernet board uses pin 9.</p></div>
<p class="indent">To create libraries, first create a main sketch, and then add the libraries to that sketch. Since the sketch is an auto-generated header file, the library you create cannot have the same name as the sketch. Let&#x2019;s start by creating the library&#x2019;s header file, <span class="FontName2">HelloLibrary.h</span><a id="cXXX.517" />. In order to create a new library, you have to use a special part of the Arduino IDE. In <a href="#Fig3" id="_Fig3">Figure 12-3</a>, there is a drop down arrow just below the serial monitor button.</p>
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig12-03.jpg" alt="9781430239390_Fig12-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 12-3</a>. </span>SimpleHello.ino sketch with &#x201C;New Tab&#x201D; option </p>
</div>
<p class="indent">Make sure your sketch contains the code from <a href="#list2">Listing 12-2</a>. Then, in <a href="#Fig3">Figure 12-3</a>, select &#x201C;New Tab&#x201D; from the triangle menu. You will be prompted to create a file. Call this new file <span class="FontName2">&quot;HelloLibrary.h&quot;</span>. Once you have created the new file, enter <a href="#list3" id="_list3">Listing 12-3</a>.</p>
<p class="noindent2"><a href="#_list3" id="list3"><b><i>Listing 12-3.</i></b></a>&#160;&#160;HelloLibrary Header File</p>
<pre><span class="FontName2">/*</span><br /><span class="FontName2">*</span><br />&#160;<span class="FontName2">* HelloLibrary Header file</span><br />&#160;<span class="FontName2">*</span><br />&#160;<span class="FontName2">*/</span><br /><span class="FontName2">#ifndef HelloLibrary_h</span><br /><span class="FontName2">#define HelloLibrary_h</span><br /><br /><span class="FontName2">#if defined(ARDUINO) &#x0026;&#x0026; ARDUINO &#x003E;= 100</span><br /><span class="FontName2">#include &quot;Arduino.h&quot;</span><br /><span class="FontName2">#else</span><br /><span class="FontName2">#include &quot;WProgram.h&quot;</span><br /><span class="FontName2">#endif</span><br /><br /><span class="FontName2">#define LED_PIN 13</span><br /><span class="FontName2">void printHelloLibrary();</span><br /><span class="FontName2">void startBlink(int duration);</span><br /><span class="FontName2">#endif</span></pre>
<p class="indent">If you were programming strictly in C, you may want to name the <span class="FontName2">HelloLibrary</span> implementation file as <span class="FontName2">HelloLibrary.c</span>, but the Arduino compiler process will be looking for <span class="FontName2">HelloLibrary.cpp</span>. Normally, it is okay to put C code in the <span class="FontName2">*.cpp</span> file. Next, we will create the <span class="FontName2">HelloLibrary.cpp</span> implementation file. The <span class="FontName2">HelloLibrary.cpp</span> code that we will use for the implementation is shown in <a href="#list4" id="_list4">Listing 12-4</a>. It is important to note that the implementation file needs to include a reference to the header file. This way, the created functions will conform to the header specification at compile time.</p>
<p class="noindent2"><a href="#_list4" id="list4"><b><i>Listing 12-4.</i></b></a>&#160;&#160;HelloLibrary cpp implementation file<a id="cXXX.519" /></p>
<pre><span class="FontName2">/*</span><br /><span class="FontName2">*</span><br />&#160;<span class="FontName2">* HelloLibrary cpp implementation file</span><br />&#160;<span class="FontName2">*</span><br />&#160;<span class="FontName2">*/</span><br /><br /><span class="FontName2">#include &quot;HelloLibrary.h&quot;</span><br /><span class="FontName2">void startBlink(int duration)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">digitalWrite(LED_PIN, HIGH);</span><br />&#160;&#160;<span class="FontName2">delay(duration);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(LED_PIN, LOW);</span><br />&#160;&#160;<span class="FontName2">delay(duration);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void printHelloLibrary()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.println(&quot;Hello Library&quot;);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The code that causes the actions is now in place in <a href="#list4">Listing 12-4</a>, and it is almost identical to the code that we made in the main sketch. Once the library is created, the main <span class="FontName2">HelloLibrarySketch.ino</span> sketch<a id="cXXX.520" /> resembles <a href="#list5" id="_list5">Listing 12-5</a>. It includes <span class="FontName2">HelloLibrary.h</span>, as well as the functions and definitions defined in the library that are now available to any application that communicates with the library.</p>
<p class="noindent2"><a href="#_list5" id="list5"><b><i>Listing 12-5.</i></b></a>&#160;&#160;Revised main sketch code</p>
<pre><span class="FontName2">/*</span><br /><span class="FontName2">*</span><br />&#160;<span class="FontName2">* Hello Library Example</span><br />&#160;<span class="FontName2">*</span><br />&#160;<span class="FontName2">*/</span><br /><br /><span class="FontName2">#include &quot;HelloLibrary.h&quot;</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">printHelloLibrary();</span><br />&#160;&#160;<span class="FontName2">startBlink(1000);</span><br /><span class="FontName2">}</span></pre>
<p class="indent"><a href="#list5">Listing 12-5</a> outlines the pattern that all libraries follow. Include the library at the top of the file, and the compiler will process the library, and then you can access the functions according to C/C++ principles. In libraries, there is a common pattern for adding enumerations (<span class="FontName2">enum</span>) and structures (<span class="FontName2">struct</span>) to your code. You can use these as types in your code, but only if you write a function that has them as a return type or parameter. Because of the preprocessing, you cannot put them in your main sketch, but you will need to add them to a header file. For example, you may want to keep track of the part of the day&#x2014;morning, afternoon, evening, or night. It is possible to do this in one of two ways.</p>
<ul class="bulleted">
<li>Using <span class="FontName2">#define</span>:
<pre><span class="FontName2">#define MORNING 0</span><br /><span class="FontName2">#define AFTERNOON 1</span><br /><span class="FontName2">#define EVENING 2</span><br /><span class="FontName2">#define NIGHT 3</span></pre></li>
<li>Using an enumeration:
<pre><span class="FontName2">enum {MORNING, AFTERNOON, EVENING, NIGHT};</span></pre></li>
</ul>
<p class="indent">There is an automatic assigning of values starting from 0 and growing by one, until the final one is reached. This can be overridden, and each can be initialized to a specific value.</p>
<pre><span class="FontName2">enum {</span><br /><span class="FontName2">MORNING = 1,</span><br /><span class="FontName2">AFTERNOON = 3,</span><br /><span class="FontName2">EVENING = 5,</span><br /><span class="FontName2">NIGHT = 7</span><br /><span class="FontName2">};</span></pre>
<p class="indent">For this reason <span class="FontName2">enum</span> sequences are not typically iterated. You should use a different data type for values that you want to iterate.</p>
<p class="indent">The other common C feature is structures. Structures<a id="cXXX.521" /> are referred to as <span class="FontName2">struct</span>s and similarly must be implemented in a header file in order to be used as parameters or return types for functions.</p>
<pre><span class="FontName2">struct position {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">int xx;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">int yy;</span><br /><span class="FontName2">};</span></pre>
<p class="indent">This <span class="FontName2">struct</span> would declare a position to have an X and Y value. In strict C, you would have to declare the <span class="FontName2">struct</span> or <span class="FontName2">enum</span> with <span class="FontName2">typedef</span>, but in C++ this is not required. This <span class="FontName2">struct</span> could be added to our Hello Library header file, as indicated in <a href="#list6" id="_list6">Listing 12-6</a>.</p>
<p class="noindent2"><a href="#_list6" id="list6"><b><i>Listing 12-6.</i></b></a>&#160;&#160;Position struct <a id="cXXX.522" /> in header file HelloLibrary.h updated</p>
<pre><span class="FontName2">/*</span><br /><span class="FontName2">*</span><br />&#160;<span class="FontName2">* HelloLibrary Header file</span><br />&#160;<span class="FontName2">*</span><br />&#160;<span class="FontName2">*/</span><br /><span class="FontName2">#ifndef HelloLibrary_h</span><br /><span class="FontName2">#define HelloLibrary_h</span><br /><br /><span class="FontName2">#if defined(ARDUINO) &#x0026;&#x0026; ARDUINO &#x003E;= 100</span><br /><span class="FontName2">#include &quot;Arduino.h&quot;</span><br /><span class="FontName2">#else</span><br /><span class="FontName2">#include &quot;WProgram.h&quot;</span><br /><span class="FontName2">#endif</span><br /><br /><span class="FontName2">#define LED_PIN 13</span><br /><span class="FontName2">struct position {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">int xx;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">int yy;</span><br /><span class="FontName2">};</span><br /><br /><span class="FontName2">void printHelloLibrary();</span><br /><span class="FontName2">void startBlink(int duration);</span><br /><span class="FontName2">#endif</span></pre>
<p class="indent">Then the <span class="FontName2">Position struct</span> could be used in the main sketch, as shown in <a href="#list7" id="_list7">Listing 12-7</a>.</p>
<p class="noindent2"><a href="#_list7" id="list7"><b><i>Listing 12-7.</i></b></a>&#160;&#160;Code using the Position struct</p>
<pre><span class="FontName2">#include &quot;HelloLibrary.h&quot;</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">Serial.begin(9600);</span><br /><span class="FontName2">position Position;</span><br /><span class="FontName2">Position.xx = 20;</span><br /><span class="FontName2">Position.yy = 30;</span><br /><span class="FontName2">Serial.print(&quot;Position X: &quot;);</span><br /><span class="FontName2">Serial.print(Position.xx);</span><br /><span class="FontName2">Serial.print(&quot; Y: &quot;);</span><br /><span class="FontName2">Serial.println(Position.yy);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span></pre>
<p class="indent"><a href="#list7">Listing 12-7</a> uses the <span class="FontName2">struct</span> from the header file in the setup portion of the main sketch. Without using libraries to hold these values, you must prototype them manually in the main sketch, which makes the code less portable to other projects. Using libraries unlocks the real power of C/C++, where function definitions, function parameters and return types can conform to the rules that were defined in your library.</p>
</div>
<p id="Sec3" class="Heading1">Making a Motor Library</p>
<p class="noindent">Robots help us get the most out of our movement code. We may have many robots<a id="cXXX.523" /> based on the same motor driver chips, so most motor movement can be done from a generic motor library that targets a set of common pin compatible motor control chips. For a more in-depth look, we will create a motor library initially based on the L293D chip. In some cases, like Texas Instruments SN754410, they are pin compatible and need to be modified. However, if a different pin layout were used for a new shield, then the pins would have to be redefined . This project is a based on the IEEE Rutgers motor controller shield, <span class="FontName2"><a href="https://github.com/erosen/Line-Following-Robot">https://github.com/erosen/Line-Following-Robot</a></span>, with two 5-volt motors. The goal is to convert it to a library that conforms to the Arduino and can be easily distributed for anyone using either chip. In this example, we will create a motor object using the basic C++ features of a class with both private and public methods.</p>
<p class="indent">A motor controller needs three types of defined pins: motor direction, the pulse width modulation (PWM), and motor enable. These pins enable the motor behavior&#x2014;for example: on or off and spin forward or backward. The motor will spin at a particular rate controlled by voltage approximated by the PWM pins. Since these pins can change from board to board, we need a way to set a default set of pins and then an override so that custom pins can be used. For instance, software PWM could be used instead of the<a id="cXXX.524" /> physical PWM pins that are indicated by the Arduino type.</p>
<p class="indent">The example code we are using in Figure 12-8 already supports many helpful features. You can also write directly to the pins to make the motors move. To enable a motor, set the direction and move it to write:</p>
<pre><span class="FontName2">digitalWrite(motor1Enable, HIGH);</span><br /><span class="FontName2">digitalWrite(motor1Dir, HIGH);</span><br /><span class="FontName2">analogWrite(motor1PWM, 128);</span></pre>
<p class="indent">Given these basic features, we can control the motor for forward, back, left, right, stop, and various speeds. In a standard Arduino sketch you would end up cutting and pasting them repeatedly, which is not very sustainable. The next step is to create some useful functions that help to avoid cutting and pasting, so we do not end up with code that is difficult to read. The final step is to create a library that organizes these functions so that you can use them in multiple robot or motor projects. The starting sketch is shown in <a href="#list8" id="_list8">Listing 12-8</a>.</p>
<p class="noindent2"><a href="#_list8" id="list8"><b><i>Listing 12-8.</i></b></a>&#160;&#160;Initial motor controller code<a id="cXXX.525" /></p>
<pre><span class="FontName2">#define motor1Dir 7</span><br /><span class="FontName2">#define motor2Dir 8</span><br /><span class="FontName2">#define motor1PWM 9</span><br /><span class="FontName2">#define motor2PWM 10</span><br /><span class="FontName2">#define motor1Enable 11</span><br /><span class="FontName2">#define motor2Enable 12</span><br /><br /><span class="FontName2">void initMotorDriver()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">pinMode(motor1Dir, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">pinMode(motor2Dir, OUTPUT);</span><br /><br />&#160;&#160;<span class="FontName2">pinMode(motor1Enable, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">pinMode(motor2Enable, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(motor1Enable,HIGH);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(motor2Enable,HIGH);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(0); // make sure the motors are stopped</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(0);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void setMotorVel(int dirPin, int pwmPin, int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">if (velocity &#x003E;= 255)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">velocity = 255;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (velocity &#x003C;=</span> &#x2212;<span class="FontName2">255)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">velocity =</span> &#x2212;<span class="FontName2">255;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><br />&#160;&#160;<span class="FontName2">if (velocity == 0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin, HIGH);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(pwmPin, HIGH);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else if(velocity &#x003C;0)</span><br />&#160;&#160;<span class="FontName2">{ // Reverse</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin, HIGH);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">analogWrite(pwmPin, 255+velocity);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else if(velocity &#x003E;0)</span><br />&#160;&#160;<span class="FontName2">{ // Forward</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin,LOW);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">analogWrite(pwmPin, velocity);</span><br />&#160;&#160;<span class="FontName2">}</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void setLeftMotorSpeed(int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Serial.print(&quot;Set Left: &quot;);</span><br />&#160;&#160;<span class="FontName2">//Serial.println(velocity);</span><br />&#160;&#160;<span class="FontName2">setMotorVel(motor1Dir, motor1PWM, -velocity);</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void setRightMotorSpeed(int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Serial.print(&quot;Set Right: &quot;);</span><br />&#160;&#160;<span class="FontName2">//Serial.println(velocity);</span><br />&#160;&#160;<span class="FontName2">setMotorVel(motor2Dir, motor2PWM, -velocity);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">initMotorDriver();</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(</span>&#x2212;<span class="FontName2">255);</span><br />&#160;&#160;<span class="FontName2">delay(500);</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(</span>&#x2212;<span class="FontName2">255);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">delay(500);</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(0);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(0);</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Go Forward 5 secs</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(355);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">delay(5000);</span><br />&#160;&#160;<span class="FontName2">//Stop</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(0);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(0);</span><br /><br />&#160;&#160;<span class="FontName2">//loop here forever.</span><br />&#160;&#160;<span class="FontName2">while(1);</span><br /><br /><span class="FontName2">}</span></pre>
<p class="indent">In the initial sketch, the individual control commands are combined into one function called <span class="FontName2">setMotorVel</span>:</p>
<pre><span class="FontName2">void setMotorVel(int dirPin, int pwmPin, int velocity)</span></pre>
<p class="indent">The direction is set by integer velocity, which accepts &#x2212;255 through 255. If the velocity is negative, then the opposite direction is enabled.</p>
<p class="indent"><a href="#list8">Listing 12-8</a> code defines the pins that are mapped to control the chip. This defines a motion function that controls all the options, and there are helper functions that make it easy to initiate left and right control of the robot. Now, we are ready to make the library. These functions will move into their own header file, <span class="FontName2">.h</span> and their own implementation file, <span class="FontName2">.cpp</span>. At this step, we want to create the appropriate project structure.</p>
<p class="noindent2"><b><i>Listing 12-9.</i></b>&#160;&#160;Motor controller header file <a id="cXXX.526" />Motor.h</p>
<pre><span class="FontName2">#ifndef Motor_h</span><br /><span class="FontName2">#define Motor_h</span><br /><br /><span class="FontName2">#if defined(ARDUINO) &#x0026;&#x0026; ARDUINO &#x003E;= 100</span><br /><span class="FontName2">#include &quot;Arduino.h&quot;</span><br /><span class="FontName2">#else</span><br /><span class="FontName2">#include &quot;WProgram.h&quot;</span><br /><span class="FontName2">#endif</span><br /><br /><span class="FontName2">#define motor1Dir 7</span><br /><span class="FontName2">#define motor2Dir 8</span><br /><span class="FontName2">#define motor1PWM 9</span><br /><span class="FontName2">#define motor2PWM 10</span><br /><span class="FontName2">#define motor1Enable 11</span><br /><span class="FontName2">#define motor2Enable 12</span><br /><br /><span class="FontName2">class Motor</span><br /><span class="FontName2">{</span><br />&#160;<span class="FontName2">public:</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Motor();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void begin();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void setLeftMotorSpeed(int velocity);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void setRightMotorSpeed(int velocity);</span><br />&#160;&#160;&#160;&#160;  <br />&#160;<span class="FontName2">private:</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">void setMotorVel(int dirPin, int pwmPin, int velocity);</span><br /><span class="FontName2">};</span><br /><span class="FontName2">#endif</span></pre>
<p class="indent">Here is what the implementation file looks like:</p>
<pre><span class="FontName2">#include &quot;Motor.h&quot;</span><br /><span class="FontName2">Motor::Motor()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">pinMode(motor1Dir, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">pinMode(motor2Dir, OUTPUT);</span><br /><br />&#160;&#160;<span class="FontName2">pinMode(motor1Enable, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">pinMode(motor2Enable, OUTPUT);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(motor1Enable,HIGH);</span><br />&#160;&#160;<span class="FontName2">digitalWrite(motor2Enable,HIGH);</span><br />&#160;&#160;<span class="FontName2">setLeftMotorSpeed(0); // make sure the motors are stopped</span><br />&#160;&#160;<span class="FontName2">setRightMotorSpeed(0);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void Motor::setMotorVel(int dirPin, int pwmPin, int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">if (velocity &#x003E;= 255)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">velocity = 255;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (velocity &#x003C;=</span> &#x2212;<span class="FontName2">255)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">velocity =</span> &#x2212;<span class="FontName2">255;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><br />&#160;&#160;<span class="FontName2">if (velocity == 0)</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin, HIGH);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(pwmPin, HIGH);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else if(velocity &#x003C;0){ // Reverse</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin, HIGH);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">analogWrite(pwmPin, 255+velocity);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else if(velocity &#x003E;0){ // Forward</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite(dirPin,LOW);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">analogWrite(pwmPin, velocity);</span><br />&#160;&#160;<span class="FontName2">}</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void Motor::setLeftMotorSpeed(int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Serial.print(&quot;Set Left: &quot;);</span><br />&#160;&#160;<span class="FontName2">//Serial.println(velocity);</span><br />&#160;&#160;<span class="FontName2">setMotorVel(motor1Dir, motor1PWM, -velocity);</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void Motor::setRightMotorSpeed(int velocity)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Serial.print(&quot;Set Right: &quot;);</span><br />&#160;&#160;<span class="FontName2">//Serial.println(velocity);</span><br />&#160;&#160;<span class="FontName2">setMotorVel(motor2Dir, motor2PWM, -velocity);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">Once the implementation code is in place, it is time to work on the main sketch that will use the code. To avoid cutting and pasting the code into every sketch, we can just write <span class="FontName2">#include &quot;Motor.h&quot;</span>. The following sketch example shows the code controlling the motor and using features of the library, which is much shorter and cleaner than the original sketch in <a href="#list8">Listing 12-8</a>.</p>
<p class="noindent2"><b><i>Listing 12-10.</i></b>&#160;&#160;Motor controller main sketch<a id="cXXX.527" /></p>
<pre><span class="FontName2">.#include &quot;Motor.h&quot;</span><br /><span class="FontName2">Motor motor;</span><br /><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;  <br />&#160;&#160;<span class="FontName2">motor.setRightMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">motor.setLeftMotorSpeed(</span>&#x2212;<span class="FontName2">255);</span><br />&#160;&#160;<span class="FontName2">delay(500);</span><br />&#160;&#160;<span class="FontName2">motor.setRightMotorSpeed(</span>&#x2212;<span class="FontName2">255);</span><br />&#160;&#160;<span class="FontName2">motor.setLeftMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">delay(500);</span><br />&#160;&#160;<span class="FontName2">motor.setRightMotorSpeed(0);</span><br />&#160;&#160;<span class="FontName2">motor.setLeftMotorSpeed(0);</span><br /><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Go Forward 5 secs</span><br />&#160;&#160;<span class="FontName2">motor.setRightMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">motor.setLeftMotorSpeed(255);</span><br />&#160;&#160;<span class="FontName2">delay(5000);</span><br />&#160;&#160;<span class="FontName2">//Stop</span><br />&#160;&#160;<span class="FontName2">motor.setRightMotorSpeed(0);</span><br />&#160;&#160;<span class="FontName2">motor.setLeftMotorSpeed(0);</span><br /><br />&#160;&#160;<span class="FontName2">//loop here forever.</span><br />&#160;&#160;<span class="FontName2">while(1);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The amount of code for the sketch file is greatly reduced. Now, the sketch is about controlling the robot and less about implementing the low-level motor controlling code. The code can be adapted to be used system-wide across multiple projects.</p>
<p id="Sec4" class="Heading1">The anatomy of an Arduino library folder<a id="cXXX.249a" /></p>
<p class="noindent">The previous code shows how to create a library that is available to an individual Arduino sketch, rather than a system-wide sketch that all programs can use. As you continue to develop a set of libraries, you will want to structure them so that other people can use them. This means creating a <span class="FontName2">readme.txt</span> and a <span class="FontName2">keywords.txt</span>, moving examples to their <a id="cXXX.528" />own directory, and placing utility code into a <span class="FontName2">utilities</span> folder, all of which is shown in <a href="#Fig4" id="_Fig4">Figure 12-4</a>.</p>
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig12-04.jpg" alt="9781430239390_Fig12-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 12-4</a>. </span>Motor library<a id="cXXX.249b" /> directory structure </p>
</div>
<ul class="bulleted">
<li><b>Library Name</b>: The folder that contains the motor library will be listed with the library name; for instance <span class="FontName2">MotorLibrary</span> not <span class="FontName2">Motor.h</span></li>
<li><b>Examples</b>: These can be demo programs or test sketches that people will find useful when using your library.</li>
<li><b>Utilities</b>: A folder for utility code is not needed for main functionality, but provides help code.</li>
<li><b>Doc</b>: A documentation folder where <span class="FontName2">.pdf</span>, <span class="FontName2">.txt</span>, or <span class="FontName2">.html</span> files go with documentation for the library.</li>
<li><b>Header files</b>: Our example uses <span class="FontName2">Motor.h</span>, but you may have many other header files in your project. Those would all go in this directory.</li>
<li><b>Implementation file</b>: This example uses <span class="FontName2">Motor.cpp</span>, but other libraries can have one or more implementation files.</li>
<li><b>License</b>: The license your libraries will be distributed under, such as the GNU Public License (GPL).</li>
<li><b>keywords.txt</b>: This contains the formatting to highlight the functions and variables that a user will see in the Arduino IDE.</li>
</ul>
<p class="indent">All of these directories and files need to be compressed into a <span class="FontName2">.zip</span> compressed archive file for download and installation by extracting them into the Arduino <span class="FontName2">libraries</span> folder. Let&#x2019;s examine critical features in more detail.</p>
<div>
<p id="Sec5" class="Heading2">Examples Folder</p>
<p class="noindent">The example folder contains all of your example sketches that demonstrate features and instructions. By having examples, your library will appear in the &#x201C;examples&#x201D; menu. When your library does not have examples, it will only be found in the &#x201C;import library&#x201D; menu<a id="cXXX.529" />. There are occasions where you write several libraries and they all share the same library. In this case, it makes sense to omit additional examples.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; New users may be confused and not be able to locate the library if it does not have at least one example.</p></div>
</div>
<div>
<p id="Sec6" class="Heading2">License</p>
<p class="noindent">The license file<a id="cXXX.530" /> can be anything from GPL to &#x201C;all rights reserved.&#x201D; If you are building on top of open source software, the license should be compatible. For Open Hardware check out the Open Source Hardware Association (OSHWA) at <span class="FontName2"><a href="http://www.oshwa.org/">http://www.oshwa.org/</a></span>; they maintain the definition of Open Hardware and have helpful information on what licenses are available.</p>
</div>
<div>
<p id="Sec7" class="Heading2">keywords.txt</p>
<p class="noindent">This file consists of the datatypes<a id="cXXX.531" />, methods, functions, and constants sections. A data type in parenthesis denotes the section. However, a tab character must separate these key and value pairs. Any spaces will cause the parsing to fail, with no indication as to what is wrong.</p>
<div class="thinline">
<pre><span class="FontName2"># Datatypes (KEYWORD1)</span></pre>
</div>
<pre><span class="FontName2">Motor&#160;&#160;&#160;&#160;KEYWORD1</span></pre>
<div class="thinline">
<pre><span class="FontName2"># Methods and Functions (KEYWORD2)</span></pre>
</div>
<pre><span class="FontName2">setMotorVel&#160;&#160;&#160;&#160;KEYWORD2</span><br /><span class="FontName2">setLeftMotorSpeed&#160;&#160;&#160;&#160;KEYWORD2</span><br /><span class="FontName2">setRightMotorSpeed&#160;&#160;&#160;&#160;KEYWORD2</span></pre>
<div class="thinline">
<pre><span class="FontName2"># Constants (LITERAL1)</span></pre>
</div>
<pre><span class="FontName2">motor1Dir LITERAL1</span></pre>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Even before your code is completed in this format, it is good practice to make it a version-controlled project and enable issue tracking. This is explained in detail in <a href="9781430239390_Ch02.xhtml">Chapter 2</a>.</p></div>
</div>
<div>
<p id="Sec8" class="Heading2">Installing Arduino Libraries</p>
<p class="noindent">The libraries are normally installed in the user sketch folder under <span class="FontName2">libraries</span>. Complete <a id="cXXX.532" />libraries are stored there for use in any Arduino sketch. Installation typically consists of extracting the library into the Arduino <span class="FontName2">libraries</span> folder.</p>
<p class="indent">If you have placed your code in a version control system like GitHub, users can click the download option and extract or clone the project into the default libraries folder. This is a very efficient way to distribute the code and make it communally available.</p>
</div>
<div>
<p id="Sec9" class="Heading2">Using Arduino Libraries</p>
<p class="noindent">Once a library is extracted and placed, it is ready for use. The code that references the<a id="cXXX.533" /> libraries will need to be updated in one of the following formats.</p>
<ul class="bulleted">
<li>To look for a system-level library:
<pre><span class="FontName2">#include &#x003C;Motor.h&#x003E;</span></pre></li>
</ul>
<ul class="bulleted">
<li>To look in the project directory for the library:
<pre><span class="FontName2">#include &quot;Motor.h&quot;</span></pre></li>
</ul>
<p class="indent">The <span class="FontName2">#include</span> with caret bracketing (<span class="FontName2">&#x003C; &#x003E;</span>) indicates a system library, and it will search the library area for your code. This step can be easily overlooked, so be careful and check that you have the correct symbols.</p>
</div>
<p id="Sec10" class="Heading1">Arduino Objects and Library Conventions<a id="cXXX.251a" /></p>
<p class="noindent">C libraries do not use constructors and destructors. The library simply provides a set of previously created functions and variables. However, in order to use a library, there may be some set-up configuration necessary. This initialization would be in a <span class="FontName2">begin()</span> function<a id="cXXX.534" />, where all necessary elements of the library are configured. However, C++ supports objects that typically have a constructor, which is invoked when the object is created. Conversely, a destructor is invoked when the object is removed from memory, which means <span class="FontName2">begin()</span> is not always needed.</p>
<p class="indent">A destructor<a id="cXXX.535" /> would usually be defined as a way to clean up the object on delete. However, delete in the AVR environment is not always available. You can free up pins and clean up after the object is finished, or you can use an <span class="FontName2">end()</span> function activated in the void <span class="FontName2">setup()</span> portion of an Arduino sketch.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; Destructors are not typically used. The examples have the destructors removed.</p></div>
<p class="indent">The <span class="FontName2">setup()</span> function<a id="cXXX.536" /> should include all the starting maintenance and object initialization in addition to the constructor. One key reason to use the <span class="FontName2">begin()</span> function is that variables, objects, or communications may not be initialized yet. For instance, if you want to use the <span class="FontName2">Wire</span><a id="cXXX.537" /> (I2C) library in a library or object, the <span class="FontName2">Wire.begin()</span> function must be enabled before your object can use the Wire library. At some point, the user may want to end the use of an object so that the <span class="FontName2">end()</span> function can be accessed, which takes care of any necessary cleanup. The recommended Arduino best practice for writing libraries that have some kind of sequential data includes using &#x201C;read&#x201D; and &#x201C;write&#x201D; functions instead of &#x201C;send&#x201D; and &#x201C;receive&#x201D;.</p>
<p class="indent">One common temperature sensor is the DS1631 I2C. It is essential to review the characteristics of the device in order for the code to use these features. This includes going to the data sheet <span class="FontName2"><a href="http://datasheets.maxim-ic.com/en/ds/DS1631-DS1731.pdf">http://datasheets.maxim-ic.com/en/ds/DS1631-DS1731.pdf</a></span>, on which you can derive the following information.</p>
<p class="indent">This is an I2C slave device<a id="cXXX.538" />, which has a pin configurable address for up to eight devices on the same I2C chain as the master device.</p>
<p class="indent">This is represented by the 7-bit control byte defined here:</p>
<ul class="bulleted">
<li><span class="FontName2">Bit 0: r/w</span></li>
<li><span class="FontName2">Bit 1: A0</span></li>
<li><span class="FontName2">Bit 2: A1</span></li>
<li><span class="FontName2">Bit 3: A2</span></li>
<li><span class="FontName2">Bit 4: 1</span></li>
<li><span class="FontName2">Bit 5: 0</span></li>
<li><span class="FontName2">Bit 6: 0</span></li>
<li><span class="FontName2">Bit 7: 1</span></li>
</ul>
<p class="indent">We frequently work with these numbers in hexadecimal format. You will see device configuration that looks like this:</p>
<pre><span class="FontName2">0x90</span></pre>
<p class="indent">The way to read it is:</p>
<ul class="bulleted">
<li>9 is 1001</li>
<li>0 is 0000</li>
</ul>
<p class="indent">That would mean the device address is 0 and writable. The address corresponds to three bits, A0, A1, A2, and the last bit in the sequence configures if the device is in both write and read mode. So, read-only would look like 0001. The address only needs the 000, so in the implementation, we shift the address by one bit. Then the piece of code looks like this:</p>
<pre><span class="FontName2">_addr = 0x90 &#x003E;&#x003E; 1;</span></pre>
<p class="indent">Now the address can be used to reference the device. The goal with our code is to put those details into the constructor so that the data sheet can be directly read and the address can be pulled from it without forcing the programmer to make the shift. This also means that the user must wire the DS1631 with a valid address. Then, they must define the address for the library or object. When we configure the object, we require an address. The Arduino I2C master sets the control byte in order to tell the correct DS1631 what command to receive.</p>
<p class="indent">Ideally, the programmer will be able to use or hide the commands as needed during the implementation stage. So, <span class="FontName2">startConversion()</span> can be done without the programmer knowing the internal commands<a id="cXXX.539" />, such as the fact that 0x51 means &#x201C;start conversion&#x201D;. This applies to any of the appropriate and defined commands. For use in the Wire library, these must be converted into a hexadecimal form.</p>
<p class="indent">The commands are as follows:</p>
<ul class="bulleted">
<li>Start Convert: 0x51</li>
<li>Stop Convert: 0x22</li>
<li>Read Temperature: 0xAA</li>
<li>Access TH: 0xA1</li>
<li>Access TL: 0xA2</li>
<li>Access Config: 0xAC</li>
</ul>
<p class="indent">Software POR: 0x54 Registers:</p>
<ul class="bulleted">
<li>Temperature, 2 bytes, read only</li>
<li>Configuration, 1 byte, read/write or set read-only</li>
<li>Trip point: High, 2 bytes, read/write</li>
<li>Trip point: Low, 2 bytes, read/write</li>
</ul>
<p class="indent">We will want to obtain and/or set this information. The trigger trip points are very useful because we can set actions to occur if we leave a common boundary. Additionally, we can have interrupts that respond to both high and low conditions.</p>
<p class="indent">We will not be using the trip point registers in this example, but they can be found with the website in the final library code.</p>
<p class="indent">A typical set of functions would be the getters and setters for those registers:</p>
<pre><span class="FontName2">getConfig();</span><br /><span class="FontName2">setConfig();</span><br /><span class="FontName2">getTemp();</span></pre>
<p class="indent">The goal for the main Arduino sketch is to print out the temperature at specified intervals. When we distribute the code, this will be moved into the examples folder. We also need to create <span class="FontName2">DS1631.h</span>, and <span class="FontName2">DS1631.cpp</span> in the same sketch folder. Then, we will move the code to its own Arduino generic library. Here&#x2019;s the initial library code, starting with the header file:</p>
<p class="noindent2"><a href="#_list11" id="list11"><b><i>Listing 12-11.</i></b></a>&#160;&#160;DS1631 I2C temperature sensor Arduino library DS1631.h<a id="cXXX.540" /></p>
<pre><span class="FontName2">/*</span><br />&#160;<span class="FontName2">* DS1631 library object.</span><br />&#160;<span class="FontName2">* Registers R1, and R2 are used to set 9, 10, 11, 12 bit temperature resolution</span><br />&#160;<span class="FontName2">* Between a range of -55C to +125C</span><br />&#160;<span class="FontName2">* A0, A1, A2 are used to set the device address. Which is shifted by the library for use.</span><br />&#160;<span class="FontName2">* 1-SHOT readings or Continuous Readings can be configured</span><br />&#160;<span class="FontName2">* 12 bit resolution can take up to 750ms to be available</span><br />&#160;<span class="FontName2">* Temperature is returned in a 16 bit&#160;&#160;two&#x0027;s complement Th, and Tl Register</span><br />&#160;<span class="FontName2">* The signed bit S, S = 0 for positive, and S = 1 for negative</span><br />&#160;<span class="FontName2">*/</span><br />&#160;&#160; <br /><span class="FontName2">#ifndef DS1631_h</span><br /><span class="FontName2">#define DS1631_h</span><br /><br /><span class="FontName2">#if defined(ARDUINO) &#x0026;&#x0026; ARDUINO &#x003E;= 100</span><br /><span class="FontName2">#include &quot;Arduino.h&quot;</span><br /><span class="FontName2">#include &quot;pins_arduino.h&quot;</span><br /><span class="FontName2">#else</span><br /><span class="FontName2">#include &quot;WProgram.h&quot;</span><br /><span class="FontName2">#include &quot;pins_arduino.h&quot;</span><br /><span class="FontName2">#endif</span><br /><br /><span class="FontName2">#define DEV0 0x90</span><br /><span class="FontName2">#define DEV1 0x91</span><br /><span class="FontName2">#define DEV2 0x92</span><br /><span class="FontName2">#define DEV3 0x93</span><br /><span class="FontName2">#define DEV4 0x94</span><br /><span class="FontName2">#define DEV5 0x95</span><br /><span class="FontName2">#define DEV6 0x96</span><br /><span class="FontName2">#define DEV7 0x97</span><br /><br /><span class="FontName2">class DS1631</span><br /><span class="FontName2">{</span><br /><span class="FontName2">public:</span><br />&#160;&#160;<span class="FontName2">DS1631(uint8_t _ADDR);</span><br />&#160;&#160;<span class="FontName2">void begin( );</span><br />&#160;&#160;<span class="FontName2">byte getConfig();</span><br />&#160;&#160;<span class="FontName2">void setConfig(uint8_t _ADDR);</span><br />&#160;&#160;<span class="FontName2">float getTemp();</span><br />&#160;&#160;<span class="FontName2">void stopConversion();</span><br />&#160;&#160;<span class="FontName2">void startConversion();</span><br /><br /><span class="FontName2">private:</span><br />&#160;&#160;<span class="FontName2">float calcTemp(int msb, int lsb);</span><br />&#160;&#160;<span class="FontName2">uint8_t _addr;</span><br />&#160;&#160;<span class="FontName2">uint8_t _temp[2];</span><br /><span class="FontName2">};</span><br /><span class="FontName2">#endif</span></pre>
<p class="indent"><a href="#list11" id="_list11">Listing 12-11</a> defines all the valid device addresses that can be used with the object. It is configured so that when reading the data sheet, the hexadecimal I2C address can be used as listed. Since the header file only shows the signature for the functions, we can tell what the class name, constructor, and destructor are for the defined object.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160; With the AVR GCC, there is not effective memory management. Objects will not get deleted, so the constructor is not used and can be eliminated from the code.</p></div>
<p class="indent">As there is no effective memory management, the destructor is not used and no memory will be deallocated. The private variables are declared here, and the compiler will enforce them. If you try to directly access <span class="FontName2">_addr</span>, <span class="FontName2">_temp[2]</span>, or <span class="FontName2">calcTemp()</span>, the compiler will show an error indicating that you are trying to access private values. By reviewing this code, you can get a quick idea of the functions and the types of parameters that are defined. This information will be used to ensure that the implementation corresponds to the values that are represented in the header file.</p>
<p class="indent">It is possible to describe more than one object in a single header file, but this can confuse library users, so it is best to create only one object per header file. If a set of objects will never be used separately from one another, it may make sense to define more than one object in the same header file.</p>
<p class="noindent2"><a href="#_list12" id="list12"><b><i>Listing 12-12.</i></b></a>&#160;&#160;DS1631 I2C temperature sensor implementation DS1631.cpp <a id="cXXX.541" /></p>
<pre><span class="FontName2">#include &#x003C;Wire.h&#x003E;</span><br /><span class="FontName2">#include &quot;DS1631.h&quot;</span><br /><br /><span class="FontName2">uint8_t _temp[2];</span><br /><span class="FontName2">uint8_t _addr;</span><br /><br /><span class="FontName2">DS1631::DS1631(uint8_t _ADDR)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">//Cannot use Wire.begin() here because at declaration time it is unavailable.</span><br />&#160;&#160;<span class="FontName2">//Shift the address so the user can use the address as described in the Datasheet</span><br />&#160;&#160;<span class="FontName2">_addr = _ADDR &#x003E;&#x003E; 1;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void DS1631::begin()</span><br /><span class="FontName2">{</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void DS1631::stopConversion()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Wire.beginTransmission(_addr);</span><br />&#160;&#160;<span class="FontName2">Wire.write(0x22); //stop conversion command</span><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void DS1631::startConversion()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Wire.beginTransmission(_addr);</span><br />&#160;&#160;<span class="FontName2">Wire.write(0x51); //start conversion command</span><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">byte DS1631::getConfig()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">byte config;</span><br />&#160;&#160;<span class="FontName2">stopConversion();</span><br />&#160;&#160;<span class="FontName2">Wire.beginTransmission(_addr);</span><br />&#160;&#160;<span class="FontName2">Wire.write(0xAC); //get configuration command</span><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br />&#160;&#160;<span class="FontName2">Wire.requestFrom(_addr, (uint8_t) 0x01); //The configuration is one byte get it</span><br />&#160;&#160;<span class="FontName2">while (Wire.available())</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">config = Wire.read();</span><br />&#160;&#160;<span class="FontName2">}</span><br /><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br />&#160;&#160;<span class="FontName2">startConversion();</span><br />&#160;&#160;<span class="FontName2">return config;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void DS1631::setConfig(uint8_t config)//configuration options</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">stopConversion();</span><br />&#160;&#160;<span class="FontName2">Wire.beginTransmission(_addr);</span><br />&#160;&#160;<span class="FontName2">Wire.write(0xAC); //get configuration command</span><br />&#160;&#160;<span class="FontName2">Wire.write(config); //configure with options</span><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br />&#160;&#160;<span class="FontName2">startConversion();</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">float DS1631::getTemp() //0xAA command Read Temp, read 2 bytes, one shot temperature read</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">unsigned char _temp[2];</span><br />&#160;&#160;<span class="FontName2">int count = 0;</span><br /><br />&#160;&#160;<span class="FontName2">Wire.beginTransmission(_addr);</span><br />&#160;&#160;<span class="FontName2">Wire.write(0xAA); // start reading temperature now</span><br />&#160;&#160;<span class="FontName2">Wire.endTransmission();</span><br /><br />&#160;&#160;<span class="FontName2">delay(750); //750ms reqiured to get 12 bit resolution temperature</span><br />&#160;&#160;<span class="FontName2">Wire.requestFrom(_addr,&#160;&#160;(uint8_t)2); //get the 2 byte two&#x0027;s complement value back</span><br />&#160;&#160;<span class="FontName2">while(Wire.available())</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">_temp[count] = Wire.read();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">count++;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">float temp = calcTemp(_temp[0],_temp[1]);</span><br />&#160;&#160;<span class="FontName2">return temp;</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">float DS1631::calcTemp(int msb,&#160;&#160;int lsb)</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">float num = 0.0;</span><br />&#160;&#160;<span class="FontName2">//Acceptable, but only 2-3 significant digits</span><br />&#160;&#160; <span class="FontName2">// num = ((((short)msb&#x003C;&#x003C;8) | (short)lsb)&#x003E;&#x003E;6) / 4.0;</span><br />&#160;&#160;<span class="FontName2">lsb = lsb &#x003E;&#x003E; 4; // shift out the last 4 bits because they are 0</span><br />&#160;&#160;<span class="FontName2">if (msb &#x0026; 0x80) // Compare the sign bit = 1, then less than 0;</span><br />&#160;&#160;<span class="FontName2">{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">msb = msb - 256;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">// Float conversion</span><br />&#160;&#160;<span class="FontName2">num = (float) (msb + lsb*0.0625);</span><br />&#160;&#160;<span class="FontName2">return&#160;&#160;num;</span><br /><span class="FontName2">}</span></pre>
<p class="indent">The work of implementing the header file is done in the implementation file. Each of the I2C commands needs to be configured exactly to the data sheet. The constructor takes the defined address and shifts it the required one bit in order to be a proper address on the I2C bus. The details of the I2C communication protocol<a id="cXXX.542" /> are wrapped inside the functions so that a library user only needs to have some knowledge of the data sheet.</p>
<p class="indent">We have a <span class="FontName2">setConfig(uint8_t)</span> and a <span class="FontName2">uint8_t getConfig()</span> that will accept and display the configuration of the temperature sensor.</p>
<p class="indent">The datasheet explains that the temperature is in Celsius and is stored in two&#x2019;s complement formats, which mean that the most significant bit is the whole number, and the least significant bit is the decimal place. The float <span class="FontName2">getTemp()</span> function returns the Celsius temperature by calling <span class="FontName2">calcTemp()</span>; this is a private function that the sketch cannot call. There are many ways to do <span class="FontName2">calcTemp()</span>; it could be turned into a virtual function and be overridden by the programmer, but by separating it from <span class="FontName2">getTemp()</span>, it is possible to add flexibility to the library.</p>
<p class="noindent2"><a href="#_list13" id="list13"><b><i>Listing 12-13.</i></b></a>&#160;&#160;DS1631 I2C main sketch<a id="cXXX.543" /> DS1631Example.ino</p>
<pre><span class="FontName2">/*</span><br />&#160;<span class="FontName2">* DS1631_CPP Library Example</span><br />&#160;<span class="FontName2">*/</span><br /><br /><span class="FontName2">#include &#x003C;Wire.h&#x003E;</span><br /><span class="FontName2">#include &quot;DS1631.h&quot;</span><br /><br /><span class="FontName2">uint8_t conf = 0x0C;</span><br /><span class="FontName2">uint8_t dev1 = DEV0;</span><br /><br /><span class="FontName2">DS1631 TempSensor(dev1); //Wire.begin hasn&#x0027;t happened yet</span><br /><span class="FontName2">void setup()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">Wire.begin();</span><br /><br />&#160;&#160;<span class="FontName2">TempSensor.stopConversion();</span><br />&#160;&#160;<span class="FontName2">TempSensor.setConfig(conf);</span><br />&#160;&#160;<span class="FontName2">byte config = TempSensor.getConfig();</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot;Config: dev:&quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.print(DEV0, BIN);</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot; set: &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.print(config, BIN);</span><br />&#160;&#160;<span class="FontName2">Serial.print(conf, BIN);</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot; get: &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.println(config, BIN);</span><br /><span class="FontName2">}</span><br /><br /><span class="FontName2">void loop()</span><br /><span class="FontName2">{</span><br />&#160;&#160;<span class="FontName2">float temp = TempSensor.getTemp();</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot;TempC: &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.print(temp, 4);</span><br />&#160;&#160;<span class="FontName2">Serial.print(&quot; tempF: &quot;);</span><br />&#160;&#160;<span class="FontName2">Serial.println((temp*9/5) + 32, 4);</span><br /><span class="FontName2">}</span></pre>
<p class="indent">One key point is that <span class="FontName2">Wire.begin()</span> must be initiated for any I2C communication to occur. This explains why <span class="FontName2">Wire.begin()</span> is established early in the <span class="FontName2">setup()</span> code, before <span class="FontName2">TempSensor.setConfig(conf)</span> is called. The Serial library can print float values so the temperature returned as <span class="FontName2">float</span> would be printed automatically with two decimal points, but because we have more detail, the code specifies four decimal places.</p>
<p class="indent">Lastly, it is possible to have up to eight DS1631 temperature sensors<a id="cXXX.544" /> on one Arduino. In this version of the library, the sketch would contain an array of sensors each configured with their own address, as follows:</p>
<pre><span class="FontName2">DS1631 TmpSense[8] = {</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV0),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV1),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV2),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV3),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV4),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV5),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV6),</span><br />&#160;&#160;<span class="FontName2">DS1631(DEV7)</span><br /><span class="FontName2">};</span></pre>
<p class="indent">This code initializes all of the possible DS1631 I2C devices and can be used to monitor all eight possible sensors. You can access sensor four by calling <span class="FontName2">TmpSense[4].getTemp()</span>. You can use a for loop to read through the array and obtain all the sensor values. Lastly, in order to get the most from the library, you must document how the device names are defined; otherwise, users of the library will have to examine the header file and deduce all of the features. Another benefit of using libraries is to organize convenience functions like Fahrenheit conversion as shown in the loop code in <a href="#list13" id="_list13">Listing 12-13</a>. A good follow up exercise is updating the library to support <span class="FontName2">getTempC()</span> and <span class="FontName2">getTempF()</span><a id="cXXX.545" />.</p>
<p class="indent">One benefit of using <a href="#list12" id="_list12">Listing 12-12</a> is that we abstract away the details of configuring the temperature sensor, making the main sketch code simpler; we only need to configure and use the device. The library and the object contain all the code that are typically cut and pasted into the main sketch. This allows the user to avoid major headaches by using the temperature sensor instead of debugging the code.</p>
<p id="Sec11" class="Heading1">Summary</p>
<p class="noindent">Arduino libraries are powerful tools for sharing code between projects and users. This code is organized for bundling and easy distribution. In this chapter we showed how to create libraries in a specific sketch directory. You can now choose whether to write C style libraries or C++ object based libraries. Then, we explained how to convert that directory into an Arduino wide library. The Motor controller evolved from a single sketch to a powerful library with many helpful commands that control a robot or a set of motors. The other major example shows how to interact with devices using the I2C protocol and makes those devices easier to access and use. We also reviewed the steps necessary to take a library from a single project and make it available to all of your code system-wide. The next steps are to check your library code into GIT and share the project with other Arduino users as we described in <a href="9781430239390_Ch02.xhtml">Chapter 2</a>.</p>
</div>
</body>
</html>