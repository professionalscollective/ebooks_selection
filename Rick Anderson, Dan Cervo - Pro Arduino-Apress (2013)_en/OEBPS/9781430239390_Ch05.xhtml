<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 5 XBees</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap5" />CHAPTER 5</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">XBees</p>
<div>
<p class="noindent">Radio communication is a fundamental method of communicating over varying distances without having an encumbrance of wires. Arduino developers take advantage of radio communication in robotics, home automation, and remote-sensing applications. To avoid the headaches of developing radio communications systems from scratch, a lot of developers use XBee radio modules to add wireless functionality to projects. The XBee is a full-featured radio transceiver module made by Digi International (<span class="FontName1"><a href="http://www.digi.com">www.digi.com</a></span>) and is compliant with FCC regulations as long as you use the module without modification and adhere to a few other restrictions.</p>
<p class="indent">The restrictions that apply to the use of the XBee by the FCC and by other countries are listed in the data sheet provided by Digi. Most XBee modules are also compliant with the <i>ZigBee communication protocol</i>, a standard based on the IEEE 802.15.4 standard. XBees have the ability to communicate with other ZigBee-compliant devices.</p>
<p class="indent">The minimum hardware to get started exploring the world of XBees is a USB adapter, a serial adapter, an Arduino-compatible board, and two XBee modules. You can use the USB XBee adapter sold by Adafruit Industries (<span class="FontName1"><a href="http://www.adafruit.com/products/247">www.adafruit.com/products/247</a></span>) or the one sold by SparkFun Electronics (<a href="http://www.sparkfun.com/products/8687">www.sparkfun.com/products/8687</a>). The USB adapter is needed to interface with the computer for initialization and setup, and can provide a connection from the computer to other XBee modules.</p>
<p class="indent">The XBee has a small pin pitch that&#x2019;s not breadboard compatible, and it&#x2019;s a 3.3V device, so to use the XBee with an Arduino, you need a serial adapter to make the connections more easily and to convert the voltage levels. There are a few different styles of serial adapters that can be used for connecting the Arduino to the XBee: the two most notable are shields and breakout boards. They come with and without voltage conversion. Shields provide a method of simplified packaging&#x2014;excellent for semipermanent setups. Shields limit the number of devices that can be easily used and are usually restricted to boards with the standard Arduino pin out. For greater development flexibility, it is recommended to use breakout boards instead of shields. XBee breakout boards, such as the adapter available from Adafruit (<span class="FontName1"><a href="http://www.adafruit.com/products/126">www.adafruit.com/products/126</a></span>) or SparkFun (<span class="FontName1"><a href="http://www.sparkfun.com/products/9132">www.sparkfun.com/products/9132</a></span>), will work for the examples in this chapter and <a href="9781430239390_Ch06.xhtml">Chapter 6</a>.</p>
<p class="indent">The examples in this chapter are built using one ATmega328 Arduino-compatible board, two series 2 XBee modules, one USB adapter, and a serial breakout board. The focus of this chapter is on the series 2 XBee modules, but they are not the only modules available from Digi. The first section describes the various models of the XBee modules and the differences in functionality.</p>
<p id="Sec1" class="Heading1">Buying XBees</p>
<p class="noindent">It can be a bit difficult to discern the differences between XBee modules and match them to your project requirements. There are currently nine different series, with multiple variations on antennas, functionality, and transmission power. The series number is not an indication of version revisions, but of functionality and features. Modules with the same series number are always compatible with one another. When deciding what XBee set to purchase, you need to take constraints and the type of project into consideration. For example, for remote-control robots, an XBee that uses a point-to-point communication protocol with an extended transmitting range would be sufficient, even though the data rate may not be as fast as other modules. XBees for large sensor networks, on the other hand, may need to use a mesh protocol to be more robust in getting the data to the endpoint, with the range not being as important. To avoid issues in debugging, and for best results when purchasing a first set of XBees, match modules according to the series number, transmission power, and antenna type.</p>
<p class="indent">There may be a need in some projects to mismatch the modules, such as when using two modules with greater range and having others in the network with lower transmitting power to more effectively cover an area. Keep in mind when mixing the ranges of the modules that they can usually receive data at a faster rate than they can transmit data. Another possible mismatch comes with pro versions of XBee modules. Pro modules are clearly labeled with the word <i>Pro</i> on the module itself; these modules provide an integrated programmable microcontroller that acts in the same way as attaching an Arduino to a standard XBee module. The pro modules are useful for stand-alone operations or removing overhead from the Arduino itself. The move to the pro module is not necessary, and can add more complexity because the microcontroller used is made by Freescale and has a programming methodology different from the Arduino.</p>
<p class="indent">Here are the different series (series 1 and 2 are the most commonly used in Arduino development):</p>
<ul class="bulleted">
<li><i>Series 1</i>: This series has a network topology of spoke-and-hub or point-to-multipoint and uses the 2.4 GHz frequency band. Series 1 modules can be configured and used out of the box without extra software. This series works well for remote control applications and simple sensor networks. All communications go through a central node; outer nodes cannot communicate with one another. This series has a rage of 300 feet to 1 mile.</li>
<li><i>Series 2</i>: This series is a bit more complicated than series 1, but provides more functionality and flexibility. It&#x2019;s capable of <i>mesh networking</i><a id="cXXX.205" />, which closely resembles the common wired networking topology of an ISP, router, and computer. There are three different internal firmware options that can be used for a mesh network.</li></ul>
<ul class="bulletedin">
<li>There must be one controller in the network, which functions like a DHCP server or ISP. The controller assigns the address and determines if a new node can join the network.</li>
<li>Mesh networks also include router firmware and allow for multiple routers in the network.</li>
<li>Routers connect to the controller and to endpoints, which are the third firmware option.</li></ul>
<ul class="bulleted1">
<li>Both the controller and router have to be powered all the time and cannot take advantage of the power-saving feature of sleeping; this is due to the modules keeping track of routing information. The endpoint can be put into a sleep state. This series is usually marked on the board by an S2 below the XBee markings. There are two other variants in this series: S2B and S2C. S2B is the pro package and S2C is a surface-mount package. The regular S2 has the standard XBee through-hole configuration. This series has a range of 400 feet to 2 miles.</li></ul>
<ul class="bulleted">
<li><i>Series 3</i>: This series offers a 900 MHz point-to-multipoint module with about 6 miles of range.</li>
<li><i>Series 4</i>: Modules of this series can be used for proprietary Digi mesh<a id="cXXX.206" /> and point-to-multipoint; they have an approximate range of 1.8 miles using 900 MHz.</li>
<li><i>Series 5</i>: This series is licensed for European point-to-multipoint in the 868 MHz band; it has about 25 miles of range.</li>
<li><i>Series 6</i>: This series offers a WiFi module<a id="cXXX.207" /> packaged in the XBee format. It uses SPI or UART for connections and can work on B, G, and N networks.</li>
<li><i>Xtend</i><a id="cXXX.208" />: Modules of this series have a range of 15 miles, the longest available for use in the United States. They communicate at 900MHz. The network topology is proprietary multipoint or proprietary mesh.</li>
</ul>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Creating a network bridge is possible by connecting two different series, which converts between network types.</p></div>
<p id="Sec2" class="Heading1">Simple Setup</p>
<p class="noindent">This section&#x2019;s example sets up a simple communication for a set of series 2 XBee modules. There is some software that needs to be set up before the XBees<a id="cXXX.93a" /> can start communicating. Unlike series 1 modules, which can be configured for communications via a serial terminal, series 2 modules need different firmware for different nodes on the XBee network. There are two different software packages that can perform the firmware configuration.:</p>
<ul class="bulleted">
<li><i>X-CTU</i><a id="cXXX.209" />: This is the Digi proprietary software package to program the XBee modules. The software is available from the Digi web site, as well as directly from <span class="FontName1"><a href="http://ftp1.digi.com/support/utilities/40003002_B.exe">http://ftp1.digi.com/support/utilities/40003002_B.exe</a></span>. The X-CTU is capable of running on other operating systems, such as Linux via WINE. You need to download the firmware ZIP file for series 2 devices if setting up the X-CTU on Linux. You can download it from <span class="FontName1"><a href="http://www.digi.com/support/productdetail?pid=3430&#x0026;type=drivers">www.digi.com/support/productdetail?pid=3430&#x0026;type=drivers</a></span>. You also need to define a link so the WINE software can use ttyUSB to create a link; to do so, type the following into a command shell:
<pre><span class="FontName2">ln -s /dev/ttyUSB0 &#x223C;/.wine/dosdevices/com1</span></pre></li></ul>
<ul class="bulleted">
<li><i>Moltosenso</i><a id="cXXX.210" />: This software package is made by a third-party vendor and has the same functionality as the X-CTU. It natively works on the three common operating systems, Linux, Mac, and Windows, and is available at <span class="FontName1"><a href="http://www.moltosenso.com">www.moltosenso.com</a></span>. This software may be a bit buggy on some 64-bit Linux distributions. The ZIP files that contain the firmware have to be downloaded from Digi. Be aware that this software does not automatically determine the firmware that is compatible with the connected XBee module, but will work well for configuring the module&#x2019;s other settings.</li>
</ul>
<p class="indent">When the XBee is loaded with the AT firmware, a serial terminal program such as minicom, PuTTY, or HyperTerminal can be used to set and read options.</p>
<p class="indent">There are two different communication modes that the XBee module can be set to via different firmware:</p>
<ul class="bulleted">
<li><i>Transparent mode</i><a id="cXXX.211" />: Also known as <i>AT command mode</i>, transparent mode acts as a direct serial connection, the same way hardwired connections work. Sensors like the Parallax RFID readers can be connected over XBees in transparent mode without any other microcontroller in between the sensor and the RF module. This mode provides a great method for direct XBee-to-XBee communications and is useful in instances where the user needs to change settings while a network is up and running. You can enter this mode by typing <span class="FontName2">+++</span> without a carriage return into a serial program and waiting for an <span class="FontName2">OK</span> to return. All the commands are two characters prefixed by <span class="FontName2">AT</span> and followed by a carriage return. An example is the command <span class="FontName2">ATSL</span>, which will print the lower four bytes of the module&#x2019;s serial number.</li>
<li><i>API mode</i><a id="cXXX.212" />: This is useful for lager dynamic network setups where the software or microcontroller can easily change configurations without having to convert the human-readable AT command mode. API has a predefined protocol and communicates via packets. The use of the API mode is discussed further on in this chapter.</li>
</ul>
<p id="Sec3" class="Heading1">Transparent (AT Command) Mode</p>
<p class="noindent">When setting up the series 2 XBee modules, write down the serial numbers for all the modules in a convenient location. The serial numbers is also used as the hardware address and is located on the sticker just below the revision marking and to the right of the 2D bar code on the XBee module. The first eight numbers of the serial number are the higher 32 bits of the address&#x2014;usually 0013A200. The second eight numbers is the lower 32 bits of the address.</p>
<div>
<p id="Sec4" class="Heading2">Module Configuration<a id="cXXX.213" /></p>
<p class="noindent">Now it&#x2019;s time to set up your modules:</p>
<ul class="bulleted1">
<li>1.&#160;&#160;Determine which module will be used as the coordinator and which will be used as the router, and mark them with a label to differentiate between them.</li>
<li>2.&#160;&#160;Plug the XBee module to be used as the router into the USB adapter, making sure to line up the pins to the connector properly. The flat end usually points toward the USB connector.</li>
<li>3.&#160;&#160;Start the X-CTU software and plug the USB adapter into the computer. On the PC Settings tab, select or enter the COM port that the adapter is connected to and click the Test/Query button. The test should come up with the module type, firmware number, and serial number. If there is an error, check the connections and the COM port number in the device manager and retry. If this is the first time that the XBee module is being configured, the standard serial configuration is 9600 8N1.</li>
<li>4.&#160;&#160;After the test is complete, click the Modem Configuration tab and click the Read button in the Modem Parameter and Firmware box. If the module cannot be read at this point, click the &#x201C;Download new versions&#x2026;&#x201D; button. If you&#x2019;re using Windows, choose &#x201C;Web source,&#x201D; and for WINE setups, select file that was downloaded. Then retry reading the configuration.</li>
<li>5.&#160;&#160;Once you have read the module, select ZIGBEE ROUTER AT from the Function Set drop-down menu, and set the version of the firmware to the highest hex number available.</li>
<li>6.&#160;&#160;Check the &#x201C;Always update firmware&#x201D; box and click the Write button. This sets the firmware but not any of the networking options; once this operation completes, reread the module settings.</li>
<li>7.&#160;&#160;In the following list, the firmware drop-down shows the options available for change. Options highlighted in green are at their default setting, and options highlighted in blue are set to a different setting. The options that need to be changed are</li>
</ul>
<ul class="bulletedin">
<li>The pan ID (ID)</li>
<li>Destination address high (DH)</li>
<li>Destination address low (DL)
<p class="indent">In transparent mode, the address is where the data will be sent. This can be changed by entering the command mode. The pan ID is like the ESSID for WiFi networks, and can be set from 0 to FFFF. The pan ID chosen for this example is 3300. click &#x201C;pan ID&#x201D; and set to the chosen ID. The next two options are the serial numbers written down earlier: the destination&#x2019;s addresses. Both the high and low should be set to the serial number of the module chosen for the coordinator. These three settings prepare the module for communications in a network.</p></li>
</ul>
<ul class="bulleted1">
<li>8.&#160;&#160;One last setting needs to be set before writing the options to the module, and it&#x2019;s specific to this example: the baud rate. There is a single number to identify the baud rate; the default is 3 for 9600 baud. Change this setting to 6 for a baud rate of 57600. When the options are highlighted in a yellow-green, they have been changed but not written to the module. Uncheck the &#x201C;Always update firmware&#x201D; box and click the Write button in the Modem Parameters and Firmware box, which will confirm and update the settings to the module.</li>
<li>9.&#160;&#160;Once the router is configured, unplug the adapter from the computer and remove the module. Plug in the module to be used as the coordinator and repeat the steps used to configure the router, but select ZIGBEE COORDINATOR AT for the firmware options and set the destination address as the router&#x2019;s serial number. Use the same baud and pan ID as for the router module.</li>
</ul>
</div>
<div>
<p id="Sec5" class="Heading2">Arduino Setup<a id="cXXX.214" /></p>
<p class="noindent">The modules are now ready for communications, and it is time to set up the rest of the example.</p>
<ol class="OrderedList">
<li>Leave the coordinator plugged into the USB adapter and plug the router into the serial adapter.</li>
<li>Prepare an Arduino board by uploading the standard Firmata sketch as described in <a href="9781430239390_Ch03.xhtml">Chapter 3</a>. Make sure that the Arduino can communicate to the Firmata test application before plunging the router into the Arduino, as shown in <a href="#Fig1" id="_Fig1">Figure 5-1</a>.</li></ol>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig05-01.jpg" alt="9781430239390_Fig05-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 5-1</a>. </span>Arduino/XBee module configuration </p>
</div>
</div>
<div>
<p id="Sec6" class="Heading2">Verifying the Code<a id="cXXX.215" /></p>
<p class="noindent">The Firmata sketch is uploaded to the Arduino and the XBees are both plugged into the computer and Arduino. This configuration of the modules is in transparent mode, and the Firmata test app can now communicate with the Arduino. It is optional to add a few buttons, servos, or LEDs to explore the application&#x2019;s potential, or use the examples created in <a href="9781430239390_Ch03.xhtml">Chapter 3</a>. If the modules are not communicating, check the connections, settings, and selected COM port.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;You can make computer-to-computer chat possible with the XBee&#x2019;s transparent mode and serial terminals by connecting the XBee serial adapter to pins 2 and 3 of the Arduino and loading the software serial sketch onto the Arduino, changing the baud rates in the sketch to match the XBee module.</p></div>
</div>
<p id="Sec7" class="Heading1">API Mode</p>
<p class="noindent">API mode is the alternative to AT command mode. The API that is implemented with the XBee module allows programs to change internal settings, create direct routing, discover new nodes, and push remote <span class="FontName2">AT</span> commands or firmware updates, along with other advanced control options. This mode uses packets that are referred to as frames in the XBee data sheet.</p>
<p class="indent">There are currently 18 different frame types for series 2 modules; the first 4 bytes of the frame are always the same type of information, as described in <a href="#Fig2" id="_Fig2">Figure 5-2</a>.</p>
<ul class="bulleted">
<li>The first byte of the frame is always <span class="FontName2">0x7E</span><a id="cXXX.216" /> to show that a frame is starting,</li>
<li>The next two bytes are the length of the data contained in the frame; this number is the total bytes from the fourth byte to the checksum.</li>
<li>Byte 4 is the frame type; this describes the data that makes up the data section of the frame, notifying a program how to interpret the data. The frame data is specific to the frame type. The structure is outlined for the various frames in the &#x201C;API Operation&#x201D; section of the XBee data sheet; the series 2 data sheet is available at <span class="FontName1"><a href="http://ftp1.digi.com/support/documentation/90000976_K.pdf">http://ftp1.digi.com/support/documentation/90000976_K.pdf</a></span>.</li>
<li>The last byte of the frame is the checksum and is calculated by subtracting the total value of bytes from the frame type to the last byte of the frame data from <span class="FontName2">0xFF</span>. This calculation is done within a single byte, and any value above 255 is truncated. The checksum is used by the modules to help determine that the frame is formed properly before sending and can be used by the program to determine that the data received is the proper data. The frame may be malformed when a verification frame is not returned or the when frame ID byte is set to zero. The frame ID is usually the first byte of the frame data section of the frame; this is to determine what frame is being talked about when information frames are returned. The frame ID is also useful for sequential frames to determine the order when receiving frames. </li>
</ul>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig05-02.jpg" alt="9781430239390_Fig05-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 5-2</a>. </span>API packet structure </p>
</div>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Frames are what Digi&#x2019;s data sheet calls the series<a id="cXXX.97a" /> of data that is used for API mode; the term <b><i>frame</i></b> is interchangeable with <i>packet</i>.</p></div>
<div>
<p id="Sec8" class="Heading2">Module Configuration<a id="cXXX.217" /></p>
<p class="noindent">Configuring the modules for API mode is similar to the setup for the AT command configuration:</p>
<ol class="OrderedList">
<li>A single coordinator is needed. Change the firmware settings to ZIGBEE COORDINATOR API and ZIGBEE ROUTER API for the router.</li>
<li>Set the PANID along with the baud rate; you can use the same settings as before for this setup.</li>
<li>The destination address is not necessary for this mode to communicate; packets determine where the information is going.</li>
<li>Choose a name for the node identification (NI) setting when configuring the module; ROUTER and COORDINATOR will suffice. The NI setting is helpful for identifying the node. This is independent of the addresses and equivalent to a computers host name.</li>
<li>Upload the software serial sketch to an Arduino with both baud rates set to the XBee modules&#x2019; rate of 57600, and connect the serial adapter to pins 2 and 3 of the Arduino, as shown in <a href="#Fig3" id="_Fig3">Figure 5-3</a>.
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig05-03.jpg" alt="9781430239390_Fig05-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 5-3</a> </span>.&#160;&#160;Setup for API examples. The XBee is connected to pins 2 and 3 for software serial </p>
</div></li>
<li>Once the Arduino is configured, connect via a serial terminal such as PuTTY, minicom, or HyperTerminal, with the setting 57600 8N1.</li>
</ol>
<div>
<p id="Sec9" class="Heading2">API Packet Construction<a id="cXXX.218" /></p>
<p class="noindent">Before delving into writing code, I&#x2019;ll describe the X-CTU software, which provides a utility on the Terminal tab to manually build packets. With the Arduino set up and the serial program running, &#x201C;Goodnight moon!&#x201D; should be printed the Arduino&#x2019;s serial monitor, indicating everything is working. Plug the coordinator into the USB adapter, start the X-CTU software, double-check that the module can be accessed, and click the Terminal tab. On the Terminal tab is information on the line status and a few options. Click the Show Hex button to get a side-by-side ASCII-and-hex display, which will be a bit easier to read. Click the Assemble Packet button to bring up a window with an input box to place packet information; by default the input box is in ASCII mode, so make sure to select the Hex option so that the raw data can be entered.</p>
<p class="indent">The first packet you&#x2019;re going to assemble is an <span class="FontName2">AT</span> command; this is equivalent to entering <span class="FontName2">+++ ATND</span> (followed by a carriage return) in transparent mode. The <b>ND</b> command is for network discovery and will return information on all XBees that can be accessed in the network; for example, the network ID, the 64-bit address, and the plain-text name (if you set that option in the configuration). Packets are ordered from left to right or top to bottom. You can lay out the general structure of the packet on a piece of paper: the first four bytes are essentially the header that contains the start, the length, and the frame type.</p>
<p class="indent">Two of the bytes are known and can be filled in: <span class="FontName2">0x7E</span> for the start and <span class="FontName2">0x08</span> for the frame type of the <span class="FontName2">AT</span> command to be sent. The packet is not complete, so the length cannot be determined yet. The first byte after the header is the frame ID that identifies the packet and enables the response to the packet: this is going to be set to <span class="FontName2">0x01</span> because only this packet is going to be sent for this example.</p>
<p class="indent">The <span class="FontName2">AT</span> command comes after the frame ID and is the hex value of the two characters that describe the command; in this case <span class="FontName2">N</span> (<span class="FontName2">0x4E</span>) and <span class="FontName2">D (0x44</span>) for the node-discovery command. Following the <span class="FontName2">AT</span> command characters is the setting value used when changing the setting for this packet, No setting change is needed, so no more bytes are added to this packet. The last byte of the packet is the checksum, which is calculated using the bytes that make up the frame packet with the frame type byte, so add the following value:</p>
<pre><span class="FontName2">0x08 +0x01+0x4E+0x44&#160;&#160;= 0x9B</span></pre>
<p class="indent">Then subtract this value from <span class="FontName2">0xFF</span> to get the checksum value:</p>
<pre><span class="FontName2">0xFF &#x2013; 0x9B = 0x64</span></pre>
<p class="indent">The last byte to calculate is the size, which is done by counting the bytes between the size and the checksum (or the bytes used to calculate the checksum); in this case the size is 4 bytes. The final packet looks like this:</p>
<pre><span class="FontName2">0x7E 0x00 0x04 0x08 0x01 0x4E 0x44 0x64</span></pre>
<p class="indent">With the packet manually calculated, enter the bytes into the packet-assembly window in the X-CTU software and send the data to the module connected to the computer. The node-discovery command sent will discover the other modules that can receive data from the coordinator. After the command was sent, a reply packet will be received that contains information on the nodes seen. The header of this packet will be <span class="FontName2">0x7E</span> followed by the size and the frame type <span class="FontName2">0x88</span>, indicating that it is a response to the <span class="FontName2">AT</span> command sent. Any received frame will be identified by the frame type, and can be compared to the packet type lists later on to help determine how to interpret the frame.</p>
<p class="indent">In the frame data, the first byte is the frame ID, which should match the frame ID originally sent, followed by the command being responded to (which should be <span class="FontName2">ND</span>) and the command status of <span class="FontName2">0x00</span>, indicating that the command was successful. The rest of the data contained in packet includes the 16-bit network address, the 64-bit serial number, a space, the node identifier, the parent network address, the device type, the status, the profile ID, the manufacture ID, and the checksum. If the node-identifier variable was set on all the modules, their plain-text ID should be readable; in this example, the string <span class="FontName2">ROUTER</span> should be clear on the ASCII side of the terminal window.</p>
</div>
<div>
<p id="Sec10" class="Heading2">Sending Commands<a id="cXXX.219" /></p>
<p class="noindent">There are two frame types that affect the local module:</p>
<ul class="bulleted">
<li>The <span class="FontName2">AT</span> command frame (<span class="FontName2">0x08</span>), which will immediately change values.</li>
<li>The <span class="FontName2">AT</span> command queue (<span class="FontName2">0x09</span>), which holds changes until the apply-changes (<span class="FontName2">AC</span>) command has been issued or a subsequent <span class="FontName2">AT</span> command (<span class="FontName2">0x08</span>) is sent.</li>
</ul>
<p class="indent">The ability to send <span class="FontName2">AT</span> commands to a remote module is a unique function that is not available in AT command mode. Sending remote <span class="FontName2">AT</span> commands uses a frame type of <span class="FontName2">0x17</span> and is constructed in a similar fashion as the local <span class="FontName2">AT</span> frame (<span class="FontName2">0x08</span>). There is extra data contained in the frame data section after the frame ID byte:</p>
<ul class="bulleted">
<li>First is the 64-bit destination address followed by the 16-bit network address. For the example following, (<span class="FontName2">0x00 00 00 00 00 00 FF FF</span>) will be used for the 64-bit and (<span class="FontName2">0xFF FE</span>) for 16-bit.</li>
<li>The next byte is a command option; it has the same effect if set to <span class="FontName2">0x00</span> as the <span class="FontName2">AT</span> command queue and needs the <span class="FontName2">AC</span> command to finalize the changes. The other options for the command option byte are <span class="FontName2">0x02</span> to apply the changes immediately, <span class="FontName2">0x20</span> to use encryption if globally set in the <span class="FontName2">EE</span> register, and <span class="FontName2">0x40</span> to use a longer transmission timeout. Settings <span class="FontName2">0x00</span> and <span class="FontName2">0x02</span> are the only two of interest for this example.</li>
<li>The <span class="FontName2">AT</span> command is after the command option byte; the node-discovery command will be used for this packet to see what the ROUTER module can transmit to.</li>
</ul>
<p class="indent">The example packet is the following:</p>
<pre><span class="FontName2">0x7E 0x00 0x0F 0x17 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0xFF 0xFF 0xFF 0xFE 0x00 0x4E 0x44 0x5A</span></pre>
<p class="indent">The example packet sends a request to all devices on the network, asking for those modules to perform a node discovery and send back their findings to the originating device. The return packet follows the same structure as any other packet, with the header, frame data, and checksum being in the same order. The returned packet&#x2019;s frame data has the 64- and 16-bit network address of the remote module added between the frame ID and the command bytes. The frame data is identical in structure to the local command, excluding the added address bytes. The value for this frame type is <span class="FontName2">0x97</span>.</p>
<p class="indent">The example remote <span class="FontName2">AT</span> command packet will execute on all the modules that can hear the coordinator. On large networks this can cause talk-over communication packet corruptions and is not advisable. In some situations broadcasting a change-setting packet is needed, as when changing the pan ID of the whole network or changing encryption settings. When changing settings across an entire network, change and apply the settings to the remote modules before changing the local module.</p>
</div>
<div>
<p id="Sec11" class="Heading2">Sending Data<a id="cXXX.220" /></p>
<p class="noindent">Up to this point, configuration packets have been constructed and sent, but no data has been sent through to the Arduino that is connected to the serial program. The packets for sending data are constructed in the same order as the <span class="FontName2">AT</span> command packets, with the frame IDs being <span class="FontName2">0x10</span> and <span class="FontName2">0x11</span>.</p>
<ul class="bulleted">
<li>The <span class="FontName2">0x10</span> data packets are general-purpose data containers that leave the network routing up to the modules.</li>
<li>In contrast, <span class="FontName2">0x11</span> packets have more options on how the packet should reach its destination.</li>
</ul>
<p class="indent">Digi provides a web-based utility that makes the manual assembly of packets easy; it&#x2019;s available at <span class="FontName1"><a href="http://ftp1.digi.com/support/utilities/digi_apiframes.htm">http://ftp1.digi.com/support/utilities/digi_apiframes.htm</a></span>. The utility calculates the errorsum and the size bytes for any of the frame types, with a convenient layout of the byte field. To use this utility, select the frame ID to be constructed.</p>
<ol class="OrderedList">
<li>For this example, select the request transmit (<span class="FontName2">0x10</span>), and use the broadcast address of <span class="FontName2">0x00 00 00 00 00 00 FF FF</span> for the 64-bit address and <span class="FontName2">0xFF FE</span> for the 16-bit address.</li>
<li>Leave the other options as they are and add the hexadecimal equivalent of &#x201C;HELLO&#x201D; to the RF packet field (<span class="FontName2">0x48 45 4C 4C 4F</span>).</li>
<li>The button next to the packet field will build the packet that needs to be entered into the packet assembly window of the X-CTU. The packet should appear as follows:
<pre><span class="FontName2">7E 00 13 10 01 00 00 00 00 00 00 FF FF FF FE 00 00 48 45 4C 4C 4F 7F</span></pre></li></ol>
<p class="indent">On the local module&#x2019;s side, the return packet is of frame type <span class="FontName2">0x8B</span> and contains the 16-bit destination address, the number of transmit retries, the delivery status, and the discovery status. If both broadcast addresses are used, the 16-bit network address will be <span class="FontName2">0xFF FE</span> if the 64-bit address of the module was used in transmitting with the <span class="FontName2">0xFF FE</span> network address. The returned packet will have discovered the actual network address of the remote module. The three bytes after the network address indicate status&#x2014;if the values come back as zeros, then the transition succeeded for the example packet.</p>
<p class="indent">The Arduino that has the receiving XBee connected should have echoed the packet to the screen. The packet shows up in the serial program as the printable characters, making most of the packet unreadable, but the data section should be a clearly readable &#x201C;HELLO.&#x201D; The packet received that is echoed is the reply packet with frame type <span class="FontName2">0x90</span>. This packet has no frame ID, the bytes after the frame type are the 64-bit and 16-bit addresses. The byte after the network address and before the data is a <i>status byte</i>; this byte provides the program with information that can be valuable when dealing with this packet. The status byte is a sum of four possible options:</p>
<ul class="bulleted">
<li><span class="FontName2">0x01</span>: Packet was acknowledged</li>
<li><span class="FontName2">0x02</span>: Packet was acknowledged and is a broadcast</li>
<li><span class="FontName2">0x20</span>: Packet is encrypted</li>
<li><span class="FontName2">0x40</span>: Packet was sent from an end device</li>
</ul>
<p class="indent">So, for example, if the byte is sent from an end device with a broadcast, the byte will have a value of <span class="FontName2">0x22</span>.</p>
<p class="indent">The remaining bytes that complete the packet are the data and checksum.</p>
</div>
<p id="Sec12" class="Heading1">Request Packets</p>
<p class="noindent"><a href="#_Tab1" id="Tab1">Table 5-1</a> is a reference for the various packets that can be used to control the XBee modules. The frame name, the frame type, a general description, and the frame data are provided. Remember that the frame type is the last byte of the header, and following the frame data is the checksum.</p>
<div class="Table">
<p class="TabCapt"><span class="CaptNr"><a href="#Tab1" id="_Tab1">Table 5-1.</a> </span>Packet Reference<a id="cXXX.221" /> </p>
<p class="img"><img src="images/Table5-1.jpg" alt="Table5-1.jpg" /></p>
</div>
<p id="Sec13" class="Heading1">Reply Packets<a id="cXXX.222" /></p>
<p class="noindent"><a href="#_Tab2" id="Tab2">Table 5-2</a> shows the packets that are usually formed in a response to another packet. They are created outside of the program that creates the packet. These packets contain information that needs to be phrased so that the program can use the information. These packets still follow the same general structure as the request packets.</p>
<div class="Table">
<p class="TabCapt"><span class="CaptNr"><a href="#Tab2" id="_Tab2">Table 5-2.</a> </span> </p>
<p class="img"><img src="images/Table5-2(a).jpg" alt="Table5-2(a).jpg" /><br/><img src="images/Table5-2(b).jpg" alt="Table5-2(b).jpg" /></p>
</div>
<p id="Sec14" class="Heading1">Arduino Data Echo<a id="cXXX.103a" /></p>
<p class="noindent">With a bit of understanding of the formation and reading of packets, this example will demonstrate in code the phrasing, retransmission, and construction of packets the code receives. The code will run on the Arduino and take incoming data packets (<span class="FontName2">0x90</span>) from any module in the network and pull the data out to reassemble the packet and retransmit back to the original source.</p>
<p class="indent">While the packet gets transmitted to the source, the code will print relative data to a serial monitor, such as a notification when an incoming packet has been received, the raw packet itself, addresses of the originating source, and the raw reply packet for sending. The code currently identifies and displays two different packets types (<span class="FontName2">0x90</span>) and (<span class="FontName2">0x8B</span>). This is accomplished through a <span class="FontName2">switch</span> statement<a id="cXXX.223" /> after the whole packet has been captured.</p>
<p class="indent">The <span class="FontName2">switch</span> statement is pretty effective and can be expanded to recognize and handle current packet types plus any future additions. The packets are received and constructed in a byte array of 80 bytes, which is done to buffer the packets and to help ensure they&#x2019;re complete before any phrasing is done or transmission starts. Although the XBee modules are capable of sending packets of greater sizes, this limit is to save on some space on the Arduino.</p>
<p class="indent">The setup is the same as in <a href="#Fig3">Figure 5-3</a>, previously. The code uses software serial at 9600 baud and standard serial at 57600 baud; the XBee modules have to be reconfigured to 9600 baud. There are two ways to reconfigure the baud settings:</p>
<ul class="bulleted">
<li>Use the X-CTU software to set the baud back to setting 3.</li>
<li>Construct and issue two <span class="FontName2">AT</span> command packets<a id="cXXX.224" />: one for the remote module and the other for the local module. The <span class="FontName2">AT</span> command is <span class="FontName2">BD</span> or <span class="FontName2">0x42 44</span>, with the parameter being 3.</li>
</ul>
<p class="indent">Both require you to change the X-CTU COM setting<a id="cXXX.225" /> back to 9600 to accommodate the new setting. This example is one-sided, so packets sent to the Arduino will still have to be constructed in the terminal of the X-CTU; the HELLO packet will work for this example, although any properly formed transmit request will work with this code. To finish the setup for this example, step through the code and upload it to the Arduino.</p>
<p class="indent"><a href="#list1" id="_list1">Listing 5-1</a> is comprised of three parts. The first part sets up the variables<a id="cXXX.226" /> and all the initialization of the Arduino&#x2019;s serial connections before entering the loop function. The loop functions waits for the software serial to be available and checks for the packet start byte of <span class="FontName2">0x7E</span>. A loop captures<a id="cXXX.227" /> the packet and counts the incoming bytes while the software serial is available. When the packet is received, the user is informed of the incoming packet along with the contents of the raw packet by printing the details to the serial monitor before processing the packet. The first part of packet processing is to calculate the checksum<a id="cXXX.228" /> by calling a function. If the checksum is correct, the program continues with parsing the packet and constructing and sending a reply packet that contains the same data that the received packet contained.</p>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 5-1.</i></b></a>&#160;&#160;<i>Arduino Packet Echo Code, Part 1 of 3</i></p>
<pre><span class="FontName2">#include &#x003C;SoftwareSerial.h&#x003E;</span><br /><span class="FontName2">byte incomePacket[80];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // buffer for incoming data</span><br /><span class="FontName2">char incomeData [64];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// phrased data holder</span><br /><span class="FontName2">byte replyPacket[80];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// packet construction buffer</span><br /><span class="FontName2">byte sourceADR[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// source addresses</span><br /><span class="FontName2">int datalen;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // length of data received</span><br /><span class="FontName2">int count;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // total length of incoming packet</span><br /><span class="FontName2">int length;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// misc. length holder</span><br /><span class="FontName2">byte calcsum ;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // checksum</span><br /><span class="FontName2">SoftwareSerial softSerial(2, 3);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // the main software serial</span><br /><br /><span class="FontName2">void setup()&#160;&#160;{</span><br />&#160;&#160; <span class="FontName2">Serial.begin(57600);&#160;&#160;&#160;&#160;&#160;&#160;// serial to monitor</span><br />&#160;&#160; <span class="FontName2">softSerial.begin(9600);&#160;&#160; // serial to XBee</span><br />&#160;&#160; <span class="FontName2">Serial.println(&quot;Ready&quot;);</span><br /><span class="FontName2">} // end setup</span><br /><br /><span class="FontName2">void loop(){</span><br />&#160;&#160;<span class="FontName2">if (softSerial.available() &#x0026;&#x0026; 0x7E == softSerial.read() ){ // check for start byte</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomePacket[0] = 0x7E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">count = 1;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">while (softSerial.available()){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomePacket[count] =&#160;&#160;softSerial.read();&#160;&#160;// receive the incoming packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">count ++;&#160;&#160;// keep track of incoming bytes</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;// end while (softSerial.available())</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot;Recived a new packet&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot;Incoming packet is: &quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; count-1 ; i++){&#160;&#160; // print raw packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (incomePacket[i],HEX);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&#x0027; &#x0027;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (incomePacket[count-1],HEX);&#160;&#160; // last byte of the raw packet</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">calcChecksum ();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (calcsum == incomePacket[count-1]){&#160;&#160;// throw error if the checksum does not match</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">processPacket();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">} // end if calcsum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot;Error packet is not proper&quot;);&#160;&#160;// the error when packets are malformed</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">while (softSerial.available()){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">softSerial.read();&#160;&#160;// on error flush software serial buffer</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">}// end looking for start byte</span><br /><span class="FontName2">}// end loop</span></pre>
<p class="indent">Part 2 of the program contains the functions to calculate the checksum and parse the packets&#x2019; data. The <span class="FontName2">calcChecksum</span> function<a id="cXXX.229" /> pulls the length of the packet from the first two bytes after the packet start, and then the checksum is calculated before retuning back to the loop function. When the <span class="FontName2">processPacket</span> function<a id="cXXX.230" /> is called, the user is informed that the packet has the correct checksum; the code then determines the packet type using the fourth position of the packet. The <span class="FontName2">switch</span> statement responds to a transmission-reply packet (<span class="FontName2">0x8B</span>) and a data-receive packet (<span class="FontName2">0x90</span>). The transmission-reply packet is handled by informing the user by printing to the serial monitor. The data packet is handled by parsing out the address of the sending XBee and pulling out the data to be used to construct a reply packet. During the whole process, the information is printed to the serial monitor.</p>
<p class="noindent2"><b><i>Listing 5-1.</i></b>&#160;&#160;<i>Arduino Packet Echo Code, Part 2 of 3</i></p>
<pre><span class="FontName2">void calcChecksum () {</span><br />&#160;&#160;<span class="FontName2">calcsum =0;&#160;&#160;&#160;&#160; // begin calculating errorsum of incoming packet</span><br />&#160;&#160;<span class="FontName2">length = incomePacket[1] +incomePacket[2];</span><br />&#160;&#160;<span class="FontName2">for (int i = 3 ; i &#x003C;= length+2 ; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">calcsum = calcsum + incomePacket[i];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">calcsum = 0xFF - calcsum;&#160;&#160;// finish calculating errorsum</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160; // end void calcChecksum ()</span><br /><br /><span class="FontName2">void processPacket(){</span><br />&#160;&#160;<span class="FontName2">Serial.println (&quot;Packet has correct checksum &quot;);</span><br />&#160;&#160;<span class="FontName2">switch (incomePacket[3]){&#160;&#160;// check packet type and perform any responses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x90:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot;The packet is a data packet&quot;); // announce packet type</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 4 ; i &#x003C;= 13 ; i++){&#160;&#160;// get both addresses of the source device</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">sourceADR[i-4]= incomePacket[i];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">datalen = count - 16 ;&#160;&#160;// reduce to just the data length to get the data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 15 ; i &#x003C; datalen+15 ; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomeData [i-15] = incomePacket[i]; // phrase out the data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot;source addess is: &quot;);&#160;&#160;// begin printing 64 bit address</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i =0 ; i &#x003C; 7 ; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (sourceADR[i],HEX);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&#x0027; &#x0027;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (sourceADR[7],HEX); // finish 64-bit address</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot;network addess is: &quot;); // begin printing 16-bit address</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print(sourceADR[8] ,HEX);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&#x0027; &#x0027;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println(sourceADR[9] ,HEX); // finish 64-bit address</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&quot;the packet contains: &quot;);&#160;&#160;// start printing the data from packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i =0 ; i &#x003C; datalen ; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (incomeData [i]);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot; : For data&quot;);&#160;&#160; // finish the data print</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">constructReply();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break; // done with the received packet</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x8B: //start response to the return packet from sending data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot;Received reply &quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">default: // anouce unknown packet type</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (&quot;error: packet type not known&quot;);</span><br />&#160;&#160;<span class="FontName2">}// end switch</span><br /><span class="FontName2">}&#160;&#160;&#160;&#160;// end processPacket()</span><br />&#160;&#160;</pre>
<p class="indent">Part 3 of the code echoes the data received from another XBee. The reply packet is built one byte at a time in an array starting with the packet start frame, the type, and the frame ID. Portions of the packet that are a single-byte setting are set one at a time. The parts of the packet that are from the received packet are added to the outgoing packet via <span class="FontName2">for</span> loops (the parts added include the address to send the new packet to and a copy of the received data). When the packet is almost complete, the packet size is calculated and added. The final calculation to be added to the packet is for the checksum before the packet is sent, and the program continues waiting for new packets.</p>
<p class="noindent2"><b><i>Listing 5-1.</i></b>&#160;&#160;<i>Arduino Packet Echo Code, Part 3 of 3</i></p>
<pre><span class="FontName2">void constructReply(){</span><br />&#160;&#160;<span class="FontName2">Serial.println (&quot;Constructing a reply packet&quot;); // announce packet construction</span><br />&#160;&#160;<span class="FontName2">// start adding data to the reply packet buffer</span><br />&#160;&#160;<span class="FontName2">replyPacket[0] = 0x7E;&#160;&#160;&#160;&#160;// start byte</span><br />&#160;&#160;<span class="FontName2">replyPacket[1] = 0; // 1st address byte will be zero with current limitations</span><br />&#160;&#160;<span class="FontName2">replyPacket[3] = 0x10;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// frame type</span><br />&#160;&#160;<span class="FontName2">replyPacket[4] =&#160;&#160;1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // frame ID</span><br />&#160;&#160;<span class="FontName2">for (int i =5 ; i &#x003C;= 14 ; i++){&#160;&#160;&#160;&#160; // add addresses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">replyPacket[i] = sourceADR[i-5] ;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">replyPacket[15] = 0 ;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set both options</span><br />&#160;&#160;<span class="FontName2">replyPacket[16] = 0 ;</span><br />&#160;&#160;<span class="FontName2">for (int i =17 ; i &#x003C; datalen+17 ; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">replyPacket[i] =&#160;&#160;incomeData [i-17];&#160;&#160;// add data to packet</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">replyPacket[2] = 14 + datalen ;&#160;&#160;&#160;&#160;&#160;&#160;// set the lower length byte</span><br />&#160;&#160;<span class="FontName2">calcsum = 0; // start calculating errorsum</span><br />&#160;&#160;<span class="FontName2">replyPacket[17 + datalen] = 0;</span><br />&#160;&#160;<span class="FontName2">for (int i = 3 ; i &#x003C;= replyPacket[2]+3 ; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">calcsum = calcsum + replyPacket[i];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">replyPacket[17 + datalen]= 0xFF - calcsum; // finish packet by adding checksum</span><br />&#160;&#160;<span class="FontName2">Serial.print (&quot;The packet is: &quot;);&#160;&#160;// start printing raw packet before sending</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C; replyPacket[2]+3 ; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (replyPacket[i],HEX);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (&#x0027; &#x0027;);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">Serial.println (replyPacket[17 + datalen],HEX); // finish printing packet</span><br />&#160;&#160;<span class="FontName2">Serial.println (&quot;Sending Packet&quot;);&#160;&#160; // start sending packet to original source</span><br />&#160;&#160;<span class="FontName2">for (int i =0 ; i &#x003C;= 17 + datalen ; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">softSerial.write ( replyPacket[i]);</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end void constructReply()</span></pre>
<p class="indent">With everything compiled and hooked up, a prepared packet can be sent from the X-CTU&#x2019;s packet-assembly window. Watch the code&#x2019;s actions in a serial monitor that is connected to the Arduino. The serial monitor<a id="cXXX.231" /> should start printing information when a packet is received and proceed through the programmed responses. This code is a demonstration of packet handling and sometimes messes up on receive and transmit packets, because of the lack of more robust error correction.</p>
<p class="indent">To make the error checking<a id="cXXX.232" /> a bit more robust, you can the check the reply packet against the created checksum for the new packet and re-create it before the packet is sent. Other error checking can be performed with flow control, timeouts, resends, and packet-acknowledgement communication. The transmit status frame type (<span class="FontName2">0x8B</span>) that is returned when a packet is sent does not indicate that the packet was successfully received by anything other than XBee modules. A microcontroller should form a reply packet to the state of a received packet if the incoming packets are from serial out from an XBee module. This method of packet handling is demonstrated in greater depth in <a href="9781430239390_Ch08.xhtml">Chapter 8</a>.</p>
<p class="indent">If the code in <a href="#list1">Listing 5-1</a> does not respond, resend the packet a few times before checking the configurations. You can also issue an <span class="FontName2">ND</span> command to check the XBee radio connection. If the radios can see one another, double-check the serial connections on the Arduino and, if necessary, revert to the software serial, and then double-check the code.</p>
<p id="Sec15" class="Heading1">Endpoint Firmware<a id="cXXX.107a" /></p>
<p class="noindent">The last firmware option is that of endpoint for both AT and API modes. They act similarly to any other module firmware by issuing and receiving data. However, unlike the router and coordinator, end devices do not route packets to other devices. End devices also have the capability to enter sleep mode because they do not store routing information. Sleep mode makes end devices the preferred choice when making remote sensors or controllers that need low power consumption.</p>
<p class="indent">There are three types of sleep configuration<a id="cXXX.233" /> that are set via the sleep mode (<span class="FontName2">SM</span>) register:</p>
<ul class="bulleted">
<li>Setting a value of 1 in the <span class="FontName2">SM</span> register will put the module in hibernate mode. When XBee pin 9 is high, the module will not respond to any transmissions or requests, but will return from sleep.</li>
<li>Setting the <span class="FontName2">SM</span> register to 4 is for cyclic sleep. In this mode, the endpoint module will still respond to incoming transmissions. When using API mode, the extended timeout option (<span class="FontName2">0x40</span>) needs to be set in the packet&#x2019;s transmit options, giving the end device time to wake up and respond. The controlling program in this mode must wait till the Clear to Send (CTS) flow-control line is low.</li>
<li>Setting the value to 5 works the same as 4, but allows a transition from low to high on XBee pin 9 to wake the module for transmission.</li>
</ul>
<p class="indent">Endpoint modules have the capability to connect to either routers or coordinators. The code and setup for the last example will work for the end device.</p>
<ol class="OrderedList">
<li>For this setup, reconfigure the router module with ZIGBEE END DEVICE API<a id="cXXX.234" />.</li>
<li>Use the same settings to create a network, change the node identifier to ENDDEVICE,<a id="cXXX.235" /> set the <span class="FontName2">SM</span> register to 4, and connect back to the Arduino.</li>
<li>Reconstruct the HELLO packet<a id="cXXX.236" /> with <span class="FontName2">0x40</span> in the options byte, and send this packet to watch the code work. In this configuration, when the end device receives a packet, it will be awake for a period of time to allow the module to transmit the outgoing packet.</li>
</ol>
<p class="indent">The next example (see <a href="#list2" id="_list2">Listing 5-2</a>) Arduino sketch uses sleep mode 5, demonstrating a method of allowing other modules in the network to wake and send data to the end device, while allowing the code to wake up the module to send data. The code examples use the setup in <a href="#Fig4" id="_Fig4">Figure 5-4</a>; the only change to the Arduino connections is that an extra connection is added between the serial adapter and the Arduino, connecting XBee pin 9 to Arduino pin 9. Both modules need to be set with AT command mode firmware&#x2014;ZIGBEE COODINATOR AT for one and ZIGBEE END DEVICE AT for the other. The modules need the destination addressed set to be able to communicate. When configuring the end device, set the <span class="FontName2">SM</span> register to 5, allowing the code and other external events wake up the module.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 5-2.</i></b></a>&#160;&#160;<i>Arduino Dual-Direction Communication with Sleep Mode Communications</i><a id="cXXX.237" /></p>
<pre><span class="FontName2">#include &#x003C;SoftwareSerial.h&#x003E;</span><br /><span class="FontName2">SoftwareSerial mySerial(2, 3); //rx,tx</span><br /><span class="FontName2">void setup()&#160;&#160;{</span><br />&#160;&#160;<span class="FontName2">pinMode (9 , OUTPUT);</span><br />&#160;&#160;<span class="FontName2">Serial.begin(9600);</span><br />&#160;&#160;<span class="FontName2">Serial.println(&quot;Ready&quot;);</span><br />&#160;&#160;<span class="FontName2">mySerial.begin(9600);</span><br /><span class="FontName2">} // end setup</span><br /><br /><span class="FontName2">void loop() {</span><br />&#160;&#160;<span class="FontName2">digitalWrite (9 , LOW);</span><br />&#160;&#160;<span class="FontName2">if (mySerial.available())</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Serial.write(mySerial.read());</span><br />&#160;&#160;<span class="FontName2">if (Serial.available()){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (9 , HIGH);&#160;&#160;// transition from LOW to HIGH to wake up module</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (2);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (9 , LOW);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// delay to give the chip time to recognize the transition</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">mySerial.write(Serial.read());</span><br />&#160;&#160;<span class="FontName2">} // end if (Serial.available())</span><br /><i>}&#160;&#160; // end loop</i>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </pre>
<div class="Figure" id="Fig4">
<p class="img"><img src="images/9781430239390_Fig05-04.jpg" alt="9781430239390_Fig05-04.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig4">Figure 5-4</a>. </span>End-device configuration </p>
</div>
<p class="indent">The code is a simple chat-style program that can receive data from another XBee and transmit data itself. With everything configured and plugged in, start a serial program to monitor and send data from the Arduino; use the terminal in the X-CTU&#x2019;s terminal for the coordinator. Any data typed into either terminal will show up on the other terminal. When typing in the terminal for the Arduino, the code does not echo the typed data back to the terminal; the local echo in the terminal would need to be set for you to see the typed characters. This setup is good when devices need to access or poll from the end device when power consumption is a concern.</p>
<p id="Sec16" class="Heading1">Summary</p>
<p class="noindent">This chapter demonstrated working with XBee modules in both AT command mode and API packet mode. There are a lot more configuration and communication options available, such as implementing encryption, working with other ZigBee-compatible devices, and using the other available pins for analog-to-digital sensors or controlling PWM. The XBee data sheet for the modules provides a wealth of information. This chapter did not discuss setting up a large network of XBees, but the concepts described are scalable.</p>
</div></div>
</body>
</html>