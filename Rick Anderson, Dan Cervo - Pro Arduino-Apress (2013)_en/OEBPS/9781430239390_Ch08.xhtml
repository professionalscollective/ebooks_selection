<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>CHAPTER 8 Android Sensor Networks</title>
<link href="9781430239390.css" rel="stylesheet" type="text/css" />
</head>
<body>
<p class="ChapterNumber"><a id="Chap8" />CHAPTER 8</p>
<p class="chapimage"><img src="images/frontdot.jpg" alt="image"/></p>
<p class="ChapterTitle">Android Sensor Networks</p>
<div>
<p class="noindent">A sensor network<a id="cXXX.143a" /> is a series of stand-alone distributed sensor nodes that communicate information to a gateway for retrieval. Sensor networks are used to monitor a wide range of conditions over a greater area than is possible with a single sensor package. There is no typical setup for a sensor network; networks can range from just a few nodes to hundreds, collecting any kind of imaginable data. Sensor networks are commonly used for industrial, security, and scientific applications and can be set up as passive data collectors or active controllers. Sensor networks are not made upon any single technology; they are made by integrating a variety of other technologies.</p>
<p class="indent">Arduino provides a great development platform for sensor packages for data logging and system control. A sensor node is created when a sensor package is integrated with a communication method such as Bluetooth, Ethernet, XBees, Cellular/GSM, or light to create a network. Arduino has been used to make sensor networks to monitor environmental changes. For example, a distributed sensor network was created for the Fukushima nuclear disaster to keep track of radiation levels. The network for Fukushima used a combination of GSM and Ethernet to pass information from a Geiger sensor to a web service. Sebastian Alegria, a high-school student from Chile, created another successful example of a sensor network to detect and warn of earthquakes. Sebastian&#x2019;s system used a simple seismometer to detect events that could cause destruction, his system passed the information through the Internet via Ethernet and used a buzzer to provide a local warning.</p>
<p class="indent">Sensor networks don&#x2019;t have to be as grand as these two examples, however. For example, they can be made to monitor temperatures around a house or keep track of inventory being shipped out of a warehouse. When developing a sensor network, keep in mind of all the development requirements and choose the sensors and communication methods accordingly. For systems that monitor a smaller area, XBee modules can be used to avoid the need to run cabling. In harsh environments, a network that uses cabling might be needed. XBee modules and cable-based systems are great methods for creating stand-alone networks that don&#x2019;t rely on other infrastructure systems but limit the range in which a sensor network can feasibly be created. To increase a senor network to a range that can monitor across a country or the world, it might be preferential to use an existing communication infrastructure, such as the Internet or telephone.</p>
<p class="indent">Android is a useful platform to integrate into a sensor network because of the variety of roles it can fill, along with its popularity and ease of development. Android can be used as a method to receive or send sensor information via a web service. Bluetooth can be used to wirelessly obtain data from a factory&#x2019;s sensor network. Android in conjunction with the Open Accessory development kit can provide a portable method to retrieve data from a stand-alone sensor network.</p>
<p class="indent">This chapter focuses on building a small sensor network that integrates XBees, Android, and Arduino. The sensor network uses hardware that has been used in other chapters. The Mega ADK, SD breakout, XBee modules, XBee adapters, and an Android device are all required for this chapter. openFrameworks, Eclipse, and Arduino IDEs will also need to be available to complete the sensor network in this chapter.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Caution</b>&#160;&#160;This chapter uses concepts from and builds upon <a href="9781430239390_Ch03.xhtml">Chapters 3</a>, <a href="9781430239390_Ch04.xhtml">4</a>, and <a href="9781430239390_Ch05.xhtml">5</a>. I recommend reading these chapters (on openFrameworks, the Android ADK, and XBees, respectively) before continuing with this chapter.</p></div>
<p id="Sec1" class="Heading1">Setting Up<a id="cXXX.194a" /> a Sensor Network</p>
<p class="noindent">When starting the development of a sensor network, decide what information<a id="cXXX.301" /> needs to be collected. This will help when qualifying sensor types. After determining the information to be collected, make a list of the requirements for the environment that the sensor network is to be deployed in. The environment has the biggest impact on what technologies to use; in an urban environment, power may be more readily available than in a rural or wilderness environment, where power may have to be generated or batteries extensively used. Wireless is probably the easiest type of node to deploy, but may have some reliability issues in environments with high electromagnetic interference; in such cases, shielded cabling may need to be run. The communication method also needs to not interfere with the sensor readings. If RF information is being collected, wireless may have to be avoided or the interference may have to be zeroed out of the information. In some special cases, fiber optics may be the best choice.</p>
<p class="indent">The sensor&#x2019;s resolution<a id="cXXX.302" /> is one factor that can determine the resolution of the whole network. The resolution can also be determined by the collection rate required by the system being monitored, with the amount of data collected to be sufficient for the application. The requirements need to be considered when starting to develop a sensor network. Systems that monitor machinery may require continuous sensor output every few milliseconds or even seconds, while networks measuring tidal flow may only need to be read every few minutes or even once an hour to achieve sufficient resolution. Some other requirements to plan for are how the collected data will be processed. The network will need sufficient processing power if the data needs to be processed in real time. The network will need to store the data if it&#x2019;s to be processed at a later time than when it is collected.</p>
<p class="indent">Sensor networks do not need to be complex or use a lot of hardware in the initial development stages. Usually a sensor network has one gateway for the data and one to a few different node types to collect the data. Building a sensor network can start with a one or two nodes and a gateway and be planned to be expandable. In the initial stages of development, the passing of data is more important than the data itself. The data can be simulated to provide a constant to compare how successful the data transmission is.</p>
<p class="indent">The example in this chapter sets up a simple sensor network<a id="cXXX.303" /> that demonstrates the integration of some of the technologies and concepts introduced in earlier chapters. The example is not a complete project to make a fully working sensor network.</p>
<p class="indent">The example creates a simulated sensor node with three different sensors that transmit predefined data for each sensor to the Mega ADK for logging and further retrieval by the Android device. The XBee modules are set up as router and coordinator in API mode with a baud of 115200. The pan ID needs to match on both XBees, but there is no need for the destination address to be set. The code implements a bit of error correction to ensure that the data is logged properly to the SD card and the serial connections stay synced. The Android device will be set up to pull a log from the Mega ADK and display the data via a graph. The Arduino connects the Android device, SD card, and XBee to create a data gateway. The Arduino also responds to the sensor node to confirm data was received or that the packet was malformed. <a href="#Fig1" id="_Fig1">Figure 8-1</a> shows the configuration of the Arduino Mega ADK.</p>
<div class="Figure" id="Fig1">
<p class="img"><img src="images/9781430239390_Fig08-01.jpg" alt="9781430239390_Fig08-01.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig1">Figure 8-1</a> </span>.&#160;&#160;Arduino setup for sensor log node<a id="cXXX.304" /> </p>
</div>
<p class="indent">As shown in <a href="#Fig1">Figure 8-1</a>, the XBee module is connected to serial 3 on the Mega ADK; other connections are TX to RX and RX to TX, with the 5V and GND pins connected accordingly. On the SD adapter, the DI and DO pins are connected to the MOSI and MISO pins on the Mega ADK, CLK is connected to SCK, CS is connected to Arduino pin 10, and CD is connected to pin 2.</p>
<p class="indent">Set up the Arduino Mega ADK as shown in <a href="#Fig1">Figure 8-1</a>, with the XBee module configured as the router and inserted in the serial adapter, and the coordinator plugged into the USB adapter. Individually testing each component attached to the Mega ADK before developing the code is vital to ensure that the hardware will not present many problems in the debugging stages. To test that the SD card can read and write, open the <span class="FontName2">ReadWrite</span> sketch<a id="cXXX.305" /> in File <img src="images/arrow.jpg" alt="image" />Examples <img src="images/arrow.jpg" alt="image" /> SD and add the line <span class="FontName2">pinMode (53, OUTPUT);</span> to make sure the slave select pin will not pull the Arduino out of SPI master mode. Change the line <span class="FontName2">if (!SD.begin(4))</span> to <span class="FontName2">if &quot;(!SD.begin(10))&quot;</span> to map the SD card to the chosen slave-activation pin. Insert an SD card into the adapter and upload the <span class="FontName2">ReadWrite</span> sketch to the board. Start the serial monitor at baud 9600 and check that the sketch successfully runs.</p>
<p class="indent">To test the XBee modules, open the software serial sketch example and modify it to accommodate the serial of the Arduino Mega ADK by changing all occurrences of <span class="FontName2">mySerial</span> to <span class="FontName2">Serial3</span>. Before uploading the sketch, remove the <span class="FontName2">#include</span> and <span class="FontName2">SoftwareSerial</span> code lines at the beginning of the program and change both baud rates to 115200 to match the current XBee configuration. Once the programs is running on the Arduino, plug in the USB explorer to a computer and start the X-CTU software, and try sending the HELLO packet from <a href="9781430239390_Ch05.xhtml">Chapter 5</a>. The packet is</p>
<pre><b>7E 00 13 10 01 00 00 00 00 00 00 FF FF FF FE 00 00 48 45 4C 4C 4F 7F</b></pre>
<p class="indent">The packet should be entered into the packet assembly window in the terminal tab of the X-CTU software. The packet should show up on the serial monitor with a few unreadable characters along with a readable &#x201C;HELLO.&#x201D; You don&#x2019;t need to test the Android ADK functionality if you&#x2019;ve already completed the corresponding exercise in <a href="9781430239390_Ch05.xhtml">Chapter 5</a>. The coding can begin for the sensor network components once the XBee and the SD card have been successfully tested.</p>
<p id="Sec2" class="Heading1">openFrameworks</p>
<p class="noindent">openFrameworks is used for this setup to create an application to create and transmit known data as a simulated sensor network over a single XBee module connected to a computer. As in <a href="9781430239390_Ch03.xhtml">Chapter 3</a>, a program is created in a C++ compiler such as Code::Blocks and is made of at least three source files. A copy of the empty example found in <span class="FontName2">openFrameworks directory/apps/myApps</span> can be used as a base for the first part of the sensor network code. You need to modify the <span class="FontName2">main.cpp</span> file to set the drawing window to a smaller size by changing the <span class="FontName2">ofSetupOpenGL</span> function call to create a 276&#x00D7;276-pixel window. Change the call to match the following line of code: <span class="FontName2">ofSetupOpenGL(&#x0026;window, 276, 276, OF_WINDOW);</span>.</p>
<p class="indent"><span class="FontName2">testapp.cpp</span><a id="cXXX.306" /> handles data creation and packet construction, responds to flow control, and graphically draws and indicates what data is being sent. The <span class="FontName2">testapp.cpp</span> code can be replaced with the code from <a href="#list1" id="_list1">Listing 8-1</a>. The example is made of seven different functions. Part 1 sets up the serial connection declared by the serial object in <span class="FontName2">testapp.h</span>. The serial is connected to the location of the USB serial adapter (COM or TTY, depending on the system) and is connected at 115200 baud. The <span class="FontName2">setup</span> function initializes a destination address of a broadcast for this example, as well as flags needed for program control. Three unsigned byte arrays of 256 bytes are filled with data created by a sine wave&#x2013;generation equation. The sine waves are zeroed at a value of 127. The sine wave follows the form <i>y</i> = <i>a</i> + <i>b</i> sin(<i>k</i>(<i>x</i> &#x2013; <i>c</i>)), where <i>a</i> is the vertical transformation, <i>b</i> is the amplitude, <i>c</i> sets the horizontal shift, and <i>k</i> affects the period. The data generated will be drawn to the computer&#x2019;s screen and sent over the XBee module to be eventuality displayed on an Android device.</p>
<p class="noindent2"><a href="#_list1" id="list1"><b><i>Listing 8-1.</i></b></a>&#160;&#160;testApp.cpp, Part 1 of 7</p>
<pre><span class="FontName2">#include &quot;testApp.h&quot;</span><br /><span class="FontName2">void testApp::setup(){</span><br />&#160;&#160;<span class="FontName2">printf (&quot;Start \n&quot;);</span><br />&#160;&#160;<span class="FontName2">serial.setup(&quot;/dev/ttyUSB0&quot;, 115200); // change to match where the Arduino is connected</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; 256; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">graph[i] = 127 + (100 * sin((1*(PI/127))*(i-0))); // sine functions</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">graph1[i] = 127 + (75 * sin((2*(PI/127))*(i-10)));&#160;&#160;// normalized in a 256&#x00D7;256-value area</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">graph2[i] = 127 + (50 * sin((3*(PI/127))*(i-40)));</span><br />&#160;&#160;<span class="FontName2">} // end data fill installation</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; 10; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">destADR[i] = 0x00;&#160;&#160;// set the 64-bit broadcast address</span><br />&#160;&#160;<span class="FontName2">} // end address fill</span><br />&#160;&#160;<span class="FontName2">destADR[6] = 0xFF; // set network broadcast address</span><br />&#160;&#160;<span class="FontName2">destADR[7] = 0xFF;</span><br />&#160;&#160;<span class="FontName2">destADR[8] = 0xFF;</span><br />&#160;&#160;<span class="FontName2">destADR[9] = 0xFE;</span><br />&#160;&#160;<span class="FontName2">point = 0; // zero data point indicator</span><br />&#160;&#160;<span class="FontName2">counts = 0; // used to delay packet send timing</span><br />&#160;&#160;<span class="FontName2">SensorsSent [0] = false; // packet flags</span><br />&#160;&#160;<span class="FontName2">SensorsSent [1] = false;</span><br />&#160;&#160;<span class="FontName2">SensorsSent [2] = false;</span><br />&#160;&#160;<span class="FontName2">FirstPacketsent = false;</span><br /><span class="FontName2">} // end testApp::setup()</span></pre>
<p class="indent">The next function is the loop<a id="cXXX.307" /> that runs constantly during program execution. The update function waits for a set time to pass before trying to send the each of the sensor&#x2019;s data. The time is based upon the amount of times the update function is run and will vary depending on the complexity of the code run. On average, the data is sent in intervals of half a second. Each time a data packet is sent, the code waits for a reply of an &#x201C;OK&#x201D; or &#x201C;BAD,&#x201D; signifying whether it should move on to the next packet or resend the last. Once all three sensors have been sent, the program starts sending the next data position in the array. All three of the sensor&#x2019;s data packets could be sent in one packet, but for this demonstration they are split up to represent different nodes.</p>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 2 of 7</p>
<pre><span class="FontName2">void testApp::update(){</span><br />&#160;&#160;<span class="FontName2">unsigned char DatatoSend[3] ;</span><br />&#160;&#160;<span class="FontName2">if (counts == 500){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;sensor 1 \n&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[0] = &#x0027;S&#x0027;;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[1] = &#x0027;1&#x0027;;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[2] =&#160;&#160;point;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[3] = graph[point];</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">CreatePacket(DatatoSend, 4);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">WaitForReply();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [0] = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (counts == 1000){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;sensor 2 \n&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[0] = &#x0027;S&#x0027; ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[1] = &#x0027;2&#x0027; ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[2] =&#160;&#160;point;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[3] = graph1[point] ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">CreatePacket(DatatoSend , 4 );</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">WaitForReply();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [1] = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (counts == 1500){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;sensor 3 \n&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[0] = &#x0027;S&#x0027;;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[1] = &#x0027;3&#x0027;;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[2] =&#160;&#160;point;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DatatoSend[3] = graph2[point] ;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">CreatePacket(DatatoSend , 4 );</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">WaitForReply();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [2] = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">if (SensorsSent [0] == true &#x0026;&#x0026; SensorsSent [1] == true &#x0026;&#x0026; SensorsSent [2] == true){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;reset counts move point \n&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">counts = 0;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">point++;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [0] = false;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [1] = false;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorsSent [2] = false;</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">counts++;</span><br />&#160;&#160;<span class="FontName2">CheckForIncoming();</span><br /><span class="FontName2">} // end testApp::update()</span></pre>
<p class="indent">The last thing that the update function performs is to check for incoming data<a id="cXXX.308" /> on the serial connection. Part 3 is the function that performs the check for incoming packets. The function tries to capture a complete packet from the XBee module and check to see if the packet has the correct checksum before attempting to read what the packet is and performing an action based on the packet&#x2019;s information. The capture length is calculated by the first two bytes received after the packet start byte, not by the amount of available serial data. The buffer is cleared after each packet is captured and read. To attempt to keep the serial data incoming constantly, the buffers are cleared and variables reinitialized if an incoming packet is malformed.</p>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 3 of 7</p>
<pre><span class="FontName2">void testApp::CheckForIncoming(){</span><br />&#160;&#160;<span class="FontName2">incomingPacketChecksum = 0;</span><br />&#160;&#160;<span class="FontName2">incomingByteLen = 0;</span><br />&#160;&#160;<span class="FontName2">if (serial.available() &#x0026;&#x0026; 0x7E == (incomingBuffer[0] = serial.readByte())){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;Incoming packet \n&quot;);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[1] = serial.readByte(); // pull packet length</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[2] = serial.readByte();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingByteLen = incomingBuffer[1] + incomingBuffer[2];</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int i&#160;&#160;= 3; i &#x003C;= incomingByteLen + 3; i++){&#160;&#160;// receive the rest of the packet&#x0027;s data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[i]&#160;&#160;= serial.readByte();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum += incomingBuffer[i]; // add byte to checksum calculation</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum = (0xFF - incomingPacketChecksum);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingByteLen += 3;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (incomingByteLen &#x003E; 0 &#x0026;&#x0026;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum == incomingBuffer[incomingByteLen + 1 ] ){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;Has Corect Checksum \n&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ReadPacket();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">serial.flush(true, true); // flush incoming and outgoing serial buffers</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;Check Sum Error\n&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">serial.flush(true, true);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingByteLen = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;= 80; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">incomingBuffer[i] = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">} // end the error else statement</span><br />&#160;&#160;<span class="FontName2">} //end if (serial.available() &#x0026;&#x0026; 0x7E ==...</span><br /><span class="FontName2">} // end testApp::CheckForIncoming()</span></pre>
<p class="indent">The function in part 4 reads the packet when called via a <span class="FontName2">switch</span> statement<a id="cXXX.309" /> to determent the packet type and associated method of reading. This function responds to three different packet types: an <span class="FontName2">AT</span> command response packet, a transmit response, and a data packet and announces that the packet type is unknown in response to all other packet types. The program uses data packets transmitted for the Arduino to determine if the packet was sent properly; if the packet is returned &#x201C;BAD,&#x201D; the program resends the packet till an &#x201C;OK&#x201D; is returned. This is a simplified method of error correction that is handled by the next function.</p>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 4 of 7</p>
<pre><span class="FontName2">void testApp::ReadPacket(){</span><br />&#160;&#160;<span class="FontName2">switch (incomingBuffer[3]){&#160;&#160;// check packet type and perform any responses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x90:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">dataLength = incomingByteLen - 15;&#160;&#160;// reduce to just the data length to get the data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;= dataLength; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomeData [i] = incomingBuffer[i+15]; // phrase out the data from the packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (dataLength == 2 &#x0026;&#x0026; incomeData[0] == &#x0027;O&#x0027; &#x0026;&#x0026; incomeData[1] == &#x0027;K&#x0027;){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;OKAY\n&quot;);&#160;&#160;&#160;&#160;// set Okay flag true when a good reply is received</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ReplyOK = true;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (dataLength == 3 &#x0026;&#x0026; incomeData[0] == &#x0027;B&#x0027; &#x0026;&#x0026; incomeData[1] == &#x0027;A&#x0027; &#x0026;&#x0026;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomeData[2]&#160;&#160;== &#x0027;D&#x0027; &#x0026;&#x0026; FirstPacketsent){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ReplyOK = false;&#160;&#160;// make sure that the flag is false when a BAD notify is received</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;BAD\n&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">serial.writeBytes (packetBuffer, lastPacketLength); // send last known packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">WaitForReply();&#160;&#160;// wait again for an okay</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x8B:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;Transmt Responce\n&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x88:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;Command response %X%X \n&quot;, incomingBuffer[8] , incomingBuffer[9]);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">default: // announce unknown packet type</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;error: packet type not known\n&quot; );</span><br />&#160;&#160;<span class="FontName2">} // end switch</span><br /><span class="FontName2">} // end&#160;&#160;testApp::ReadPacket()</span></pre>
<p class="indent">In part 5, the <span class="FontName2">WaitForReply</span> function<a id="cXXX.310" /> is called after sending a packet to the Arduino, and will remain in a loop, constantly polling for new packets. The loop is complete when the reply comes back as a data packet containing an &#x201C;OK.&#x201D; The program will stop everything else it is doing while in the loop; this could be mitigated with more complexity, such as implementing a timeout. A recursive situation occurs when waiting for a good reply and a &#x201C;BAD&#x201D; packet is received, because the wait for reply is called when the resend occurs. The recursive situation is not detrimental to the running of the example and is completely exited when an &#x201C;OK&#x201D; is received. The recursive call can cause problems in more complex situations, though, and needs to be handled differently&#x2014;with the use of timeouts and more robust packet-correction methods.</p>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 5 of 7</p>
<pre><span class="FontName2">void testApp::WaitForReply(){</span><br />&#160;&#160;<span class="FontName2">printf (&quot;Wait for reply \n&quot;);</span><br />&#160;&#160;<span class="FontName2">ReplyOK = false;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">while (ReplyOK != true){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">CheckForIncoming();</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end testApp::WaitForReply()</span></pre>
<p class="indent">Part 6 is the function to create and send the packets over the XBee network. A pointer of the data and the length of the data that need to be sent are received when the function is called. The packet is created with the destination address set in the setup function and the pointer containing the data to be sent out. The packet that is created is a transmit request that has no frame ID<a id="cXXX.311" /> to limit the number of packets that are worked with for this example. The frame ID can be used in situations where the receiving XBee may fail or go out of range, telling the program whether the packet was received or not. The transmit-reply packet that is generated by the XBee network does not inform the program that the packet was properly received by the Arduino; that is why the &#x201C;OK&#x201D; and &#x201C;BAD&#x201D; packets are used. The <span class="FontName2">CreatePacket</span> function calculates the checksum needed for the packet as the last step before sending. The function saves the packet length for possible resending and sets the <span class="FontName2">FirstPacketsent</span> flag to <span class="FontName2">true</span> to tell other functions that one packet has been sent; otherwise, the program will fail if a &#x201C;BAD&#x201D; packet is received before one packet has been sent.</p>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 6 of 7</p>
<pre><span class="FontName2">void testApp::CreatePacket(unsigned char *Outdata, int length){</span><br />&#160;&#160;<span class="FontName2">printf (&quot;creating packet\n&quot;);</span><br />&#160;&#160;<span class="FontName2">packetBuffer[17+ length] = 0;</span><br />&#160;&#160;<span class="FontName2">packetBuffer[0] = 0x7E;&#160;&#160;&#160;&#160;// start byte</span><br />&#160;&#160;<span class="FontName2">packetBuffer[1] = 0;&#160;&#160;&#160;&#160;&#160;&#160; // 1st length byte will be zero with current limitations</span><br />&#160;&#160;<span class="FontName2">packetBuffer[3] = 0x10;&#160;&#160;&#160;&#160;// frame type</span><br />&#160;&#160;<span class="FontName2">packetBuffer[4] =&#160;&#160;0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // frame ID</span><br />&#160;&#160;<span class="FontName2">for (int i = 5; i &#x003C;= 14; i++){&#160;&#160;&#160;&#160; // add addresses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">packetBuffer[i] = destADR[i-5];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">packetBuffer[15] = 0;&#160;&#160;// set both options</span><br />&#160;&#160;<span class="FontName2">packetBuffer[16] = 0;</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; length; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">packetBuffer[i + 17] =&#160;&#160;Outdata [i];&#160;&#160;// add data to packet</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">printf (&quot;graph: %X\n&quot;,packetBuffer[i+17]); // print sent data to debug console</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">packetBuffer[2] = 14 + length;&#160;&#160;&#160;&#160;&#160;&#160;// set the lower length byte</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;&#160;&#160;packetBuffer[2]; i++){ // calculate the checksum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">packetBuffer[17+ length] =&#160;&#160;packetBuffer[17+ length] + packetBuffer[i+3];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">// finish packet by adding checksum to the final position</span><br />&#160;&#160;<span class="FontName2">packetBuffer[17+ length]= 0xFF - packetBuffer[17+ length];</span><br />&#160;&#160;<span class="FontName2">serial.writeBytes (packetBuffer, (18 + length)); // send the packet</span><br />&#160;&#160;<span class="FontName2">lastPacketLength = 18 + length;&#160;&#160;// save last packet length</span><br />&#160;&#160;<span class="FontName2">FirstPacketsent = true;&#160;&#160;// flag that at least the first packet is sent</span><br /><span class="FontName2">} // end testApp::CreatePacket</span></pre>
<p class="indent">The finishing touch for the openFrameworks code, in part 7, is to create a visual display for quick verification<a id="cXXX.150a" /> of the position and data being sent. The graph that is generated will be re-created on the Android device. <a href="#Fig2" id="_Fig2">Figure 8-2</a> shows the approximate graph that is generated using the data generated in the setup function. The draw function is called by openFrameworks after the update function is run and has to generate the view from scratch every time draw is run. The function generates the grid by outlining a 256-pixel area with a square by counting out a 32-pixel line spacing using a <span class="FontName2">for</span> loop. The data is drawn by a <span class="FontName2">for</span> loop that will step through each array of data and draw a series of lines segments connected together corresponding to the data contained in the array. There is a vertical line that is drawn dynamically to indicate the position from which the code is sending data. The position of the data point is incremented when all three simulated sensors have been sent.</p>
<div class="Figure" id="Fig2">
<p class="img"><img src="images/9781430239390_Fig08-02.jpg" alt="9781430239390_Fig08-02.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig2">Figure 8-2</a> </span>.&#160;&#160;Graph visualization<a id="cXXX.312" /> of data being sent </p>
</div>
<p class="noindent2"><b><i>Listing 8-1.</i></b>&#160;&#160;testApp.cpp, Part 7 of 7</p>
<pre><span class="FontName2">void testApp::draw(){</span><br />&#160;&#160;<span class="FontName2">ofBackground (50,50,50);</span><br />&#160;&#160;<span class="FontName2">ofSetLineWidth (1);</span><br />&#160;&#160;<span class="FontName2">ofSetColor(0,0,0);</span><br />&#160;&#160;<span class="FontName2">for (int i = 266; i &#x003E; 9; i -=32){ // draw the grid</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofLine(10,i,266,i);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofLine(i,10,i,266);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; 255; i++){ // draw the data</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofSetLineWidth (2);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofSetColor(0,255,0);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofLine (i+10,(266 - graph[i]) , i+11 , (266 -graph [i+1]));</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofSetColor(255,255,0);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofLine (i+10,(266 - graph1[i]) , i+11 , (266 -graph1 [i+1]));</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofSetColor(0,0,255);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ofLine (i+10,(266 - graph2[i]) , i+11 , (266 -graph2 [i+1]));</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">ofSetColor(255,0,0);</span><br />&#160;&#160;<span class="FontName2">ofLine (10 + point, 10, 10 + point, 266); // draw the position line</span><br />&#160;&#160;<span class="FontName2">ofSetLineWidth (1);</span><br />&#160;&#160;<span class="FontName2">} // end testApp::draw()</span></pre>
<p class="indent">The last thing before compiling the code is to declare variables and function prototypes in <span class="FontName2">testApp.h</span>.<a id="cXXX.313" /> <a href="#list2" id="_list2">Listing 8-2</a> describes the class used for the program. For simplicity, a majority of the variables are declared within the class definition. <a href="#list2">Listing 8-2</a> needs to replace the one created with the empty application. The code will need a preliminary test before the rest of the project is complete. To test, temporarily comment out the three <span class="FontName2">WaitForReply</span> function calls in the update function associated with the packet creation and sending. Compile and run the program, and the red line should increment to a new position after three packets are sent. With the program running, upload the modified software serial sketch to the Arduino Mega ADK that is set up with the connected, required hardware, and check for data printing to the serial monitor. The data is in readable by humans in this from, but shows that the packets are reaching the Arduino.</p>
<p class="noindent2"><a href="#_list2" id="list2"><b><i>Listing 8-2.</i></b></a>&#160;&#160;testApp.h</p>
<pre><span class="FontName2">#pragma once</span><br /><span class="FontName2">#include &quot;ofMain.h&quot;</span><br /><span class="FontName2">class testApp : public ofBaseApp{</span><br /><span class="FontName2">public:</span><br />&#160;&#160; <span class="FontName2">// variables and objects</span><br />&#160;&#160; <span class="FontName2">unsigned char graph[256], graph1[256], graph2[256];</span><br />&#160;&#160; <span class="FontName2">unsigned char point;</span><br />&#160;&#160; <span class="FontName2">int counts;</span><br />&#160;&#160; <span class="FontName2">bool SensorsSent [3];</span><br />&#160;&#160; <span class="FontName2">bool ReplyOK;</span><br />&#160;&#160; <span class="FontName2">bool FirstPacketsent;</span><br />&#160;&#160; <span class="FontName2">unsigned char incomingBuffer[80];</span><br />&#160;&#160; <span class="FontName2">unsigned char incomeData[64];</span><br />&#160;&#160; <span class="FontName2">int incomingByteLen;</span><br />&#160;&#160; <span class="FontName2">unsigned char incomingPacketChecksum;</span><br />&#160;&#160; <span class="FontName2">unsigned char destADR[10];</span><br /><br />&#160;<span class="FontName2">unsigned char packetBuffer [80];</span><br />&#160;<span class="FontName2">int lastPacketLength;</span><br />&#160;<span class="FontName2">unsigned char dataLength;</span><br />&#160;<span class="FontName2">ofSerial serial;</span><br />&#160;<span class="FontName2">// openFrameworks-specific functions</span><br />&#160;<span class="FontName2">void setup();</span><br />&#160;<span class="FontName2">void update();</span><br />&#160;<span class="FontName2">void draw();</span><br /><span class="FontName2">// sensor network functions to handle packets</span><br />&#160;<span class="FontName2">void CheckForIncoming();</span><br />&#160;<span class="FontName2">void WaitForReply();</span><br />&#160;<span class="FontName2">void ReadPacket ();</span><br />&#160;<span class="FontName2">void CreatePacket (unsigned char*, int);</span><br /><span class="FontName2">}; // end class testApp</span></pre>
<p id="Sec3" class="Heading1">The Arduino</p>
<p class="noindent">The Arduino is the main workhorse of this chapter&#x2019;s example. The Arduino receives packets from other network nodes and processes the information to be logged to an SD card to be eventually retrieved by an Android device. The Arduino programming responds to good incoming data by generating an &#x201C;OK&#x201D; reply packet using the address contained within the good incoming packets of the sending node. If a packet is malformed, a broadcast &#x201C;BAD&#x201D; packet is sent to the network; the packet is a broadcast because it might not be possible to determine the address of the sending node. Both reply packets keep the simulated sensor network that is made with openFrameworks moving forward and sending data.</p>
<p class="indent">The Arduino program waits till the last sensor is received before writing the data to the SD card as a single buffer line. The simple packet-correction method sometimes drops data instead of trying figure out what packets might be missing. The amount of lost data needs to be determined; as a function of the requirements of some projects, it may be more critical that all the data is received.</p>
<p class="indent"><a href="#list3" id="_list3">Listing 8-3</a> is divided into eight parts. Part 1 sets up most of the variables and libraries needed. Both <span class="FontName2">SD.h</span> and <span class="FontName2">AndroidAccessory.h</span><a id="cXXX.314" /> are used to create the connection to the corresponding SPI devices. Input and output buffers are set for both the serial XBee connection and the SD card read and write. The reply packet that signifies that a packet was not received properly is set as a static byte array, as this packet will be the standard reply for malformed packets. The &#x201C;BAD&#x201D; packet is not required to be generated every time it needs to be sent, unlike the &#x201C;OK&#x201D; reply packet, which is generated dynamically every time. The SD card output buffer has a set amount of preformatting. <a id="cXXX.315" /></p>
<p class="indent">The data contained in the log file is essentially a four-byte string for each sensor: it contains the sensor name, the location of the data in the array of the openFrameworks program, and the actual sensor data. The sensor data is separated by a colon, and a double-colon separates each sensor. The data lines are ended with a carnage return and linefeed character. Each of the remote sensors are designated as S1 through S3, and a local sensor location called L1 has been left in the array to allow for an optimal local sensor attached to the Mega ADK to be processed. A series of Boolean flags are declared for program flow control: one flag contains a blink state to blink the LED and two flags are for ADK connection status.</p>
<p class="indent">The last object created is the <span class="FontName2">AndroidAccessory</span> object and uses the same declaration as we used in <a href="9781430239390_Ch04.xhtml">Chapter 4</a>. As long as the default program has not been set on the Android device, programs associated with a particular accessory name and ID will be given as an autorun option when connected. Using the same accessory lets you avoid an unnecessary upload when starting to integrate the Android device into the sensor network, by allowing the ADK monitor to easily be used as an option for debugging.</p>
<p class="noindent2"><a href="#_list3" id="list3"><b><i>Listing 8-3.</i></b></a>&#160;&#160;Data Logger and ADK Handler, Part 1 of 8</p>
<pre><span class="FontName2">#include &#x003C;SD.h&#x003E; // must be included before AndroidAccessory.h</span><br /><span class="FontName2">#include &#x003C;AndroidAccessory.h&#x003E;</span><br />&#160;&#160;<span class="FontName2">static byte badPacket[21] = {0x7E ,0x00 ,0x11 ,0x10 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,</span><br />&#160;&#160;<span class="FontName2">0x00 ,0xFF ,0xFF ,0xFF ,0xFE ,0x00 ,0x00 ,0x42 ,0x41 ,0x44 ,0x2D };</span><br />&#160;&#160;<span class="FontName2">byte OutPacketBuffer[80];</span><br />&#160;&#160;<span class="FontName2">byte incomingBuffer[80];</span><br />&#160;&#160;<span class="FontName2">int incomingByteLen;</span><br />&#160;&#160;<span class="FontName2">byte incomingPacketChecksum;</span><br />&#160;&#160;<span class="FontName2">byte sourceADR[10];&#160;&#160;&#160;&#160; // source addresses holding</span><br />&#160;&#160;<span class="FontName2">byte incomeData [64];&#160;&#160;// phrased data holder</span><br />&#160;&#160;<span class="FontName2">int dataLength;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// length of data received</span><br />&#160;&#160;<span class="FontName2">byte SDinBuffer[34];&#160;&#160;&#160;&#160;&#160;&#160;// SD buffer is 34 bytes to capture a whole data line</span><br />&#160;&#160;<span class="FontName2">byte SDoutBuffer[34] =</span><br /><span class="FontName2">// pre-format used to contain the data to log</span><br />&#160;&#160;<span class="FontName2">{&#x0027;S&#x0027;,&#x0027;1&#x0027;,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,&#x0027;:&#x0027;,</span><br />&#160;&#160; <span class="FontName2">&#x0027;S&#x0027;,&#x0027;2&#x0027;,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,&#x0027;:&#x0027;,</span><br />&#160;&#160; <span class="FontName2">&#x0027;S&#x0027;,&#x0027;3&#x0027;,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,&#x0027;:&#x0027;,</span><br />&#160;&#160; <span class="FontName2">&#x0027;L&#x0027;,&#x0027;1&#x0027;,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,0xFF,&#x0027;:&#x0027;,&#x0027;:&#x0027;, 0x0A,0x0D};</span><br />&#160;&#160;<span class="FontName2">int ERRcount = 0;</span><br />&#160;&#160;<span class="FontName2">int IcomingTime&#160;&#160;= 0;</span><br />&#160;&#160;<span class="FontName2">boolean Blink&#160;&#160;= LOW; // blink state holder</span><br />&#160;&#160;<span class="FontName2">bool lastReply = false; // false bad, true good</span><br />&#160;&#160;<span class="FontName2">boolean ADKisConnected = false; // so the rest of the code does not have to pull the USB</span><br />&#160;&#160;<span class="FontName2">boolean LogFileSyncADK = false;</span><br />&#160;&#160;<span class="FontName2">File LogFile;</span><br />&#160;&#160;<span class="FontName2">AndroidAccessory ADK(&quot;Manufacturer2&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;Model2&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;Description&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;2.0&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;</span><span class="FontName2"><a href="http://yoursite.com">http://yoursite.com</a></span><span class="FontName2">&quot;,</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">&quot;0000000012345678&quot;);</span></pre>
<p class="indent">Part 2 of the Arduino program contains the setup function. Two serial connections are needed: one for the XBee module and one for debugging. Arduino pin 2 is used for card detection and pin 10 is used for SD card slave select. Pins 10 and 13 are set as output, along with pin 53, to make sure the SPI remains in master mode. After the pins and serial are set up, the code remains in a loop, waiting for the SD card to become available, during which the LED produces a slow blink. Once the card is detected, the LED will blink rapidly before making sure that the log file is available. Finally, the setup function initializes the Android connection.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 2 of 8</p>
<pre><span class="FontName2">void setup(){</span><br />&#160;&#160;<span class="FontName2">Serial.begin(115200);&#160;&#160;// serial to monitor</span><br />&#160;&#160;<span class="FontName2">Serial3.begin(115200); // serial to XBee</span><br />&#160;&#160;<span class="FontName2">pinMode(2, INPUT); // pin for SD card detection; can attach interrupt if needed</span><br />&#160;&#160;<span class="FontName2">digitalWrite (2, HIGH);// pull up for chip detect</span><br />&#160;&#160;<span class="FontName2">pinMode(13, OUTPUT); // use onboard LED for diagnostics</span><br />&#160;&#160;<span class="FontName2">pinMode(53, OUTPUT); // make sure the SPI won&#x0027;t enter slave</span><br />&#160;&#160;<span class="FontName2">pinMode(10, OUTPUT);&#160;&#160;// CS pin for SD</span><br />&#160;&#160;<span class="FontName2">while (!SD.begin(10)) { // wait for SD to be available</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, (Blink = !Blink)); // constant blink waiting for card</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">for (int i = 0 ; i &#x003C;= 10 ; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, (Blink = !Blink));</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">} // fast blink to show SD card is initialized</span><br />&#160;&#160;<span class="FontName2">if (SD.exists(&quot;sensor.log&quot;)) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;= 4 ; i++) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, (Blink = !Blink));</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (300);</span><br />&#160;&#160; <span class="FontName2">}// slow short blink to show file is found</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">else{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LogFile = SD.open(&quot;sensor.log&quot;, FILE_WRITE);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">LogFile.close();</span><br />&#160;&#160;<span class="FontName2">} // create log file if none is found</span><br />&#160;<span class="FontName2">ADK.begin(); // initialize the Android connection</span><br /><span class="FontName2">} // end setup&quot;);</span></pre>
<p class="indent">In part 3, the <span class="FontName2">loop</span> function<a id="cXXX.316" /> controls the major flow of the Arduino program. The <span class="FontName2">loop</span> function starts with a confirmation of the presence of the SD card. If there is no SD card inserted, the program blinks the LED and sets flags for use when the SD card is available. When the SD card is available, the program will count the times the loop is run, and if a packet is not received within the set amount of counts, the function will resend the last reply packet type as either &#x201C;OK&#x201D; or &#x201C;BAD.&#x201D; The <span class="FontName2">loop</span> function also checks the availability of the ADK connection, along with checking for new data from <span class="FontName2">Serial3</span>.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 3 of 8</p>
<pre><span class="FontName2">void loop(){</span><br />&#160;&#160;<span class="FontName2">if (digitalRead(2) == HIGH){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, HIGH);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (IcomingTime &#x003E;= 25){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (lastReply){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SendOK();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">else{</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.write (badPacket,21);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">IcomingTime = 0;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">HandleADK();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">CheckForIncoming();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (50);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">IcomingTime++;</span><br />&#160;&#160;<span class="FontName2">} // end if (digitalRead(2) == HIGH)</span><br />&#160;&#160;<span class="FontName2">else{</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">IcomingTime = 1000;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">bool lastReply = false; // will request a new packet to be set</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// if node is waiting for reply</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, (Blink = !Blink));&#160;&#160;// blink when SD card is not available</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;<span class="FontName2">} // end else for if (digitalRead(2) == HIGH)</span><br /><span class="FontName2">} // end loop</span></pre>
<p class="indent">Part 4 is the function to capture incoming packets from the Arduino. It performs the checksum verification. This function is closely related to the receive function created in the openFrameworks portion and described in <a href="9781430239390_Ch05.xhtml">Chapter 5</a>. The <span class="FontName2">CheckForIncoming</span> function<a id="cXXX.317" /> has a bit more control than previous examples to ensure that the packets are properly received. It does this by flushing all of the input and serial connection buffers connected to the XBee module when too many errors have been encountered. This function also initiates the proper reply packet based on the checksum being correct, along with the reading of the packet when a proper packet is received.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 4 of 8</p>
<pre><span class="FontName2">void CheckForIncoming(){</span><br />&#160;&#160;<span class="FontName2">incomingBuffer[0] =&#160;&#160;0; // clear the first byte of the incoming buffer</span><br />&#160;&#160;<span class="FontName2">if (Serial3.available() &#x0026;&#x0026; 0x7E == (incomingBuffer[0] = Serial3.read())){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[1] = Serial3.read(); // pull packet length</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[2] = Serial3.read();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingByteLen = incomingBuffer[1] + incomingBuffer[2]; // calculate packet length</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum = 0; // clear checksum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">for (int i&#160;&#160;= 3; i &#x003C;= incomingByteLen + 3; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[i]&#160;&#160;= Serial3.read();&#160;&#160;// capture packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum += incomingBuffer[i]; // calculate checksum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingPacketChecksum = (0xFF - incomingPacketChecksum); // finish checksum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">incomingByteLen += 3;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (incomingByteLen &#x003E; 0 &#x0026;&#x0026; incomingPacketChecksum ==</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[incomingByteLen+1]){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.flush(); // done with serial buffer for now</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ReadPacket(); // read and handled the data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SendOK(); // reply to original sender</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">else { // if checksum is bad, perform clean and bad packet send</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ERRcount++; // increment error count</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;= 80; i++){&#160;&#160;// clear packet from incoming buffer</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">incomingBuffer[i] = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.flush(); // clear serial connection</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// if too many errors encountered, reset serial connection</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (ERRcount == 10) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.end();&#160;&#160; // stop serial completely</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;= 10; i++) {&#160;&#160;// blink for verification</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">digitalWrite (13, (Blink = !Blink));</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (50);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ERRcount = 0; // reset error count</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.begin(115200); // restart serial connection</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">delay (30);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial3.write (badPacket,21); // send BAD reply</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">lastReply = false; // set last reply ad bad flag</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;// end else checksum bad</span><br />&#160;&#160;<span class="FontName2">} // end if (Serial3.available() &#x0026;&#x0026; 0x7E</span><br /><span class="FontName2">} // end void CheckIncoming()</span></pre>
<p class="indent">Part 5 reads a proper incoming packet using a <span class="FontName2">switch</span> statement and recognizes three packet types. The three packet are a data packet, an <span class="FontName2">AT</span> command response, and a transmit response. The transmit and <span class="FontName2">AT</span> command response<a id="cXXX.318" /> both print to the serial monitor when they are detected and perform no other work on those types. When a data packet is received, the address of the sending node is placed in an array for use in the <span class="FontName2">SendOK</span> function, which will be called after this function returns to <span class="FontName2">CheckForIncoming</span>. Data is also phrased from the data packet and placed in an array to be used for prepping the format and containment in the log file on the SD card.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 5 of 8</p>
<pre><span class="FontName2">void ReadPacket(){</span><br />&#160;&#160;<span class="FontName2">IcomingTime&#160;&#160;= 0;&#160;&#160;// received a good packet-reset time</span><br />&#160;&#160;<span class="FontName2">switch (incomingBuffer[3]){&#160;&#160;// check packet type and perform any responses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case 0x90:&#160;&#160;// data packet</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">dataLength = 0;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 4; i &#x003C;= 13; i++){&#160;&#160;// get both addresses of the source device</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">sourceADR[i-4] = incomingBuffer[i];</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">dataLength = incomingByteLen - 15;&#160;&#160;// reduce to just the data length to get the data</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">for (int i = 0; i &#x003C;= dataLength; i++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">incomeData [i] = incomingBuffer[i+15]4data from the packet</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">if (dataLength == 4){ // send data to the preparation function if length is proper</span><br />&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">PrepareDataForSD();</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">}</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">break;</span><br />&#160;&#160; <span class="FontName2">case 0x8B:&#160;&#160;// if packet is a transmit response, perform action</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">Serial.println (&quot;Transmit Response&quot;);</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">break;</span><br />&#160;&#160; <span class="FontName2">case 0x88: // inform of information from command response</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print(&quot;Command response :&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.print (incomingBuffer[8], HEX);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println (incomingBuffer[9],HEX);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160; <span class="FontName2">default: // announce unknown packet type</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">Serial.println (&quot;error: packet type not known&quot;);</span><br />&#160;&#160;<span class="FontName2">} // end Switch Case</span><br /><span class="FontName2">} // end void ReadPacket</span></pre>
<p class="indent">In part 6, the next function preps the data to be contained in the SD card and that&#x2019;s ready for passing to the Android device. When data is received and parsed from the incoming packets, it is sent to this function and placed in the SD buffer<a id="cXXX.319" /> according to the sensor&#x2019;s number. This function will place all three sensors into the respective locations, and when the last sensor is received, the SD buffer is written to the SD card for storage. The data is sorted with a switch that looks at the second position of the <span class="FontName2">incomeData</span> array, which contains the sensor number associated with the sensor data. Once the third sensor is received, the SD buffer is printed to the serial connection to the computer for debugging, and the SD buffer will be sent to the Android device if connected and the data in the log has been synced.</p>
<p class="indent">The method of logging the data<a id="cXXX.320" /> after the third sensor has been received sometimes misses some of the other sensors. In more professional setups, the program should make a request for the missing sensor data from the network, but for this demonstration it is not necessary. This function can also be used to pull a local sensor to add extra sensor data to the log. When the SD buffer is ready, the code opens the file for writing and finds the last position by seeking to the end based upon the file size, and closes the file when finished. The positions that are associated with the sensor data are reset to the initialization values returning back to the calling function.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 6 of 8</p>
<pre><span class="FontName2">void PrepareDataForSD(){</span><br />&#160;&#160;<span class="FontName2">switch (incomeData[1]){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;1&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[3] =&#160;&#160;incomeData[2];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[5] =&#160;&#160;incomeData[3];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;2&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[11] =&#160;&#160;incomeData[2];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[13] =&#160;&#160;incomeData[3];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;3&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[19] =&#160;&#160;incomeData[2];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[21] =&#160;&#160;incomeData[3];</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">// a local sensor can be pulled and added to the SD buffer at the L1 location</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFile = SD.open(&quot;sensor.log&quot;, FILE_WRITE);&#160;&#160;// open file for writing</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFile.seek(LogFile.size()); // find end of file to append</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (LogFile) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFile.write (SDoutBuffer,34);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.write (SDoutBuffer,34);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">if (ADKisConnected &#x0026;&#x0026; LogFileSyncADK){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">ADK.write (SDoutBuffer,34);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">} // end if (LogFile)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFile.close();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[3]&#160;&#160; =&#160;&#160;0xFF;&#160;&#160;// reset SD buffer</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[5]&#160;&#160; =&#160;&#160;0xFF;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[11] =&#160;&#160;0xFF;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[13] =&#160;&#160;0xFF;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[19] =&#160;&#160;0xFF;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDoutBuffer[21] =&#160;&#160;0xFF;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;<span class="FontName2">} // end switch</span><br /><span class="FontName2">}// end void PrepareDataForSD()</span></pre>
<p class="indent">Part 7 is the function that creates and sends an OK reply and is called when a good packet is received from the XBee network. The packet is created dynamically to be able to send the reply packet<a id="cXXX.321" /> to the originating sensor node. The packet is formed in the same fashion as every XBee API transmit request that has been generated thus far. The packet is formed in a buffer with the proper formatting before being sent. The packet&#x2019;s data is constant; the only change is that of the address.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 7 of 8</p>
<pre><span class="FontName2">void SendOK(){</span><br />&#160;&#160;<span class="FontName2">delay (50);</span><br />&#160;&#160;<span class="FontName2">byte length = 2;</span><br />&#160;&#160;<span class="FontName2">byte Outdata[2] = {&#x0027;O&#x0027;, &#x0027;K&#x0027;};</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[17 + length] = 0; // clear checksum byte</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[0] = 0x7E;&#160;&#160;&#160;&#160;// start byte</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[1] = 0;&#160;&#160;&#160;&#160;&#160;&#160; // 1st length byte will be zero with current limitations</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[3] = 0x10;&#160;&#160;&#160;&#160;// transmit request frame type</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[4] =&#160;&#160;0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // frame ID</span><br />&#160;&#160;<span class="FontName2">for (int i = 5; i &#x003C;= 14; i++){&#160;&#160;&#160;&#160; // add addresses</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">OutPacketBuffer[i] = sourceADR[i-5];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[15] = 0 ;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// set both options</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[16] = 0 ;</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; length; i++){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">OutPacketBuffer[i + 17] =&#160;&#160;Outdata [i];&#160;&#160;// add data to packet</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[2] = 14 + length;&#160;&#160;&#160;&#160;&#160;&#160;// set the lower length byte</span><br />&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C;&#160;&#160;OutPacketBuffer[2]; i++){&#160;&#160; // start calculating errorsum</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">OutPacketBuffer[17+ length] =&#160;&#160;OutPacketBuffer[17+ length] + OutPacketBuffer[i+3];</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">// finish packet by adding checksum</span><br />&#160;&#160;<span class="FontName2">OutPacketBuffer[17+ length]= 0xFF - OutPacketBuffer[17+ length];</span><br />&#160;&#160;<span class="FontName2">Serial3.write(OutPacketBuffer, (18 + length));</span><br />&#160;&#160;<span class="FontName2">lastReply = true;</span><br /><span class="FontName2">}// end void SendOK()</span></pre>
<p class="indent">In Part 8, the last function included in the Arduino sketch handles the Open Accessory connection. This function is pulled at a regular interval to check for incoming data from the Android device. When the Android device is connected, a Boolean flag is set to <span class="FontName2">true</span> to avoid running the <span class="FontName2">isConnected</span> function<a id="cXXX.322" /> too often by other functions that need to know when the Android device is connected. A predetermined set of bytes are used as commands from the Android device to allow for syncing of the log information, deleting the log, or disconnecting the Android device from the Arduino. The command for syncing the data is an ASCII <span class="FontName2">a</span>; when this command is issued from the Android device, the Arduino will read the log file 34 bytes at a time and send the information to the Android device for further processing. When a command of a <span class="FontName2">b</span> is received, the Arduino will stop sending updated information to the Android. The log file will be deleted when a command of <span class="FontName2">c</span> is received. If the Android device is not connected, the two flags that control the sending of updated data to the Android device are set to <span class="FontName2">false</span>.</p>
<p class="noindent2"><b><i>Listing 8-3.</i></b>&#160;&#160;Data Logger and ADK Handler, Part 8 of 8</p>
<pre><span class="FontName2">void HandleADK(){</span><br />&#160;&#160;<span class="FontName2">if (ADK.isConnected()) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">delay (100);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">ADKisConnected = true;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (ADK.available() &#x003E; 0){&#160;&#160;&#160;&#160;// check for incoming data</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">switch (ADK.read()){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;a&#x0027;: {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">Serial.println(&#x0027;a&#x0027;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">File LogFile = SD.open(&quot;sensor.log&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">If (LogFile) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">while (LogFile.available()) { // read bytes into buffer</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">for (int i = 0; i &#x003C; 34; i ++){</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SDinBuffer[i] = LogFile.read();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="FontName2">ADK.write (SDinBuffer, 34);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">} // end while (LogFile.available())</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFileSyncADK = true;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFile.close();</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}&#160;&#160;// end if (LogFile)</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">} // end case &#x0027;a&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;b&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">LogFileSyncADK = false;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">case &#x0027;c&#x0027;:</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SD.remove(&quot;sensor.log&quot;);</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">break;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">}// end switch (ADK.read())</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">} // end if (ADK.available() &#x003E; 0)</span><br />&#160;&#160;<span class="FontName2">}&#160;&#160;// end if (acc.isConnected())</span><br />&#160;&#160;<span class="FontName2">else{</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">ADKisConnected = false;</span><br />&#160;&#160;&#160;&#160; <span class="FontName2">LogFileSyncADK = false;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">}// end HandleADK()</span></pre>
<p class="indent">When all the code is complete for the Arduino<a id="cXXX.160b" /> sketch, compile and upload it to the Arduino Mega ADK with the SD adapter and the XBee module connected. The openFrameworks<a id="cXXX.160c" /> program needs to be started to ensure that the <span class="FontName2">WaitForReply</span> function<a id="cXXX.323" /> calls are uncommented and the program is recompiled. Insert an SD card into the Arduino and power on the setup. When the Arduino is powered on, the openFrameworks program should start to send data and move through the data arrays. The serial monitor can be used to see the data being written to the SD card after three sensors have be sent and received.</p>
<p class="indent">Now that the data is being logged to the SD card, the ADK monitor program that was created in <a href="9781430239390_Ch04.xhtml">Chapter 4</a> can be used to verify that the data is getting sent to the Android device. While the Arduino and openFrameworks are running, plug the Android device into the host side of the Mega ADK and wait till the Android program detects the event. A command can be sent to the Mega ADK when an <span class="FontName2">a</span> is sent; in this case the log data should be printed to the Android screen. The data should match the printed data on the Arduino serial monitor and should update at about the same time while connected.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Before the Android program is complete, you can verify the data on the SD card by using a hex editor to read the <span class="FontName2">sensor.log</span> file when the SD card is read by a computer.</p></div>
<p id="Sec4" class="Heading1">The Android Application<a id="cXXX.160a" /></p>
<p class="noindent">In this section, we&#x2019;ll make the Android program display the data in a more human-readable format. The example adds a chart that graphs the data in a fashion similar to the openFrameworks code. The layout of the program is shown in <a href="#Fig3" id="_Fig3">Figure 8-3</a>. The graph is drawn at the top of the screen above the monitor box. Making the graph is a bit difficult to do from scratch, so a library is used to add the functionality. The library that is going to be used is called <span class="FontName2">AChartEngine</span><a id="cXXX.324" />. The chart library adds the ability to make scatter plots, pie charts, and line or bar graphs that can be created dynamically and can be pinched, zoomed, and scrolled. The binary distribution of the library needs to be downloaded from <span class="FontName2"><a href="http://www.achartengine.org">www.achartengine.org</a></span><a id="cXXX.325" />.</p>
<div class="Figure" id="Fig3">
<p class="img"><img src="images/9781430239390_Fig08-03.jpg" alt="9781430239390_Fig08-03.jpg" /></p>
<p class="FigCapt"><span class="CaptNr"><a href="#_Fig3">Figure 8-3</a> </span>.&#160;&#160;The running Android application </p>
</div>
<p class="indent">The program that this example creates uses the same framework that was created in <a href="9781430239390_Ch04.xhtml">Chapter 4</a>. A new project can be created in the Eclipse IDE and the framework section copied over using the same method as the original setup. To use the library, create a folder named <span class="FontName2">libraries</span> in the <span class="FontName2">RES</span> folder<a id="cXXX.326" /> in the project&#x2019;s workspace, and drag and drop the <span class="FontName2">achartengine-1.0.0.jar</span> file into the newly created folder. Right-click the added JAR file in the workspace and select Build Path <img src="images/arrow.jpg" alt="image" /> Add to Build Path from the pop-up menu to make the library fully ready for use. The JAR file will move from the location copied to the <span class="FontName2">Referenced Libraries</span> workspace folder when it is properly added to the build path.</p>
<p class="indent">The Javadocs of the <span class="FontName2">AChartEngine</span> library can be a great help on how to use it (see <span class="FontName2"><a href="http://www.achartengine.org">www.achartengine.org</a></span>). Note that this example only focuses on one possible implementation of the chart engine and only uses the line graph setup.</p>
<p class="indent">The Android application needs a different <span class="FontName2">main.xml</span> file<a id="cXXX.327" /> and a <span class="FontName2">strings.xml</span> file. <a href="#list4" id="_list4">Listing 8-4</a> is the <span class="FontName2">main.xml</span> file that needs to be created. The graph is created in a nested layout inside of the main relative layout within the <span class="FontName2">main.xml</span> file. The <span class="FontName2">LinearLayout</span> tag defines the space that will be used to place the graph created at run time. An Edit text box is used to display the incoming data from the Arduino and has the same functionality as the data-display box for the ADK monitor program. Two buttons are also created in the <span class="FontName2">main.xml</span> file for the layout: one to sync the data stored on the SD card and receive current updates while plugged in, and the other to clear the data from the screen. Both buttons are set up to call a respective function in the activity class.</p>
<p class="noindent2"><a href="#_list4" id="list4"><b><i>Listing 8-4.</i></b></a>&#160;&#160;main.xml</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;RelativeLayout xmlns:android=&quot;</span><span class="FontName2"><a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a></span><span class="FontName2">&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/relativeLayout1&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_weight=&quot;0.72&quot; &#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;LinearLayout</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/chart&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;fill_parent&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;500dp&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentTop=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">/&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;EditText</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/incomingData&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;250dp&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_above=&quot;@+id/syncbutton&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentLeft=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentRight=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:scrollbars=&quot;vertical&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:clickable=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:cursorVisible=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:focusable=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:focusableInTouchMode=&quot;false&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:gravity=&quot;top&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:inputType=&quot;textMultiLine|textNoSuggestions&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:hint=&quot;@string/hint&quot; /&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;Button</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/clear&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentBottom=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentRight=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:onClick=&quot;clearScreen&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:text=&quot;@string/clear&quot; /&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;Button</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:id=&quot;@+id/syncbutton&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_width=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_height=&quot;wrap_content&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_alignParentBottom=&quot;true&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:layout_toLeftOf=&quot;@+id/clear&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:onClick=&quot;SyncData&quot;</span><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">android:text=&quot;@string/sync&quot; /&#x003E;</span><br /><span class="FontName2">&#x003C;/RelativeLayout&#x003E;</span></pre>
<p class="indent"><a href="#list5" id="_list5">Listing 8-5</a> is the <span class="FontName2">strings.xml</span> file<a id="cXXX.328" /> and defines the new application name, a hint for the Edit text box, and the name of the two buttons. As stated in <a href="9781430239390_Ch04.xhtml">Chapter 4</a>, putting the information in the <span class="FontName2">strings.xml</span> file saves you from having to go to every instance that will be used to change a name. When this application is loaded on the Android device, it will have a different name than that of the ADK monitor, but will still respond to the same accessory name declared in the Arduino sketch. Sharing the same information is not a problem if the default program option on the autorun pop-up menu is not selected. The Android device will give a series of options if there are multiple programs that use the same accessory. If the multiple options are undesirable, change the declaration to a new accessory name in the Arduino sketch, and change the <span class="FontName2">accessory_filter.xml</span> file in the Android project to reflect the changes.</p>
<p class="noindent2"><a href="#_list5" id="list5"><b><i>Listing 8-5.</i></b></a>&#160;&#160;strings.xml</p>
<pre><span class="FontName2">&#x003C;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&#x003E;</span><br /><span class="FontName2">&#x003C;resources&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;app_name&quot;&#x003E;ADK Sensor Network&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;hint&quot;&#x003E;Data from Arduino board will be displayed here&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;sync&quot;&#x003E;Sync&#x003C;/string&#x003E;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">&#x003C;string name=&quot;clear&quot;&#x003E;Clear&#x003C;/string&#x003E;</span><br /><span class="FontName2">&#x003C;/resources&#x003E;</span></pre>
<p class="indent">New objects for the chart engine need to be imported for you to use the graphing capabilities in the application. <a href="#list6">Listing 8-6</a> shows the new imports needed for the chart that will be used. <span class="FontName2">ChartFactory</span> and <span class="FontName2">GraphicalView</span><a id="cXXX.329" /> make up the main core of the chart engine. There is a data class that contains the data in a series for the graph using Cartesian x- and y- coordinates for the point&#x2019;s position. <span class="FontName2">XYMultipleSeriesDataset</span> is used for a class that will contain all the series data that will need to be displayed on the screen. <span class="FontName2">XYSeriesRenderer</span> and <span class="FontName2">XYMultipleSeriesRenderer</span> are needed to get the data rendered properly. The import <span class="FontName2">android.graphics.Color</span> is used to get classes that predefine colors such as red, green, and blue to make color use a bit easier. The import <span class="FontName2">android.widget.LinearLayout</span> will allow the blank layout to be accessible for adding the graph to the layout space defined in <span class="FontName2">main.xml</span>. Add the import in <a href="#list6" id="_list6">Listing 8-6</a> to the beginning of the ADK framework from <a href="9781430239390_Ch04.xhtml">Chapter 4</a>.</p>
<p class="noindent2"><a href="#_list6" id="list6"><b><i>Listing 8-6.</i></b></a>&#160;&#160;New Imports for Using the AChartEngine Library</p>
<pre><span class="FontName2">import org.achartengine.ChartFactory;</span><br /><span class="FontName2">import org.achartengine.GraphicalView;</span><br /><span class="FontName2">import org.achartengine.model.XYMultipleSeriesDataset;</span><br /><span class="FontName2">import org.achartengine.model.XYSeries;</span><br /><span class="FontName2">import org.achartengine.renderer.XYMultipleSeriesRenderer;</span><br /><span class="FontName2">import org.achartengine.renderer.XYSeriesRenderer;</span><br /><span class="FontName2">import android.graphics.Color;</span><br /><span class="FontName2">import android.widget.LinearLayout;</span><br /><span class="FontName2">import android.widget.View;</span><br /><span class="FontName2">import android.widget.Button;</span><br /><span class="FontName2">import android.widget.EditText;</span></pre>
<p class="indent"><a href="#list7">Listing 8-7</a> defines the new variables that need to be added to the framework to define the chart and the data that will be drawn to the screen. The first two new variables declare the multiple-series data set and the renderer. The data-set variable contains the three series that will make up the data from the sensors. The renderer uses the data set to display the data and is used by the <span class="FontName2">SensorChartView</span><a id="cXXX.330" /> class&#x2019;s <span class="FontName2">repaint</span> function. Options for the renderer are set in the <span class="FontName2">SetupGraph</span> function<a id="cXXX.331" />, described later. Each piece of the sensor&#x2019;s data is contained in a simple <span class="FontName2">XYSeries</span> variable<a id="cXXX.332" /> declared with the name on creation and will have data added to it as it is received from the Arduino board. The linear layout has to be declared so that the <span class="FontName2">registerUIobjects</span><a id="cXXX.333" /> function can add the graph to the view for the user. The buttons and the Edit text box are added in the same way as the ADK monitor. The last six variables are used to store information for the placement within the graph and the beginning limits to display, along with a Boolean to inform functions of the status of the synchronization with the Arduino board. Add the variables in <a href="#list7" id="_list7">Listing 8-7</a> to the program after the beginning of the activity class and before the first function.</p>
<p class="noindent2"><a href="#_list7" id="list7"><b><i>Listing 8-7.</i></b></a>&#160;&#160;New Variables for the Android Sensor Network Application</p>
<pre><span class="FontName2">// chart variables</span><br /><span class="FontName2">private XYMultipleSeriesDataset SensorData = new XYMultipleSeriesDataset();</span><br /><span class="FontName2">// the XYMultipleSeriesRenderer spans two lines in the book</span><br /><span class="FontName2">private XYMultipleSeriesRenderer SensorRenderer = new XYMultipleSeriesRenderer();</span><br /><span class="FontName2">private XYSeries Sensor1CurrentSeries = new XYSeries(&quot;Sensor 1&quot;);</span><br /><span class="FontName2">private XYSeries Sensor2CurrentSeries = new XYSeries(&quot;Sensor 2&quot;);</span><br /><span class="FontName2">private XYSeries Sensor3CurrentSeries = new XYSeries(&quot;Sensor 3&quot;);</span><br /><span class="FontName2">private GraphicalView SensorChartView;</span><br /><span class="FontName2">// chart container and other UI objects</span><br /><span class="FontName2">private LinearLayout layout;</span><br /><span class="FontName2">private Button buttonSync;</span><br /><span class="FontName2">private Button ScreenClear;</span><br /><span class="FontName2">private EditText DataFromArduino;</span><br /><span class="FontName2">// chart control variables</span><br /><span class="FontName2">double[] limits = new double[] {0, 500000,-127,127}; // for chart limits</span><br /><span class="FontName2">double x = 0;</span><br /><span class="FontName2">double y = 0;</span><br /><span class="FontName2">double xCount = 0;</span><br /><span class="FontName2">double lastMinX = 0;</span><br /><span class="FontName2">boolean Sync = false;</span></pre>
<p class="indent"><a href="#list8" id="_list8">Listing 8-8</a> is the function that registers the user interface objects to the code. Both of the buttons and the text box are set to the defined objects in <span class="FontName2">main.xml</span>, as was done in prior Android applications. The chart is a bit unusual because the chart view must be added to the linear layout; this is done by adding the output of <span class="FontName2">ChartFactory</span>&#x2019;s <span class="FontName2">getLineChartView</span> function to the <span class="FontName2">SensorChartView</span> variable. Some information has to be included with the <span class="FontName2">getLineChartView</span> function call&#x2014;the instance of the program along with the data set and renderer that will be used with the chart need to be passed to the function. Then the <span class="FontName2">SensorChartView</span> variable id added to the linear view before this function is finished.</p>
<p class="noindent2"><a href="#_list8" id="list8"><b><i>Listing 8-8.</i></b></a>&#160;&#160;New registerUIobjects Function<a id="cXXX.334" /></p>
<pre><span class="FontName2">private void registerUIobjects(){</span><br />&#160;&#160;<span class="FontName2">buttonSync = (Button) findViewById(R.id.syncbutton);</span><br />&#160;&#160;<span class="FontName2">ScreenClear = (Button) findViewById(R.id.clear);</span><br />&#160;&#160;<span class="FontName2">DataFromArduino = (EditText)findViewById(R.id.incomingData);</span><br />&#160;&#160;<span class="FontName2">layout = (LinearLayout) findViewById(R.id.chart);</span><br />&#160;&#160;<span class="FontName2">// the next line spans two in the book</span><br />&#160;&#160;<span class="FontName2">SensorChartView = ChartFactory.getLineChartView(this, SensorData,</span><br />&#160;&#160;<span class="FontName2">SensorRenderer);</span><br />&#160;&#160;<span class="FontName2">layout.addView(SensorChartView);</span><br /><span class="FontName2">}// end registerUIobjects</span></pre>
<p class="indent">The <span class="FontName2">SetupGraph</span> function defined in <a href="#list9" id="_list9">Listing 8-9</a> sets the options for how the graph will be rendered to the screen, and also links the individual data series to the graph. The overall options that are set include the color of the axes, the text size, the axes&#x2019; minimums and maximums, and the pan limitations. The color of the data series is controlled by individual renderers that are added to the multi-series renderer variable. There are a lot of options that can be set for the graph; be sure to check out the Java reference documentation at <span class="FontName2"><a href="http://www.achartengine.org/content/javadoc/index.html">www.achartengine.org/content/javadoc/index.html</a></span> for more in-depth information. The <span class="FontName2">SetupGraph</span> function needs to be called from the <span class="FontName2">onResume</span> function of the framework. Add the code line <span class="FontName2">SetupGraph()</span><a id="cXXX.335" /><span class="FontName2">;</span> after the <span class="FontName2">super.onResume()</span><a id="cXXX.336" /><span class="FontName2">;</span> line in the function. The <span class="FontName2">SetupGraph</span> function is called from this function to ensure that the graph will be set up correctly every time the program resumes.</p>
<p class="noindent2"><a href="#_list9" id="list9"><b><i>Listing 8-9.</i></b></a>&#160;&#160;Function That Defines How the Graph Is Drawn</p>
<pre><span class="FontName2">public void SetupGraph(){</span><br />&#160;&#160; <span class="FontName2">// set chart-drawing options</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setAxisTitleTextSize(10);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setChartTitleTextSize(10);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setLabelsTextSize(10);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setLegendTextSize(10);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setMargins(new int[] {10, 10, 10, 0});</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setAxesColor(Color.WHITE);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setShowGrid(true);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setYAxisMin(&#x2212;127);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setYAxisMax(127);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setXAxisMin(0);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setXAxisMax(100);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.setPanLimits(limits);</span><br />&#160;&#160; <span class="FontName2">// add the three series to the multi-series data set</span><br />&#160;&#160; <span class="FontName2">SensorData.addSeries(Sensor1CurrentSeries);</span><br />&#160;&#160; <span class="FontName2">SensorData.addSeries(Sensor2CurrentSeries);</span><br />&#160;&#160; <span class="FontName2">SensorData.addSeries(Sensor3CurrentSeries);</span><br />&#160;&#160; <span class="FontName2">// set color options for the data lines to match graph openFrameworks</span><br />&#160;&#160; <span class="FontName2">XYSeriesRenderer Sensor1renderer = new XYSeriesRenderer();</span><br />&#160;&#160; <span class="FontName2">Sensor1renderer.setColor(Color.GREEN);</span><br />&#160;&#160; <span class="FontName2">XYSeriesRenderer Sensor2renderer = new XYSeriesRenderer();</span><br />&#160;&#160; <span class="FontName2">Sensor2renderer.setColor(Color.YELLOW);</span><br />&#160;&#160; <span class="FontName2">XYSeriesRenderer Sensor3renderer = new XYSeriesRenderer();</span><br />&#160;&#160; <span class="FontName2">Sensor3renderer.setColor(Color.BLUE);</span><br />&#160;&#160; <span class="FontName2">// add the sensor graph with set options to the graph</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.addSeriesRenderer(Sensor1renderer);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.addSeriesRenderer(Sensor2renderer);</span><br />&#160;&#160; <span class="FontName2">SensorRenderer.addSeriesRenderer(Sensor3renderer);</span><br /><span class="FontName2">} // end SetupGraph</span></pre>
<p class="indent">The message handler function that is linked to the thread that is created to check for incoming data from the Arduino is where the program dynamically updates the graph. Because the data is well formatted at the point it is sent from the Arduino, and the data is consistently sized, the parsing is pretty straightforward&#x2014;we have only to look at specific places in the data buffer. This is only possible if the data transition is reliable; in a more refined setup, a verification step should be used to check that the transition is what is expected. The connection between the Android device and the Arduino is decently reliable, so this example does not add the verification complexity.</p>
<p class="indent">Once the data is received from the Arduino, the three sensors&#x2019; data is pulled from the 34-byte array and added as the y value to the appropriate series of data. Because the data that was sent to the Arduino from openFrameworks was normalized to a unsigned byte, you have to normalize the data back to a zero value of the sine wave function by subtracting 127 from the sensor value to make the byte signed. The x value is controlled by a count that is incremented every time a data transition is received; the same count value is added to all three series. A special function is called after the data is added to the graph to check if the data is outside of the view; if so, it will scroll to the last position, keeping the current incoming data always in the view area. The old data is not lost as the graph scrolls, and can be viewed by scrolling back to the left.</p>
<p class="indent">After the graph is printed to the screen, the entire data buffer is appended to the text box to add an extra view for possible debugging. The information in the text box could be accessed for further processing, such as saving the data to a file on the Android device. A decent tutorial on reading and writing to the storage of an Android device can be found at <span class="FontName2"><a href="http://www.java-samples.com/showtutorial.php?tutorialid=1523">www.java-samples.com/showtutorial.php?tutorialid=1523</a></span>. This tutorial can be modified to work with this example because the data is printed to a text box. <a href="#list10" id="_list10">Listing 8-10</a> replaces the existing incoming data handler within the framework.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;Some online examples for <span class="FontName2">AChartEngine</span> call for a separate thread to be created to be able update the chart dynamically for new data. This is not necessary for ADK applications, because of the existing thread used to respond to incoming information from the Mega ADK. This thread provides an event to update the graph when new data is received.</p></div>
<p class="noindent2"><a href="#_list10" id="list10"><b><i>Listing 8-10.</i></b></a>&#160;&#160;Incoming Data Handler Function<a id="cXXX.337" /></p>
<pre><span class="FontName2">Handler IncomingDataHandler = new Handler() {</span><br />&#160;&#160;<span class="FontName2">@Override</span><br />&#160;&#160;<span class="FontName2">public void handleMessage(Message msg) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">BufferData IncomingBuffer = (BufferData) msg.obj;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte[] buffer = IncomingBuffer.getBuffer();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">// pull and add sensor data to the graph</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte sen1 = (byte) (buffer[5] - 127);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte sen2 = (byte) (buffer[13] - 127);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte sen3 = (byte) (buffer[21] - 127);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Sensor1CurrentSeries.add(xCount,&#160;&#160;sen1 );</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Sensor2CurrentSeries.add(xCount,&#160;&#160;sen2 );</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Sensor3CurrentSeries.add(xCount,&#160;&#160;sen3 );</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">// check if a scroll is needed</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">refreshChart();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">xCount++;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">if (SensorChartView != null) {</span><br />&#160;&#160;&#160;&#160;&#160;&#160;<span class="FontName2">SensorChartView.repaint();</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">// add data buffer to text box</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">String str = new String(buffer);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">DataFromArduino.append(str);</span><br />&#160;&#160;<span class="FontName2">}// end handleMessage(Message msg)</span><br /><span class="FontName2">};// end Handler IncomingDataHandler = new Handler()</span></pre>
<p class="indent">The <span class="FontName2">refreshChart</span> function<a id="cXXX.338" /> described in <a href="#list11" id="_list11">Listing 8-11</a> provides the mechanism to scroll the graph when the current incoming data exceeds the view area on the screen. The scroll is accomplished by checking if the current x value count is greater than the highest value of the graph being drawn. When the count is greater, the function increments the minimum x value and sets the values of the minimum and the new maximum to the graph, creating the scrolling effect.</p>
<p class="noindent2"><a href="#_list11" id="list11"><b><i>Listing 8-11.</i></b></a>&#160;&#160;Function to Keep the Graph Focused on the Most Current Data</p>
<pre><span class="FontName2">private void refreshChart() {</span><br />&#160;&#160;<span class="FontName2">// check if a shift of the graph view is needed</span><br />&#160;&#160;<span class="FontName2">if (xCount &#x003E; SensorRenderer.getXAxisMax()) {</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorRenderer.setXAxisMax(xCount);</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">SensorRenderer.setXAxisMin(++lastMinX);</span><br />&#160;&#160;<span class="FontName2">}</span><br />&#160;&#160;<span class="FontName2">SensorChartView.repaint();</span><br /><span class="FontName2">}</span></pre>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Caution</b>&#160;&#160;The graph will fail to redraw when the Android device rotates to a new orientation. This happens because the application has not been programmed to handle the screen-rotation event.</p></div>
<p class="indent"><a href="#list12" id="_list12">Listing 8-12</a> shows the last two functions needed to complete the Android application. The first function is the <span class="FontName2">clearScreen</span> function<a id="cXXX.339" />, associated with the Clear button. The <span class="FontName2">clearScreen</span> function sends a command of an ASCII <span class="FontName2">b</span> to the Arduino to inform it that the Android device is no longer synchronized. The <span class="FontName2">clearScreen</span> function then performs an operation to reset the graph and the text box back to their initial settings.</p>
<p class="indent">The <span class="FontName2">SyncData</span> function<a id="cXXX.340" /> is associated with the Sync button on the user interface; it first checks whether the data is currently synchronized to avoid resending the data when the button is clicked multiple times. The <span class="FontName2">SyncData</span> function send an ASCII command of <span class="FontName2">a</span> to the Arduino, initiating the transfer of the <span class="FontName2">sensor.log</span> file located on the SD card attached to the Arduino. The transfer is captured by the running thread that is checking for incoming data. The Arduino transfers 34 bytes at a time to the Android device, and the information of the three sensors is added to the graph. While the Arduino is connected and the data has been synchronized, new data will be transferred to the Android device and recorded to the log file on the SD card.</p>
<p class="noindent2"><a href="#_list12" id="list12"><b><i>Listing 8-12.</i></b></a>&#160;&#160;Clear-Screen and Sync-Data Button Events</p>
<pre><span class="FontName2">public void clearScreen(View v) {</span><br />&#160;&#160;<span class="FontName2">byte[] BytestoSend = new byte[1];</span><br />&#160;&#160;<span class="FontName2">BytestoSend[0] = &#x0027;b&#x0027;;</span><br />&#160;&#160;<span class="FontName2">write(BytestoSend);</span><br />&#160;&#160;<span class="FontName2">Sensor1CurrentSeries.clear();</span><br />&#160;&#160;<span class="FontName2">Sensor2CurrentSeries.clear();</span><br />&#160;&#160;<span class="FontName2">Sensor3CurrentSeries.clear();</span><br />&#160;&#160;<span class="FontName2">xCount = 0 ;</span><br />&#160;&#160;<span class="FontName2">lastMinX = 0 ;</span><br />&#160;&#160;<span class="FontName2">SensorRenderer.setYAxisMin(&#x2212;127);</span><br />&#160;&#160;<span class="FontName2">SensorRenderer.setYAxisMax(127);</span><br />&#160;&#160;<span class="FontName2">SensorRenderer.setXAxisMin(0);</span><br />&#160;&#160;<span class="FontName2">SensorRenderer.setXAxisMax(100);</span><br />&#160;&#160;<span class="FontName2">Sync = false ;</span><br />&#160;&#160;<span class="FontName2">SensorChartView.repaint();</span><br />&#160;&#160;<span class="FontName2">DataFromArduino.setText(null);</span><br /><span class="FontName2">}// end clearScreen</span><br /><br /><span class="FontName2">public void SyncData(View v) {</span><br />&#160;&#160;<span class="FontName2">if (!Sync){</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">byte[] BytestoSend = new byte[1];</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">BytestoSend[0] = &#x0027;a&#x0027;;</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">write(BytestoSend); // sends buffer to the ADK</span><br />&#160;&#160;&#160;&#160;<span class="FontName2">Sync = true;</span><br />&#160;&#160;<span class="FontName2">}</span><br /><span class="FontName2">} // end void SyncData(View v)</span></pre>
<p class="indent">After the updates described in this example are added to the ADK framework and a final check for errors is done, the application can be uploaded to a target Android device. Start and run the openFrameworks program and the Arduino without the Android connected, and let them run for a while to build some data in the log file. When a sufficient amount of data is sent, connect the Android device without restarting the Arduino. A pop-up menu should appear, asking for permission to run a program. Select the ADK Sensor Network program. Synchronize the data when the program is ready, and observe the graph and compare to the one drawn by the openFrameworks program. The red line in the openFrameworks program should match the last position of the Android graph.</p>
<div class="notepara">
<p class="paraaftertitle1"><img src="images/sq.jpg" alt="image"/>&#160;<b>Note</b>&#160;&#160;The Android application may have to be forcefully stopped each time it is run because the thread sometimes does not stop properly. More robust thread handling is required for final products.</p></div>
<p id="Sec5" class="Heading1">Summary</p>
<p class="noindent">The example series in this chapter showed one method of integrating Android into a sensor network and provided a review of other concepts introduced in other chapters of this book. The possible combinations of what the sensor network observes and measures and the different technologies that can be used to achieve a final product are limitless. The example series is not intended to be a final product, but a starting point for further exploration into sensor networks and integration. An extra challenge that can be tackled with this chapter&#x2019;s concepts is using a third XBee module and another USB adapter connected to a different computer to add three more simulated sensors. The most important thing about sensor networks, Arduino, and Android is that you should explore the technology to get more familiar with more advanced techniques so you can use them in future projects.</p>
</div>
</body>
</html>